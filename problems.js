const data = [
  {
    title: "2331. Evaluate Boolean Binary Tree",
    description:
      "You are given the root of a full binary tree with the following properties:\n\n\n\tLeaf nodes have either the value 0 or 1, where 0 represents False and 1 represents True.\n\tNon-leaf nodes have either the value 2 or 3, where 2 represents the boolean OR and 3 represents the boolean AND.\n\n\nThe evaluation of a node is as follows:\n\n\n\tIf the node is a leaf node, the evaluation is the value of the node, i.e. True or False.\n\tOtherwise, evaluate the node's two children and apply the boolean operation of its value with the children's evaluations.\n\n\nReturn the boolean result of evaluating the root node.\n\nA full binary tree is a binary tree where each node has either 0 or 2 children.\n\nA leaf node is a node that has zero children.\n\n \nExample 1:\n\nInput: root = [2,1,3,null,null,0,1]\nOutput: true\nExplanation: The above diagram illustrates the evaluation process.\nThe AND node evaluates to False AND True = False.\nThe OR node evaluates to True OR False = True.\nThe root node evaluates to True, so we return true.\n\nExample 2:\n\nInput: root = [0]\nOutput: false\nExplanation: The root node is a leaf node and it evaluates to false, so we return false.\n\n\n \nConstraints:\n\n\n\tThe number of nodes in the tree is in the range [1, 1000].\n\t0 <= Node.val <= 3\n\tEvery node has either 0 or 2 children.\n\tLeaf nodes have a value of 0 or 1.\n\tNon-leaf nodes have a value of 2 or 3.\n\n",
    difficulty: "Easy",
    acceptance: "50.39",
    frequency: "12.58",
    topics: [
      [
        "Brainteaser",
        "Iterator",
        "Ordered Set",
        "Shell",
        "Memoization",
        "Rolling Hash",
        "Bucket Sort",
        "Binary Search",
        "Greedy",
        "Segment Tree",
      ],
    ],
    languages: [
      [
        "TypeScript",
        "Kotlin",
        "Python3",
        "C#",
        "Racket",
        "Elixir",
        "Scala",
        "C++",
        "Rust",
        "Ruby",
      ],
    ],
    comments: [
      {
        author_id: "678",
        problem_id: 1,
        body: "Иногда лучшее решение приходит в голову после нескольких неудачных попыток.",
        comment_reply_id: null,
      },
      {
        author_id: "804",
        problem_id: 1,
        body: "Я просто в восторге от того, как эффективно работает мое решение!",
        comment_reply_id: null,
      },
      {
        author_id: "282",
        problem_id: 1,
        body: "Вот почему я люблю программирование - за такие интересные задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "55",
        problem_id: 1,
        body: "Сколько времени я потратил на решение этой задачи? Не считаясь!",
        comment_reply_id: null,
      },
      {
        author_id: "35",
        problem_id: 1,
        body: "Какие интересные подходы у других людей к этой задаче",
        comment_reply_id: null,
      },
      {
        author_id: "854",
        problem_id: 1,
        body: "Наконец-то, я разобрался с этой задачей! Спасибо за все подсказки.",
        comment_reply_id: null,
      },
      {
        author_id: "291",
        problem_id: 1,
        body: "Как приятно видеть, что мое решение работает!",
        comment_reply_id: null,
      },
      {
        author_id: "268",
        problem_id: 1,
        body: "Не могу поверить, что я наконец-то разобрался с этой задачей. Спасибо, сообщество!",
        comment_reply_id: null,
      },
      {
        author_id: "266",
        problem_id: 1,
        body: "Вот почему я люблю программирование - за такие интересные задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "151",
        problem_id: 1,
        body: "Чувствую, что становлюсь лучше с каждой решенной задачей!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title:
          "✅Detailed Explanation🔥2 Approaches🔥🔥Extremely Simple and effective🔥🔥🔥",
        body: "🎯Problem Explanation:\nYou are given a root of full binary tree (that means that every its node has either 0 or 2 children) and you need to evaluate tree with following rules:\n\nIf nodes value is 2 - that means boolean \"OR\"\nIf nodes value is 3 - that means boolean \"AND\"\nIf node is leaf then its value is either 1 or 0 (as integers) which corresponds to boolean True and False respectivily\n\n📥Input:\n\nroot of the binary tree root\n\n📤Output:\nThe evaluated result for root\n🤔 Intuition\n\nThe first thing to think about is that in order to estimate the values ​​of the upper branches, we must necessarily estimate the values ​​of the lower ones, that is, we need to go from bottom to top to evaluate the entire tree.\nIn fact, this is enough for us to solve this problem. The recursion solution is almost trivial, but recursive solutions are often worse than iterative solutions due to the \"recursion depth\" limit, so what about the iterative solution? Is it possible? Short answer - yes.\n\n🧠 Approach 1: Recursion\nThe logic for recursion is very simple, we just need to apply the following conditions for each node:\n\nIf current node is leaf then return its value\nIf current node isn't leaf and its value is 2, then call recursion on left and right children and use boolean \"OR\" on results\nIf current node isn't leaf and its value is 3, then call recursion on left and right children and use boolean \"AND\" on results\n\n\nExample\nSo this is it for recursive solution, if this still not clear to you look at the following example:\n        3\n       / \\\n      0   2\n         / \\\n        0   1\nStep 1: Evaluate the leaf nodes.\n\nNode with value 0 evaluates to False.\nNode with value 0 evaluates to False.\nNode with value 1 evaluates to True.\n\nStep 2: Evaluate next node (the non-leaf node with value 2 (OR operation)).\n\nLeft child (value 0) evaluates to False.\nRight child (value 1) evaluates to True.\nPerform OR operation: False OR True = True.\n\nStep 3: Evaluate next node (the non-leaf (root) node with value 3 (AND operation)).\n\nLeft child (value 0) evaluates to False.\nRight child (value 2) evaluates to True (from Step 2).\nPerform AND operation: False AND True = False.\n\nStep 4: Return the final result.\n\nThe root node evaluates to False, so the output is False.\nThus, the output for the given binary tree is False.\n\n📒 Complexity\n\n⏰ Time complexity: O(n), since we for through each node once\n🧺 Space complexity: O(n), we use recursion (there will be n calling of function)\n\n🧑‍💻 Code\nPythonC++class Solution:\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\n        if not root.left and not root.right:\n            return root.val\n\n        if root.val == 2:\n            return self.evaluateTree(root.left) or self.evaluateTree(root.right)\n        elif root.val == 3:\n            return self.evaluateTree(root.left) and self.evaluateTree(root.right)\n🧠 Approach 2: Iterative\nThe logic for iterative solution is much harder to understand so don't worry if you haven't came up with it by yourself:\n\nWe want to imitate the thing we do in recursion - we want to first evaluate leafs and then go 1 level back every time. To do so we will use pretty common data structure for iterative binary tree solutions - stack.\nSo now, while we have any node in the stack we want to apply this logic:\n\nIf current node is the leaf, then we want to \"remember\" its value to evaluate other nodes and delete it from stack since we don't need it anymore.\nIf current node isn't the leaf and we already know the evaluation for its left and right children then we want to \"remember\" its calculated value and then delete it from stack, since we already know its value\nIf current node isn't the leaf and we still don't know values of its children - then we want to add this children to stack to evaluate first them and then return to this node. We don't want to remove this node from stack, since we want to return to it after we evaluate its children!!!\n\n\nAfter evaluating all nodes we want to just return the evaluated value for root. By the way, I've been using this word \"remember\" but what do I mean? So, we want to keep some data structure to know evaluating for every node in this tree, so dictionary, where key is the node and the value is its value is our best choice.\n\n\nP.S. Look for more hints in code as I write them when coding this solution\n\n📒 Complexity\n\n⏰ Time complexity: O(n), since we go through each node once (Or twice at max, but that doesn't matter for complexity)\n🧺 Space complexity: O(n), we use stack and dictionary which is O(2n) -> O(n)\n\n🧑‍💻 Code\nclass Solution:\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\n        stack = [root]\n        res: dict[TreeNode, int] = {} # dictionaty node -> value (0 - False, 1 - True) \n\n        while stack:\n            last_node = stack[-1] # Take the node which we've added last iteration\n            if not last_node.left and not last_node.right: # if this node is leaf\n                stack.pop() # we don't need this node anymore\n                res[last_node] = last_node.val\n\n            if last_node.left in res and last_node.right in res: # if this node isn't leaf and we've already calculated its childrens' values\n                stack.pop(-1) # we don't need this node anymore\n                if last_node.val == 2:\n                    res[last_node] = res[last_node.left] or res[last_node.right]\n                elif last_node.val == 3:\n                    res[last_node] = res[last_node.left] and res[last_node.right]\n            elif last_node.left and last_node.right: # if this node isn't leaf but we haven't evaluated its children\n                stack.append(last_node.left)\n                stack.append(last_node.right)\n\n        return res[root]\n💡I encourage you to check out my profile and Project-S project for detailed explanations and code for different problems (not only Leetcode). Happy coding and learning! 📚\nPlease consider upvote because I try really hard not just to put here my code and rewrite testcase to show that it works but explain you WHY it works and HOW. Thank you❤️\nIf you have any doubts or questions feel free to ask them in comments. I will be glad to help you with understanding❤️❤️❤️\n",
        views: "215",
        upvotes: "9",
        author_id: "460",
        problem_id: 1,
      },
      {
        title: "",
        body: "",
        views: 0,
        upvotes: 0,
        author_id: "881",
        problem_id: 1,
      },
      {
        title: "✅Recursive with Anonymous func ✅",
        body: "\nComplexity\n\n\nTime complexity: O(N)\n\n\nSpace complexity: O(1)\n\n\nThere is used anonymous function with recursive.\nCode\nfunc evaluateTree(root *TreeNode) bool {\n    // Just declare for using calc function in recursive\n\tvar calc func(node *TreeNode) bool\n\n\tcalc = func(node *TreeNode) bool {\n        // for left and right nodes\n\t\tleft, right := false, false\n        // left value\n\t\tif node.Left != nil {\n\t\t\tleft = calc(node.Left)\n\t\t}\n        // right value\n\t\tif node.Right != nil {\n\t\t\tright = calc(node.Right)\n\t\t}\n\n        // if now OR, we return left and right result\n\t\tif node.Val == 2 {\n\t\t\treturn left || right\n\t\t}\n        // if now AND, we return left and right result\n\t\tif node.Val == 3 {\n\t\t\treturn left && right\n\t\t}\n\n        // if Val is 1, result is true, or false\n\t\treturn node.Val == 1\n\t}\n\n    // last, we need to call our anonym calc function\n\treturn calc(root)\n}",
        views: "613",
        upvotes: "18",
        author_id: "213",
        problem_id: 1,
      },
      {
        title: "Fully Visual Explanation in Java/C++/Python",
        body: "The question is very simple, let's break it down and understand it!\nWe have a tree, which has these 4 types of value. And each value respresent something,\n\n\n0 -> FALSE\n\n\n1 -> TRUE\n\n\n2 -> OR\n\n\n3 -> AND\n\n\n\nBut the value going to be present in the number form >\n\nOr we can look at it's graphical representation for better understanding >\n\nLet's start solving the problem,\nTo start the traversal, we going to use Post Order Traversal\nThe, post order traversal principle say's :\nFirst traverse to #LEFT\nThen to #RIGHT\nand finally to #ROOT\nLet's understand with an example and doing the traversal with the help of ANIMATION\n\nLet\\s code it up :\nJAVA\nclass Solution {\n    public boolean evaluateTree(TreeNode root) {\n        // Base condition, if it's a leaf node\n        if(root.left == null && root.right == null){\n            if(root.val == 0) return false;\n            return true;\n        }\n        // If it's not a leaf node, then go to left subtree\n        boolean left = evaluateTree(root.left);\n        // then go to right subtree\n        boolean right = evaluateTree(root.right);\n        // OR operation\n        if(root.val == 2) return left || right;\n        return left && right; // AND operation\n    }\n}\nC++\nclass Solution {\npublic:\n    bool evaluateTree(TreeNode* root) {\n        // Base condition, if it's a leaf node\n        if(root->left == nullptr && root->right == nullptr){\n            if(root->val == 0) return false;\n            return true;\n        }\n        // If it's not a leaf node, then go to left subtree\n        bool left = evaluateTree(root->left);\n        // then go to right subtree\n        bool right = evaluateTree(root->right);\n        // OR operation\n        if(root->val == 2) return left || right;\n        return left && right; // AND operation\n    }\n};\nPYTHON\nclass Solution(object):\n    def evaluateTree(self, root):\n        # Base condition, if it's a leaf node\n        if not root.left and not root.right:\n            if root.val == 0:\n                return False\n            return True\n        # If it's not a leaf node, then go to left subtree\n        left = self.evaluateTree(root.left)\n        # then go to right subtree\n        right = self.evaluateTree(root.right)\n        # OR operation\n        if root.val == 2:\n            return left or right\n        return left and right  # AND operation\n\nLet's talk about\n\n\n\nTime Complexity :- BigO(N), there were N nodes, it took O(N) time.\n\n\nSpace Complexity :- BigO(logN), we use recursion (a kind of loop where a function calls itself) to go through the tree. In the worst case it could be BigO(N) too\n\n",
        views: "1990",
        upvotes: "22",
        author_id: "61",
        problem_id: 1,
      },
    ],
  },
  {
    title: "1. Two Sum",
    description:
      "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\n \nConstraints:\n\n\n\t2 <= nums.length <= 104\n\t-109 <= nums[i] <= 109\n\t-109 <= target <= 109\n\tOnly one valid answer exists.\n\n\n \nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
    difficulty: "Easy",
    acceptance: "12.10",
    frequency: "122.76",
    topics: [
      [
        "Line Sweep",
        "Counting",
        "Linked List",
        "Divide and Conquer",
        "Design",
        "Segment Tree",
        "Radix Sort",
        "Minimum Spanning Tree",
        "Heap (Priority Queue)",
        "Depth-First Search",
      ],
    ],
    languages: [
      [
        "JavaScript",
        "Ruby",
        "Elixir",
        "Python",
        "PHP",
        "Racket",
        "TypeScript",
        "Erlang",
        "Scala",
        "C#",
      ],
    ],
    comments: [
      {
        author_id: "745",
        problem_id: 2,
        body: "Чувствую себя настоящим гений после того, как решил эту задачу!",
        comment_reply_id: null,
      },
      {
        author_id: "953",
        problem_id: 2,
        body: "Сложно поверить, что я только что решил это! Спасибо всем за поддержку.",
        comment_reply_id: null,
      },
      {
        author_id: "159",
        problem_id: 2,
        body: "Всегда думал, что эта задача невозможна. Но вот я, сделал это!",
        comment_reply_id: null,
      },
      {
        author_id: "336",
        problem_id: 2,
        body: "Эта задача заставила меня использовать все свои ресурсы!",
        comment_reply_id: null,
      },
      {
        author_id: "130",
        problem_id: 2,
        body: "Эта задача преподнесла мне неожиданный поворот! Интересно, как многие это заметили.",
        comment_reply_id: null,
      },
      {
        author_id: "332",
        problem_id: 2,
        body: "Наконец-то, я разобрался с этой задачей! Спасибо за все подсказки.",
        comment_reply_id: null,
      },
      {
        author_id: "909",
        problem_id: 2,
        body: "Как я мог не догадаться о таком подходе? Спасибо за отличное объяснение!",
        comment_reply_id: null,
      },
      {
        author_id: "982",
        problem_id: 2,
        body: "Я просто в восторге от того, как эффективно работает мое решение!",
        comment_reply_id: null,
      },
      {
        author_id: "461",
        problem_id: 2,
        body: "Всегда думал, что эта задача невозможна. Но вот я, сделал это!",
        comment_reply_id: null,
      },
      {
        author_id: "875",
        problem_id: 2,
        body: "Это было как головоломка, но я нашел свой путь к решению!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title:
          "✅3 Method's || C++ || JAVA || PYTHON || Beginner Friendly🔥🔥🔥",
        body: "Intuition\n\nThe Two Sum problem asks us to find two numbers in an array that sum up to a given target value. We need to return the indices of these two numbers.\nApproach\n\n\nOne brute force approach is to consider every pair of elements and check if their sum equals the target. This can be done using nested loops, where the outer loop iterates from the first element to the second-to-last element, and the inner loop iterates from the next element to the last element. However, this approach has a time complexity of O(n^2).\nA more efficient approach is to use a hash table (unordered_map in C++). We can iterate through the array once, and for each element, check if the target minus the current element exists in the hash table. If it does, we have found a valid pair of numbers. If not, we add the current element to the hash table.\n\nApproach using a hash table:\n\nCreate an empty hash table to store elements and their indices.\nIterate through the array from left to right.\nFor each element nums[i], calculate the complement by subtracting it from the target: complement = target - nums[i].\nCheck if the complement exists in the hash table. If it does, we have found a solution.\nIf the complement does not exist in the hash table, add the current element nums[i] to the hash table with its index as the value.\nRepeat steps 3-5 until we find a solution or reach the end of the array.\nIf no solution is found, return an empty array or an appropriate indicator.\n\nThis approach has a time complexity of O(n) since hash table lookups take constant time on average. It allows us to solve the Two Sum problem efficiently by making just one pass through the array.\nCode\nSolution 1: (Brute Force)\nC++JavaPython3class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (nums[i] + nums[j] == target) {\n                    return {i, j};\n                }\n            }\n        }\n        return {}; // No solution found\n    }\n};\n\nSolution 2: (Two-pass Hash Table)\nC++JavaPython3class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> numMap;\n        int n = nums.size();\n\n        // Build the hash table\n        for (int i = 0; i < n; i++) {\n            numMap[nums[i]] = i;\n        }\n\n        // Find the complement\n        for (int i = 0; i < n; i++) {\n            int complement = target - nums[i];\n            if (numMap.count(complement) && numMap[complement] != i) {\n                return {i, numMap[complement]};\n            }\n        }\n\n        return {}; // No solution found\n    }\n};\n\nSolution 3: (One-pass Hash Table)\nC++JavaPython3class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> numMap;\n        int n = nums.size();\n\n        for (int i = 0; i < n; i++) {\n            int complement = target - nums[i];\n            if (numMap.count(complement)) {\n                return {numMap[complement], i};\n            }\n            numMap[nums[i]] = i;\n        }\n\n        return {}; // No solution found\n    }\n};\n\n\nIf you are a beginner solve these problems which makes concepts clear for future coding:\n\nTwo Sum\nRoman to Integer\nPalindrome Number\nMaximum Subarray\nRemove Element\nContains Duplicate\nAdd Two Numbers\nMajority Element\nRemove Duplicates from Sorted Array\nPractice them in a row for better understanding and please Upvote for more questions.\n\nIf you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.",
        views: "1076405",
        upvotes: "5.8K",
        author_id: "827",
        problem_id: 2,
      },
      {
        title: "【Video】 HashMap Solution",
        body: "Intuition\nUse HashMap to keep numbers and their indices we found.\nSolution Video\n\n⭐️⭐️ Don't forget to subscribe to my channel! ⭐️⭐️\n■ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\nSubscribers: 4,540\nThank you for your support!\n\nApproach\nIf you check all possible pairs, we need two loops which is O(n2)O(n^2)O(n2).\nInput: nums = [2,7,11,15], target = 9\nAll possible pairs are\n[2,2][2,7][2,11][2,15] = 4\n[7,2][7,7][7,11][7,15] = 4\n[11,2][11,7][11,11][11,15] = 4\n[15,2][15,7][15,11][15,15] = 4\n\ntotal 16 pairs\nAnd then, we need to the right pair among them. They are including invalid pairs but at least we need to iterate input array 16 times which is 4^2. 4 is the length of input array.\nLooping 16 times is not a big deal. But what if we have 100 or 1000 numbers as an input array. Do we loop 10000 or 1000000 times?\nThat's why if we can improve the time complexity to O(n)O(n)O(n), we will loop 100 or 1000 at most. It's much much much better right?\nHow can we improve the time complexity?\nMy answer is to use a memory to keep results of something my solution code has done.\n\n⭐️ Points\nUse a memory to keep data for something to improve time complexity.\n\nIn this case, HashMap is good data structure.\nWhat is data we should keep with HashMap?\nLet's take a look at input array and target number.\nInput: nums = [2,7,11,15], target = 9\nIn this case, if we subtract current number in input array from target number, we can get a number we need to create the target number.\nFor example,\n9 - 2 = 7\n7 is a number we need when current number is 2. So if we have 7 and index number of 7, we can create 9 with the current(= 2) number and 7.\nFrom this example, what we should keep in HashMap is\n\n⭐️ Points\nKeep numbers(elements) as keys and index numbers as values in the input array.\n\nLet's iterate through one by one.\nInput: nums = [2,7,11,15], target = 9\nLet's call the HashMap pair_idx.\n[2,7,11,15], target = 9\n　　↑\n\npair_idx = {} \nWe found 2. we need 7 to create 9, so check if we have 7 in pair_idx. But now pair_idx is empty, so just add current number and its index to pair_idx.\npair_idx = {2: 0} \n\n2 is current number\n0 is index of 2\nThen move next.\n[2,7,11,15], target = 9\n　　  ↑\n\npair_idx = {2: 0}\nWe found 7, so we need 2. Check if we have 2 in pair_idx. And yes we have 2.\nreturn [0,1] or [1,0]\nThe description says \"You can return the answer in any order\".\nWe already found the answer but if we continue that\npair_idx = {2: 0, 7: 1}\n[2,7,11,15], target = 9\n　　     ↑\n\nWe need 9 - 11 = -2 but no -2 in pair_idx, so\npair_idx = {2: 0, 7: 1, 11: 2}\npair_idx = {2: 0, 7: 1, 11: 2}\n[2,7,11,15], target = 9\n　　        ↑\n\nWe need 9 - 15 = -6 but no -6 in pair_idx, so\npair_idx = {2: 0, 7: 1, 11: 2, 15: 3}\nEasy!😄\nLet's see solution codes and step by step algorithm!\n\n⭐️ I recently created a video on how I've been using LeetCode to learn.\n\n\nComplexity\n\n\nTime complexity: O(n)O(n)O(n)\nn is number of elements in input array.\n\n\nSpace complexity: O(n)O(n)O(n)\nn is number of elements in input array. In the worst case, we put all numbers in pair_idx.\n\n\nPythonJavaScriptJavaC++class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        pair_idx = {}\n\n        for i, num in enumerate(nums):\n            if target - num in pair_idx:\n                return [i, pair_idx[target - num]]\n            pair_idx[num] = i\nStep by step algorithm\n\nInitializing a Dictionary:\n\npair_idx = {}\n\nWe initialize an empty dictionary called pair_idx. This dictionary will be used to store the indices of numbers encountered during the iteration.\n\n\nIterating Through the List:\n\nfor i, num in enumerate(nums):\n\nWe use the enumerate() function to iterate through the nums list along with their indices.\nAt each iteration, i represents the index of the current number, and num represents the actual value.\n\n\nChecking for Complementary Pair:\n\nif target - num in pair_idx:\n\nWe check if the difference target - num exists as a key in the pair_idx dictionary.\nIf it exists, it means that we have found a pair of numbers whose sum equals the target.\n\n\nReturning the Result:\n\nreturn [i, pair_idx[target - num]]\n\nIf we find the complementary pair, we return a list containing the indices of the current number i and the index of the complementary number stored in the pair_idx dictionary.\n\n\nStoring Number Indices:\n\npair_idx[num] = i\n\nIf the complementary pair is not found, we store the current number num along with its index i in the pair_idx dictionary.\nThis allows us to later look up whether the complementary number exists in the list.\n\nIn summary, this algorithm efficiently finds a pair of numbers in the nums list whose sum equals the target value. It does so by using a dictionary to store the indices of numbers encountered so far and checking for the existence of complementary numbers during the iteration.\n\nThank you for reading my post. Please upvote it and don't forget to subscribe to my channel!\n⭐️ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n⭐️ Twitter\nhttps://twitter.com/CodingNinjaAZ\n⭐️ Related question #167 - Two Sum Ⅱ\nvideo\n",
        views: "2520",
        upvotes: "12",
        author_id: "129",
        problem_id: 2,
      },
      {
        title:
          "Solution  - C++/Java/Python  (Both Brute force & Optimized Code)",
        body: "Beginner Doubt's -\n\nLets Connect on LinkedIn (Leave a note) - https://www.linkedin.com/in/arajankit/\nJoin my Telegram Chyannel for Exclusive Internships & Jobs - @letsgocareer (https://t.me/letsgocareer)\nI am goint to solve all Leetcode Problems. If you are intrested to contribute. Please visit my github repo to contribute - https://github.com/arajAnkit/Leetcode-OpenSource\n\n2. Time complexity of second solution is O(N ^ 2) OR O(N logN) Instead of O(N)?\n\nI have explained well how the time complexity of the second solution is O(N). Its explanation is written below the solution.\n\nProblem Constraints\n\nTest cases written like more than one solution cannot exist. Either solution exist or not.\n\nBrute Force Approach\n\nRun two nested loops to check every possible pair of numbers in the given array to see if they add up to the target sum.\nIf they add up to the target sum return the indexes.\n\nBrute Force Code\nC++JavaPythonclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                if (nums[i] + nums[j] == target) {\n                    return {i, j};\n                }\n            }\n        }\n        return {};\n    }\n};\n\nComplexity\n\nTime complexity: O(N^2);\nSpace Complexity: O(1);\n\n\nOptimized Code - TWO PASS HASH TABLE SOLUTION\nC++JavaPython#include <unordered_map>\n \nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        // Declare an unordered map to store the numbers and their indices\n        unordered_map<int, int> mp;\n       \n        // Loop through the array\n        for(int i = 0; i < nums.size(); i++){\n            // Check if the complement of the current number exists in the map\n            if(mp.find(target - nums[i]) == mp.end())\n                // If not, add the current number and its index to the map\n                mp[nums[i]] = i;\n            else\n                // If yes, return the indices of the current number and its complement\n                return {mp[target - nums[i]], i};\n        }\n \n        // If no pair is found, return {-1, -1} as a default value\n        return {-1, -1};\n    }\n};\n\n\nComplexity\n\nTime complexity: O(N);\nSpace Complexity: O(N);\n\nDRY Run\nSuppose we have an array nums = [2, 7, 11, 15] and a target of target = 9. We want to find two numbers in nums that add up to target.\nInitially, the unordered_map mp is empty. We start iterating through the array from left to right.\nFor the first element nums[0] = 2, we check if its complement target - nums[0] = 7 exists in the map by using the find() method. Since it does not exist in the map, we add the key-value pair (2, 0) to the map. The map now looks like this: {2: 0}.\nFor the second element nums[1] = 7, we check if its complement target - nums[1] = 2 exists in the map. Since it does exist in the map, we return the indices mp[2] = 0 and i = 1 as a vector {0, 1}.\nTherefore, the code returns the expected output of [0, 1], indicating that the indices of the two elements that add up to the target are 0 and 1.\n\nOptimized Code - ONE PASS HASH TABLE SOLUTION\nclass Solution {\npublic:\n    Solution() {\n        ios_base ::sync_with_stdio(false);\n        cin.tie(NULL);\n        cout.tie(NULL);\n    }\n    vector<int> twoSum(vector<int>& nums, int target) {\n        // Declare a hash map to store the numbers and their indices\n        unordered_map<int, int> mp;\n        // Loop through the array\n        for (int i = 0; i < nums.size(); i++) {\n            // Calculate the complement of the current number\n            int complement = target - nums[i];\n            // Check if the complement exists in the hash map\n            if (mp.count(complement)) {\n                // If yes, return the indices of the current number and its\n                // complement\n                return {mp[complement], i};\n            }\n            // If not, add the current number and its index to the hash map\n            mp[nums[i]] = i;\n        }\n        // If no pair is found, return an empty vector as a default value\n        return {-1, -1};\n    }\n};\n\nComplexity\n\nTime complexity: O(N);\nSpace Complexity: O(N);\n\n\nQN - How the time complexity of above solution is O(N)?\n\n\nFirst understand about unordered_map implementation -\n\nunordered_map uses a hash table to store the key-value pairs, while map uses a self-balancing binary search tree to store the key-value pairs.\nunordered_map does not maintain any order among the elements, while map stores the elements in sorted order by their keys.\nunordered_map has an average constant-time complexity for search, insertion & deletion of elements, while map has a logarithmic-time complexity for these operations.\n\n\n\nNow we will know what FIND & COUNT function does in unordered_map -\n\nfind(key) method: Searches for an element with the specified key in the unordered_map. And return the iterator pointing to the found element if the key exists.\ncount(key) method: Counts the number of elements with the specified key in the unordered_map. And return 1 if the key exists &\n0 if the key is not found.\n\n\n\nNow we understand when the average case of time complexity arises in unordered_map -\n\nThe average case time complexity of O(1) for find and count operations in unordered_map arises when these conditions are met: Good Hash Functon, Reasonable Load Factor, Effective Collision Resolution.\nAccording to the problem statement & Constraints of Two sum problem - Always average case of time complexity arise. Because constraints & There are no collision in the testcases.\n\n\n\n\nSo the time complexity of find() & count() is O(1) for this question. And Over All time complexity of tthe solution is O(N).\nBe Happy Now ????????????? or Ek upvote to banta hai ???????\n\nUpvote Me If You Like It\n",
        views: "560045",
        upvotes: "1.4K",
        author_id: "219",
        problem_id: 2,
      },
      {
        title: "✅ 99.22% 4 Method || C++ | Java  || JavaScript  || Python💯🔥",
        body: "**Read article Explaination and codes : https://bit.ly/two-2-sum\nThe LeetCode Two Sum 1 problem is a popular coding challenge that requires finding the indices of two numbers in an array that add up to a specific target. The problem statement provides an array of integers and a target value, and the task is to return the indices of the two numbers that sum up to the target.\nOne approach to solve this problem efficiently is by using a hash map or dictionary. We can iterate through the given array, checking if the complement of each element (target minus current element) exists in our hash map. If it does, we have found our solution and can return the indices. Otherwise, we add the current element and its index to our hash map for future reference.\nAnother possible solution is by using two pointers. We can sort the array first and then initialize two pointers at the beginning and end of the array. By comparing their sum with the target value, we can move either pointer closer to each other until we find a match or exhaust all possibilities.\nBoth approaches have a time complexity of O(n), where n is the length of the input array. However, using a hash map might be more efficient when dealing with large arrays or when multiple solutions are expected.\n\nExplanation  Eg.\nTime Complexity:\nBruteforce: O(n^2)\nHashMap: O(n)\nTwo pass Hashmap: O(n)\nTwo Pointer: O(n log n)\n\n\nPython :\nJava:\nc++:\nJavaScript:\nRead Whole article :https://bit.ly/two-2-sum\n",
        views: "2896",
        upvotes: "11",
        author_id: "621",
        problem_id: 2,
      },
    ],
  },
  {
    title: "2. Add Two Numbers",
    description:
      "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n \nExample 1:\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\n\nExample 2:\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\n\nExample 3:\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n\n \nConstraints:\n\n\n\tThe number of nodes in each linked list is in the range [1, 100].\n\t0 <= Node.val <= 9\n\tIt is guaranteed that the list represents a number that does not have leading zeros.\n\n",
    difficulty: "Medium",
    acceptance: "14.11",
    frequency: "153.00",
    topics: [
      [
        "Probability and Statistics",
        "Depth-First Search",
        "Monotonic Stack",
        "Counting Sort",
        "Segment Tree",
        "Line Sweep",
        "Matrix",
        "Suffix Array",
        "Game Theory",
        "Collapse",
      ],
    ],
    languages: [
      [
        "Erlang",
        "PHP",
        "C#",
        "Elixir",
        "TypeScript",
        "JavaScript",
        "Rust",
        "Scala",
        "Kotlin",
        "Swift",
      ],
    ],
    comments: [
      {
        author_id: "185",
        problem_id: 3,
        body: "Потратил на решение этой задачи весь день, но это было того стоило!",
        comment_reply_id: null,
      },
      {
        author_id: "60",
        problem_id: 3,
        body: "Идея для этого решения пришла ко мне во сне! Удивительно, как мозг работает иногда.",
        comment_reply_id: null,
      },
      {
        author_id: "968",
        problem_id: 3,
        body: "Эта задача заставила меня использовать все свои ресурсы!",
        comment_reply_id: null,
      },
      {
        author_id: "410",
        problem_id: 3,
        body: "Потратил на решение этой задачи весь день, но это было того стоило!",
        comment_reply_id: null,
      },
      {
        author_id: "718",
        problem_id: 3,
        body: "У кого-нибудь есть идеи, как можно оптимизировать мое решение? Пока я не совсем доволен своим подходом.",
        comment_reply_id: null,
      },
      {
        author_id: "549",
        problem_id: 3,
        body: "Теперь я чувствую, что могу решить что угодно!",
        comment_reply_id: null,
      },
      {
        author_id: "809",
        problem_id: 3,
        body: "Благодаря этой задаче я узнал о новой функции языка программирования.",
        comment_reply_id: null,
      },
      {
        author_id: "903",
        problem_id: 3,
        body: "Идея для этого решения пришла ко мне во сне! Удивительно, как мозг работает иногда.",
        comment_reply_id: null,
      },
      {
        author_id: "800",
        problem_id: 3,
        body: "Эта задача показала мне, насколько важно быть терпеливым в программировании.",
        comment_reply_id: null,
      },
      {
        author_id: "14",
        problem_id: 3,
        body: "Благодаря этой задаче я узнал о новой функции языка программирования.",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title:
          "✅Beats 100% || C++ || JAVA || PYTHON || Beginner Friendly🔥🔥🔥",
        body: "Intuition:\nThe Intuition is to iterate through two linked lists representing non-negative integers in reverse order, starting from the least significant digit. It performs digit-wise addition along with a carry value and constructs a new linked list to represent the sum. The process continues until both input lists and the carry value are exhausted. The resulting linked list represents the sum of the input numbers in the correct order.\nExplanation:\n\nCreate a placeholder node called dummyHead with a value of 0. This node will hold the resulting linked list.\nInitialize a pointer called tail and set it to dummyHead. This pointer will keep track of the last node in the result list.\nInitialize a variable called carry to 0. This variable will store the carry value during addition.\nStart a loop that continues until there are no more digits in both input lists (l1 and l2) and there is no remaining carry value.\nInside the loop:\n\nCheck if there is a digit in the current node of l1. If it exists, assign its value to a variable called digit1. Otherwise, set digit1 to 0.\nCheck if there is a digit in the current node of l2. If it exists, assign its value to a variable called digit2. Otherwise, set digit2 to 0.\nAdd the current digits from l1 and l2, along with the carry value from the previous iteration, and store the sum in a variable called sum.\nCalculate the unit digit of sum by taking the modulus (%) of sum by 10. This digit will be placed in a new node for the result.\nUpdate the carry variable by dividing sum by 10 and taking the integer division (/) part. This gives us the carry value for the next iteration.\nCreate a new node with the calculated digit as its value.\nAttach the new node to the tail node of the result list.\nMove the tail pointer to the newly added node.\nMove to the next nodes in both l1 and l2, if they exist. If either list is exhausted, set the corresponding pointer to nullptr.\n\n\nAfter the loop, obtain the actual result list by skipping the dummyHead node.\nDelete the dummyHead node.\nReturn the resulting list.\n\nCode\nC++JavaPython3class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummyHead = new ListNode(0);\n        ListNode* tail = dummyHead;\n        int carry = 0;\n\n        while (l1 != nullptr || l2 != nullptr || carry != 0) {\n            int digit1 = (l1 != nullptr) ? l1->val : 0;\n            int digit2 = (l2 != nullptr) ? l2->val : 0;\n\n            int sum = digit1 + digit2 + carry;\n            int digit = sum % 10;\n            carry = sum / 10;\n\n            ListNode* newNode = new ListNode(digit);\n            tail->next = newNode;\n            tail = tail->next;\n\n            l1 = (l1 != nullptr) ? l1->next : nullptr;\n            l2 = (l2 != nullptr) ? l2->next : nullptr;\n        }\n\n        ListNode* result = dummyHead->next;\n        delete dummyHead;\n        return result;\n    }\n};\n\nIf you are a beginner solve these problems which makes concepts clear for future coding:\n\nTwo Sum\nRoman to Integer\nPalindrome Number\nMaximum Subarray\nRemove Element\nContains Duplicate\nAdd Two Numbers\nMajority Element\nRemove Duplicates from Sorted Array\nPractice them in a row for better understanding and please Upvote the post for more questions.\n\nIf you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.",
        views: "322620",
        upvotes: "1.5K",
        author_id: "561",
        problem_id: 3,
      },
      {
        title:
          "【Video】Simple addition algorithm - Python, JavaScript, Java and C++",
        body: "Intuition\nSimply calculate addition with a few points.\nSolution Video\n\n⭐️⭐️ Don't forget to subscribe to my channel! ⭐️⭐️\n■ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\nSubscribers: 3,964\nThank you for your support!\n\nApproach\nThis question is very simple. All we have to do is just to calculate node values from l1 and l2. Let's think about this case.\nInput: l1 = [2,4,3], l2 = [5,6]\nIn the case, output should be\n[2,4,3]\n[5,6]\n-------\n[7,0,4]\nWe will implement simple algorithm and create a new LinkedList.\nFirst of all, we create dummy node with value 0(you can put any number instead of 0).\n0 → None\nd\nr\n\nd is dummy pointer\nr is result pointer\nWe copy dummy pointer and create result pointer. I'll explain why we need result pointer later.\nBasically, we calculate addition with values from l1 and l2 at the same index. Let's begin.\n[2,4,3]\n[5,6]\n ↑\n\n2 + 5 = 7\nWe got 7 as a total, so we create a new node with 7 and then connect it with node 0.\n0 → 7 → None\nr   d\n\nWe move dummy pointer to the next node(= 7) so that we can connect the next new node easily after 7.\nLet's calculate addition with the next values.\n[2,4,3]\n[5,6]\n   ↑\n\n4 + 6 = 10\nWe got 10. In that case, we want to put 0 for current digit. How can we put 0?\n\n⭐️ Points\nSimply, we use remainder divided by 10.\ntotal % 10\nFor example,\n10 % 10 = 0\n15 % 10 = 5\n7 % 10 = 7\nYou can use it when total is one digit. For example, previous digit 2 + 5 = 7\n\nWe have one more important thing. We have carry for a next digit, because total of current digit is 10. How can we calculate the carry?\n\n⭐️ Points\nJust divide total by 10, but this time we use // in Python.\ntotal // 10\nFor example,\n8 // 10 = 0\n18 // 10 = 1\nNow, we can get 0 for the current digit and carry 1 for the next digit, so we create a new node with 0 and then connect it with node 7 and move dummy pointer to node 0\n0 → 7 → 0 → None\nr       d\n\ncarry = 1\nNext\n[2,4,3]\n[5,6]\n     ↑\n\n3 + 0 + 1 = 4\n\n0 comes after 6 in the second list\n1 is carry\nNow, we can get 4 for the current digit and carry 0 for the next digit, so we create a new node with 4 and then connect it with node 0 and move dummy pointer to node 4\n0 → 7 → 0 → 4 → None\nr           d\n\ncarry = 0\nWe finish iteration. Problem here is that dummy pointer is at node 4 but we want to return 7 → 0 → 4, how can we return the whole new list?\n\n⭐️ Points\nLuckily, we have result pointer that is pointing to the first node 0. That is a reason why we copy dummy pointer and create result pointer at first.\n\nWe should return r.next(= node 7).\nreturn 7 → 0 → 4\nLet me add one more explanation. This is about conditions to continue calculating addition. To understand it, let's add 7 to the second list after 6.\n 0,0,1,1 (= carry)\n[2,4,3]\n[5,6,7]\n--------\n[7,0,1,1]\nIn this case, 1 + 3 + 7 creates carry, so we should add node 1 at last. From this example, we have 3 conditions to continue calculating.\n\n⭐️ Points\nIf list 1 has a value or list 2 has a value or we have a carry, then we continue calculating addtion.\nIn the solution code, I use while instead of if.\n\nEasy😄!\nLet's see solution codes and step by step algorithm!\n\n⭐️ I recently created a video on how I've been using LeetCode to learn.\n\n\nSolution Codes\nPythonJavaScriptJavaC++class Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        \n        dummy = ListNode()\n        res = dummy\n\n        total = carry = 0\n\n        while l1 or l2 or carry:\n            total = carry\n\n            if l1:\n                total += l1.val\n                l1 = l1.next\n            if l2:\n                total += l2.val\n                l2 = l2.next\n            \n            num = total % 10\n            carry = total // 10\n            dummy.next = ListNode(num)\n            dummy = dummy.next\n        \n        return res.next\nStep by step algorithm\n\n\nInitialization: Initialize a dummy node and a result pointer to the dummy node. Also, set total and carry variables to 0.\ndummy = ListNode()\nres = dummy\ntotal = carry = 0\n\n\nTraversing Lists: Traverse through both linked lists (l1 and l2) until either of them or the carry has a value.\nwhile l1 or l2 or carry:\n\n\nCalculating Sum: At each iteration, calculate the total sum of corresponding digits from l1, l2, and the carry.\ntotal = carry\nif l1:\n    total += l1.val\n    l1 = l1.next\nif l2:\n    total += l2.val\n    l2 = l2.next\n\n\nExtracting Digit and Carry: Extract the digit by taking the modulo 10 of the total sum and update the carry for the next iteration by dividing the total sum by 10.\nnum = total % 10\ncarry = total // 10\n\n\nCreating New Node: Create a new ListNode with the extracted digit and attach it to the result linked list.\ndummy.next = ListNode(num)\ndummy = dummy.next\n\n\nReturn Result: Finally, return the next node of the dummy node, which contains the head of the resultant linked list.\nreturn res.next\n\n\nThis algorithm effectively adds two numbers represented as linked lists, considering carryovers at each step.\nComplexity\n\n\nTime complexity: O(n)O(n)O(n)\nn is number of nodes in longer list l1 or l2.\n\n\nSpace complexity:O(n)O(n)O(n) or O(1)O(1)O(1)\nIf we count new list we create, that is O(n)O(n)O(n). If we don't count, that is O(1)O(1)O(1)\n\n\n\nThank you for reading my post. Please upvote it and don't forget to subscribe to my channel!\n⭐️ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n⭐️ Twitter\nhttps://twitter.com/CodingNinjaAZ\n⭐️ The next question #3 - Longest Substring Without Repeating Characters\npost\nhttps://leetcode.com/problems/longest-substring-without-repeating-characters/solutions/4840693/video-3-ways-to-solve-this-question-sliding-window-set-hashing-and-the-last-position/\nvideo\n",
        views: "1814",
        upvotes: "11",
        author_id: "657",
        problem_id: 3,
      },
    ],
  },
  {
    title: "3. Longest Substring Without Repeating Characters",
    description:
      'Given a string s, find the length of the longest substring without repeating characters.\n\n \nExample 1:\n\nInput: s = "abcabcbb"\nOutput: 3\nExplanation: The answer is "abc", with the length of 3.\n\n\nExample 2:\n\nInput: s = "bbbbb"\nOutput: 1\nExplanation: The answer is "b", with the length of 1.\n\n\nExample 3:\n\nInput: s = "pwwkew"\nOutput: 3\nExplanation: The answer is "wke", with the length of 3.\nNotice that the answer must be a substring, "pwke" is a subsequence and not a substring.\n\n\n \nConstraints:\n\n\n\t0 <= s.length <= 5 * 104\n\ts consists of English letters, digits, symbols and spaces.\n\n',
    difficulty: "Medium",
    acceptance: "22.95",
    frequency: "171.61",
    topics: [
      [
        "Graph",
        "Queue",
        "Bit Manipulation",
        "Rolling Hash",
        "Binary Tree",
        "Rejection Sampling",
        "Interactive",
        "Enumeration",
        "Array",
        "String",
      ],
    ],
    languages: [
      [
        "Elixir",
        "Swift",
        "C++",
        "C",
        "Python",
        "Ruby",
        "Kotlin",
        "Erlang",
        "Rust",
        "C#",
      ],
    ],
    comments: [
      {
        author_id: "251",
        problem_id: 4,
        body: "Идея для этого решения пришла ко мне во сне! Удивительно, как мозг работает иногда.",
        comment_reply_id: null,
      },
      {
        author_id: "16",
        problem_id: 4,
        body: "Чувствую себя чемпионом после этой задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "905",
        problem_id: 4,
        body: "Это было круто! Какая следующая задача?",
        comment_reply_id: null,
      },
      {
        author_id: "571",
        problem_id: 4,
        body: "Какие интересные подходы у других людей к этой задаче",
        comment_reply_id: null,
      },
      {
        author_id: "980",
        problem_id: 4,
        body: "Когда я столкнулся с этой задачей впервые, я думал, что это невозможно. Теперь я знаю иначе!",
        comment_reply_id: null,
      },
      {
        author_id: "888",
        problem_id: 4,
        body: "Наконец-то, я разобрался с этой задачей! Спасибо за все подсказки.",
        comment_reply_id: null,
      },
      {
        author_id: "352",
        problem_id: 4,
        body: "Я просто в восторге от того, как эффективно работает мое решение!",
        comment_reply_id: null,
      },
      {
        author_id: "60",
        problem_id: 4,
        body: "Это моя новая любимая задача! Хочу попробовать еще раз!",
        comment_reply_id: null,
      },
      {
        author_id: "52",
        problem_id: 4,
        body: "Эта задача преподнесла мне неожиданный поворот! Интересно, как многие это заметили.",
        comment_reply_id: null,
      },
      {
        author_id: "874",
        problem_id: 4,
        body: "Наконец-то я справился с этой задачей! Вперед к следующей!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title:
          "✅3 Method's || C++ || JAVA || PYTHON || Beginner Friendly🔥🔥🔥",
        body: "Intuition\n\nThe intuition behind the 3 solutions is to iteratively find the longest substring without repeating characters by maintaining a sliding window approach. We use two pointers (left and right) to represent the boundaries of the current substring. As we iterate through the string, we update the pointers and adjust the window to accommodate new unique characters and eliminate repeating characters.\nApproach 1 - Set\n\n\nWe use a set (charSet) to keep track of unique characters in the current substring.\nWe maintain two pointers, left and right, to represent the boundaries of the current substring.\nThe maxLength variable keeps track of the length of the longest substring encountered so far.\nWe iterate through the string using the right pointer.\nIf the current character is not in the set (charSet), it means we have a new unique character.\nWe insert the character into the set and update the maxLength if necessary.\nIf the character is already present in the set, it indicates a repeating character within the current substring.\nIn this case, we move the left pointer forward, removing characters from the set until the repeating character is no longer present.\nWe insert the current character into the set and continue the iteration.\nFinally, we return the maxLength as the length of the longest substring without repeating characters.\n\nCode\nC++JavaPython3class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int n = s.length();\n        int maxLength = 0;\n        unordered_set<char> charSet;\n        int left = 0;\n        \n        for (int right = 0; right < n; right++) {\n            if (charSet.count(s[right]) == 0) {\n                charSet.insert(s[right]);\n                maxLength = max(maxLength, right - left + 1);\n            } else {\n                while (charSet.count(s[right])) {\n                    charSet.erase(s[left]);\n                    left++;\n                }\n                charSet.insert(s[right]);\n            }\n        }\n        \n        return maxLength;\n    }\n};\nApproach 2 - Unordered Map\n\nWe improve upon the first solution by using an unordered map (charMap) instead of a set.\nThe map stores characters as keys and their indices as values.\nWe still maintain the left and right pointers and the maxLength variable.\nWe iterate through the string using the right pointer.\nIf the current character is not in the map or its index is less than left, it means it is a new unique character.\n6 We update the charMap with the character's index and update the maxLength if necessary.\nIf the character is repeating within the current substring, we move the left pointer to the next position after the last occurrence of the character.\nWe update the index of the current character in the charMap and continue the iteration.\nAt the end, we return the maxLength as the length of the longest substring without repeating characters.\n\nCode\nC++JavaPython3class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int n = s.length();\n        int maxLength = 0;\n        unordered_map<char, int> charMap;\n        int left = 0;\n        \n        for (int right = 0; right < n; right++) {\n            if (charMap.count(s[right]) == 0 || charMap[s[right]] < left) {\n                charMap[s[right]] = right;\n                maxLength = max(maxLength, right - left + 1);\n            } else {\n                left = charMap[s[right]] + 1;\n                charMap[s[right]] = right;\n            }\n        }\n        \n        return maxLength;\n    }\n};\nApproach 3 - Integer Array\n\nThis solution uses an integer array charIndex to store the indices of characters.\nWe eliminate the need for an unordered map by utilizing the array.\nThe maxLength, left, and right pointers are still present.\nWe iterate through the string using the right pointer.\nWe check if the current character has occurred within the current substring by comparing its index in charIndex with left.\nIf the character has occurred, we move the left pointer to the next position after the last occurrence of the character.\nWe update the index of the current character in charIndex.\nAt each step, we update the maxLength by calculating the length of the current substring.\nWe continue the iteration until reaching the end of the string.\nFinally, we return the maxLength as the length of the longest substring without repeating characters.\n\nCode\nC++JavaPython3class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int n = s.length();\n        int maxLength = 0;\n        vector<int> charIndex(128, -1);\n        int left = 0;\n        \n        for (int right = 0; right < n; right++) {\n            if (charIndex[s[right]] >= left) {\n                left = charIndex[s[right]] + 1;\n            }\n            charIndex[s[right]] = right;\n            maxLength = max(maxLength, right - left + 1);\n        }\n        \n        return maxLength;\n    }\n};\n\nIf you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.",
        views: "285251",
        upvotes: "1.3K",
        author_id: "238",
        problem_id: 4,
      },
      {
        title:
          "【Video】3 ways to solve this question - sliding window, set, hashing and the last position",
        body: 'Solution Video\n\n⭐️⭐️ Don\'t forget to subscribe to my channel! ⭐️⭐️\n■ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\nSubscribers: 3,982\nThank you for your support!\n\nApproach\nWe have two conditions to solve this question. The longest string should be\n\n\nSubstring\nWithout repeating characters\n\n\nYou just need to check that there are no repeated characters within a consecutive string of characters. To achieve this, you need to keep track of the characters currently forming the string. For this purpose, I considered three algorithms: one combining a sliding window and a set, and the second using a sliding window and a hash-based algorithm. The thrid is that the last position where each character was seen.\nI\'ll explain them one by one.\nSolution 1 - Sliding Window & Set\nFirst of all, we create\nleft = 0 \nmax_length = 0 (returned value)\nchar_set = set() \nleft is pointer of sliding window.\nmax_length is a value we should return.\nchar_set is to keep current characters forming the longest string with the two conditions above.\nWe will iterate through all characters one by one and create right pointer of sliding window with for loop.\nfor right in range(len(s)):\nLet\'s begin!\nInput: s = "abcabcbb"\n"abcabcbb"\n r\n l\n\nl is left of sliding window\nr is right of sliding window\nWe found a. Every time we check char_set if we have the same character or not. In this case, we don\'t have a in char_set, so add a to char_set.\nchar_set = {a}\nAfter that, we check max length.\nmax_length = 0\ncurrent length = right - left + 1\nWhy +1?\nThat\'s because current length of string is 1 which is only a, so if we don\'t add 1, we will calculate 0(right) - 0(left) = 0 which is wrong answer.\nThis happens because index number usually starts from 0 but actual count we do in daily life starts 1. That\'s why we need to kind of convert an index number to a real number by adding +1.\nLet\'s go back to the main point.\nmax_length = 1\nNext, only right pointer move next. I\'ll speed up.\n"abcabcbb"\n lr\n\nDo we have "b"? → No\nchar_set = {a, b}\n\nmax_length = 2 (right(1) - left(0) + 1)\nNext, only right pointer move next.\n"abcabcbb"\n l r\n\nDo we have "c"? → No\nchar_set = {a,b,c}\n\nmax_length = 3 (right(2) - left(0) + 1)\nNext, only right pointer move next.\n"abcabcbb"\n l  r\n\nDo we have "a"? → Yes\nIn this case, we have duplicate number a, so we can\'t continue to expand the string. That\'s why it\'s time to move left to the next. And we have important point.\n\n⭐️ Points\nWhen we move left to index 1, a at index 0 will be out of bounds, so we should remove a from char_set, so that we can keep unique characters forming the current string.\nIn this case, we use while loop, I\'ll explain why later.\n\n"abcabcbb"\n l  r\n\n- Do we have "a"? → Yes, remove "a" in char_set\nchar_set = {b,c}\n\n- move left to the next\n"abcabcbb"\n  l r\n\n- There is no "a" in char_set, we stop while looping.\n- And add crreunt "a" to char_set\nchar_set = {b,c,a}\n\nmax_length = 3 (right(3) - left(1) + 1)\nNext, only right pointer move next.\n"abcabcbb"\n  l  r\n\n- Do we have "b"? → Yes, remove "b" in char_set\nchar_set = {c,a}\n\n- move left to the next\n"abcabcbb"\n   l r\n\n- There is no "b" in char_set, we stop while looping.\n- And add crreunt "b" to char_set\nchar_set = {c,a,b}\n\nmax_length = 3 (right(4) - left(2) + 1)\nNext, only right pointer move next.\n"abcabcbb"\n   l  r\n\n- Do we have "c"? → Yes, remove "c" in char_set\nchar_set = {a,b}\n\n- move left to the next\n"abcabcbb"\n    l r\n\n- There is no "c" in char_set, we stop while looping.\n- And add crreunt "c" to char_set\nchar_set = {a,b,c}\n\nmax_length = 3 (right(5) - left(3) + 1)\nNext, only right pointer move next.\n"abcabcbb"\n    l  r\n\n- Do we have "b"? → Yes, remove "a" in char_set\nWait! Why do we have to remove a instead of b? That\'s because b is now duplicate character between left and right, so we have to remove chracters until we find b with left pointer.\n\n⭐️ Points\nLet\'s look at the string deeply.\n"abcb"\n l  r\nIf we keep a in the string, we have to also keep the first b because a is outside of the first b in the string. If we want to remove the first b, we must remove a before we remove the first b. This is substring.\nIn the end,\n"abcb"\n   lr\nLet\'s look at the process.\n"abcabcbb"\n    l  r\n\n- Do we have "b"? → Yes, remove "a" in char_set\nchar_set = {b,c}\n\n- Move left to the next\n"abcabcbb"\n     l r\n\n- Do we have "b"? → Yes, remove "b" in char_set\nchar_set = {c}\n\n- Move left to the next\n"abcabcbb"\n      lr\n\n- Do we have "b"? → No, now we stop while loop\n\n- Add current "b" to char_set\n- char_set = {c,b}\n\nmax_length = 3 > (right(6) - left(5) + 1)\n\nI hope now you understand why we use while loop when remove charcters. There is an case where we remove multiple characters.\n\nI stop rest of explanation because we will repeat the same process.\nreturn 3\nAs you can see, we keep char_set the same as the string between left and right when we add a current character to char_set. That\'s why we can check if current character is duplicate or not.\nEasy😆!\nLet\'s see solution codes and step by step algorithm!\n\n⭐️ I recently created a video on how I\'ve been using LeetCode to learn.\n\n\nComplexity\n\nTime complexity: O(n)O(n)O(n)\n\n\n\nSpace complexity: O(1)O(1)O(1)\n\nConstraints say "s consists of English letters, digits, symbols and spaces". I think we have fixed max size of characters consisting of the input string.\nPythonJavaScriptJavaC++class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        left = max_length = 0\n        char_set = set()\n        \n        for right in range(len(s)):\n            while s[right] in char_set:\n                char_set.remove(s[left])\n                left += 1\n\n            char_set.add(s[right])\n            max_length = max(max_length, right - left + 1)\n        \n        return max_length\nStep by step algorithm\n\nInitialization:\n\nleft = max_length = 0\nchar_set = set()\n\nleft: Marks the start of the current substring.\nmax_length: Tracks the length of the longest substring without repeating characters. Initialized to 0.\nchar_set: Keeps track of unique characters encountered so far, initialized as an empty set.\n\n\nIterating over the string characters:\n\nfor right in range(len(s)):\n\nright: Represents the end of the current substring. It moves from 0 to the end of the string.\n\n\nChecking for repeating characters:\n\nwhile s[right] in char_set:\n    char_set.remove(s[left])\n    left += 1\n\nThis loop executes when the character at the \'right\' index is already in the char_set, meaning we have encountered a repeating character.\nIt removes characters from the char_set and adjusts the \'left\' pointer until the current character at \'right\' is no longer in the char_set. This effectively removes the characters from the substring that are causing the repetition.\n\n\nUpdating char_set and max_length:\n\nchar_set.add(s[right])\nmax_length = max(max_length, right - left + 1)\n\nAdds the current character to char_set since it\'s unique now.\nUpdates max_length by taking the maximum between the current max_length and the length of the current substring (right - left + 1).\n\n\nReturning max_length:\n\nreturn max_length\n\nAfter iterating through the entire string, the function returns the maximum length of the substring without repeating characters.\n\nSolution 2 - Sliding Window and Hashing\nIn solution 2, we use almost the same idea as solution 1 with Slinding Window and Hashing. In Python, we use HashMap.\nIn HashMap, we keep each character as a key and frequency of the characters as a value.\nEvery time we find a character, add 1 frequency to HashMap. Since this question requires us to find the longest substring without repeating characters, so if we have more than 2 frequency of the current character, we add -1 to HashMap until we have 1 frequency of the current character and move left pointer to the next at the same time.\nAfter that, this is the same as solution 1. Just compare max length\nmax_length = max(max_length, right - left + 1)\nEasy😄！\nLet\'s see solution codes and step by step algorithm!\n\nComplexity\n\nTime complexity: O(n)O(n)O(n)\n\n\n\nSpace complexity: O(1)O(1)O(1)\n\nConstraints say "s consists of English letters, digits, symbols and spaces". I think we have fixed max size of characters consisting of the input string.\nPythonJavaScriptJavaC++class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n\n        max_length = left = 0\n        count = {}\n\n        for right, c in enumerate(s):\n            count[c] = 1 + count.get(c, 0)\n            while count[c] > 1:\n                count[s[left]] -= 1\n                left += 1\n        \n            max_length = max(max_length, right - left + 1)\n\n        return max_length\nStep by step algorithm\n\nInitialization:\n\nmax_length = left = 0\ncount = {}\n\nmax_length: Represents the length of the longest substring without repeating characters found so far. Initialized to 0.\nleft: Marks the start index of the current substring.\ncount: A dictionary used to store the count of characters encountered in the current substring.\n\n\nIterating Over the String:\n\nfor right, c in enumerate(s):\n\nright: Represents the end index of the current substring. It is updated using enumerate(s), which returns both the index and the character at that index in the string.\nc: Represents the character at the current index.\n\n\nUpdating the Character Count:\n\ncount[c] = 1 + count.get(c, 0)\n\nThis line updates the count of the current character c in the count dictionary.\nIf c is not present in the dictionary, it initializes its count to 1. Otherwise, it increments its count by 1.\n\n\nAdjusting the Left Pointer:\n\nwhile count[c] > 1:\n    count[s[left]] -= 1\n    left += 1\n\nThis while loop adjusts the left pointer as long as there are repeating characters in the current substring.\nIt decreases the count of the character at index left and increments left by 1 until there are no repeating characters.\n\n\nUpdating the Maximum Length:\n\nmax_length = max(max_length, right - left + 1)\n\nThis line updates the maximum length (max_length) of the substring without repeating characters.\nIt calculates the length of the current substring (right - left + 1) and compares it with the current maximum length (max_length). If the current substring is longer, it updates max_length.\n\n\nReturning the Result:\n\nreturn max_length\n\nAfter iterating through the entire string, the function returns the maximum length of the substring without repeating characters.\n\nIn summary, this algorithm efficiently finds the length of the longest substring without repeating characters using two pointers (left and right) and a dictionary (count) to keep track of character counts. It iterates through the string once, making it a linear time complexity algorithm.\nSolution 3 - the last position where each character was seen\nIn the solution 3, we also iterate through all characters one by one. That is right pointer.\nWe update left pointer with HashMap. In HashMap, we keep each character as a key and the last position where each character was seen　as a value.\nDo you remember this example in solution 1?\n"abcb"\n l  r\nLet\'s call HashMap last_seen.\nIn this case, last_seen should have this\nlast_seen = {a:0, b:1, c:2}\n\nlast position of a is 0\nlast position of b is 1\nlast position of c is 2\n\ncurrent max length shold be 3 (= abc)\nNow we find the second b at index 3. As I explain in solution 1, we have to remove characters until we have unique characters between left and right.\nleft pointer is at index 0 and the last position where b was seen is index 1, so that\'s why we should update left pointer with 1.\nOne more important thing is that if we update left with 1, we have bcb as a string which is including duplicate characters.\nThat\'s why we should update left pointer with the last position + 1.\nleft = last_seen[character(= b)] + 1\n= 2\nThen compare max length\nmax_length = max(max_length, right - left + 1)\nEasy😄!\nLet\'s see solution codes and step by step algorithm!\n\nComplexity\n\nTime complexity: O(n)O(n)O(n)\n\n\n\nSpace complexity: O(1)O(1)O(1)\n\nConstraints say "s consists of English letters, digits, symbols and spaces". I think we have fixed max size of characters consisting of the input string.\nPythonJavaScriptJavaC++class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        max_length = 0\n        left = 0\n        last_seen = {}\n\n        for right, c in enumerate(s):\n            if c in last_seen and last_seen[c] >= left:\n                left = last_seen[c] + 1\n            \n            max_length = max(max_length, right - left + 1)\n            last_seen[c] = right\n\n        return max_length\nStep by step algorithm\n\nInitialization:\n\nmax_length = 0\nleft = 0\nlast_seen = {}\n\nmax_length: Keeps track of the length of the longest substring without repeating characters.\nleft: Marks the start index of the current substring.\nlast_seen: A dictionary to store the last seen index of each character in the string.\n\n\nIterating Over the String:\n\nfor right, c in enumerate(s):\n\nright: Represents the current index of the character c being processed.\nc: Represents the current character being processed.\n\n\nChecking for Repeating Characters:\n\nif c in last_seen and last_seen[c] >= left:\n    left = last_seen[c] + 1\n\nIf the character c is present in last_seen and its last seen index is greater than or equal to left (the start index of the current substring), it means that c is repeating within the current substring.\nIn such a case, we update left to the index next to the last occurrence of c.\n\n\nUpdating max_length:\n\nmax_length = max(max_length, right - left + 1)\n\nUpdate max_length with the maximum value between its current value and the length of the current substring (right - left + 1).\nright - left + 1 represents the length of the current substring without repeating characters.\n\n\nUpdating last_seen:\n\nlast_seen[c] = right\n\nUpdate the last_seen dictionary with the index right where the character c was last seen.\n\n\nReturning the Result:\n\nreturn max_length\n\nAfter iterating through the entire string, return the maximum length of the substring without repeating characters.\n\n\nThank you for reading my post. Please upvote it and don\'t forget to subscribe to my channel!\n⭐️ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n⭐️ Twitter\nhttps://twitter.com/CodingNinjaAZ',
        views: "3794",
        upvotes: "27",
        author_id: "856",
        problem_id: 4,
      },
      {
        title: "Easy Simple Solution with proper explanation and hidden case",
        body: "Intuition\nSliding window two pointer approach\n\nApproach\n\nMake an unordered_map and maintain two pointers.\nStore every distinct s[j] in umap with its index as value, increment j and store in maxlen\nBe very careful about the case where umap[s[j]] >= i. The condition umap[s[j]] >= i in the provided code snippet is used to check if the last occurrence index of the current character s[j] is within the current substring boundaries defined by i and j. This condition ensures that the last occurrence of s[j] is not located before the left boundary i of the current substring.\nif s[j] already present in umap then assign i = umap[s[j]]+1.\nDon't do i = umap[s[j]]++ as this statement first retrieves the index of the last occurrence of the repeating character s[j] from the map and assigns it to i. Then, it increments the value stored in umap[s[j]] by 1.\n\nComplexity\n\n\nTime complexity:\nO(n)\n\n\nSpace complexity:\nO(n)\n\n\nCode\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int i=0, j=0, n=s.length();\n        int maxlen = 0;\n        unordered_map <char,int> umap;\n       while(j<n){\n        if(umap.find(s[j]) == umap.end() || umap[s[j]] < i){\n            umap[s[j]]=j;\n            maxlen = max(j-i+1,maxlen);\n            j++;\n        }\n        else{\n            i = umap[s[j]]+1;\n        }\n       } \n       return maxlen;\n    }\n};",
        views: "163",
        upvotes: "2",
        author_id: "97",
        problem_id: 4,
      },
      {
        title: "why leetcode why || the most straight and in depth",
        body: "Intuition\n\nKey Points:\n\nThe code uses a HashMap to efficiently track character occurrences and their indices.\nIt employs a sliding window technique to explore all possible substrings and update the longest substring length as needed.\nThe i and j pointers manage the window contraction and expansion to remove repeating characters.\n\nApproach\n\n\n\nHandling Empty and Single-Character Strings:\n\nif (size == 1 || size == 0): Checks if the string s is empty (size 0) or has only one character (size 1). In these cases, the longest substring without repeating characters is the entire string itself. The code returns size in these scenarios.\n\n\n\nInitializing Variables:\n\nHashMap<Character, Integer> hm = new HashMap<>(): Creates a HashMap hm to store characters encountered in the string and their corresponding indices in the string.\nint size = s.length(): Stores the length of the string s in the variable size.\nint j = 0: Initializes a variable j as the starting index of the current substring window.\nint i = 0: Initializes a variable i as the starting index of the window to be contracted (used to remove repeating characters).\nint ans = 1: Initializes a variable ans to store the length of the longest substring found so far, starting with 1 (assuming the first character could be the longest substring initially).\n\n\n\nSliding Window Technique:\n\nThe while loop iterates as long as j (end of the current window) is less than the string length (size). This implements a sliding window approach to explore all possible substrings.\n\nif (hm.containsKey(s.charAt(j)) && hm.get(s.charAt(j)) >= i): This condition checks two things:\n\nhm.containsKey(s.charAt(j)): Checks if the current character (s.charAt(j)) is already present in the hm HashMap (meaning it's a repeating character).\nhm.get(s.charAt(j)) >= i: If it's a repeating character, this condition ensures the last occurrence (hm.get(s.charAt(j))) is within the current window (>= i). This ensures we only contract the window if the repeating character falls within the current window we're considering.\nIf both conditions are true, it signifies a repeating character within the current window.\n\ni = hm.get(s.charAt(j)) + 1: Updates the i index to point to the character after the last occurrence of the repeating character (hm.get(s.charAt(j))). This effectively contracts the window from the left to remove the repeating character.\n\n\n\n\nhm.put(s.charAt(j), j): Updates the hm HashMap with the current character (s.charAt(j)) and its index (j). This helps track the latest occurrence of each character.\nans = Math.max(ans, j - i + 1): Updates the ans variable to store the maximum length encountered so far. It calculates the current window size (j - i + 1) and compares it with the previously found longest substring (ans).\nj++: Increments j to move the window one character to the right for exploring the next substring.\n\n\n\n\n\nReturning the Result:\n\nreturn ans: After iterating through the entire string, the ans variable holds the length of the longest substring without repeating characters. The code returns this value.\n\n\n\nComplexity\n\nTime complexity:\n\n\nThis approach provides a time-efficient solution (O(n)) for finding the longest substring without repeating characters.\n\nSpace complexity:\n\n\nCode\nThis approach provides a space-efficient solution (O(n)) for finding the longest substring without repeating characters.\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        HashMap<Character,Integer> hm=new HashMap<>();\n        \n        int size=s.length();\n        int j=0;\n        int i=0;\n        if(size==1 || size==0){\n            return size;\n        }\n\n        int ans=1;\n        while(j<size){\n            if(hm.containsKey(s.charAt(j)) && hm.get(s.charAt(j))>=i){\n                i=hm.get(s.charAt(j));\n                i++;\n                \n            }\n            \n            hm.put(s.charAt(j),j);\n            ans=Math.max(ans,j-i+1);\n            \n            j++;\n        }\n        return ans;\n    }\n}",
        views: "1276",
        upvotes: "2",
        author_id: "912",
        problem_id: 4,
      },
    ],
  },
  {
    title: "4. Median of Two Sorted Arrays",
    description:
      "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n \nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\n\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n \nConstraints:\n\n\n\tnums1.length == m\n\tnums2.length == n\n\t0 <= m <= 1000\n\t0 <= n <= 1000\n\t1 <= m + n <= 2000\n\t-106 <= nums1[i], nums2[i] <= 106\n\n",
    difficulty: "Hard",
    acceptance: "29.83",
    frequency: "10.68",
    topics: [
      [
        "Merge Sort",
        "Array",
        "Reservoir Sampling",
        "Topological Sort",
        "Biconnected Component",
        "Simulation",
        "Interactive",
        "Two Pointers",
        "Backtracking",
        "Quickselect",
      ],
    ],
    languages: [
      [
        "C++",
        "Dart",
        "Python3",
        "Scala",
        "Python",
        "Elixir",
        "Kotlin",
        "JavaScript",
        "Swift",
        "Ruby",
      ],
    ],
    comments: [
      {
        author_id: "376",
        problem_id: 5,
        body: "Всегда думал, что эта задача невозможна. Но вот я, сделал это!",
        comment_reply_id: null,
      },
      {
        author_id: "180",
        problem_id: 5,
        body: "Эта задача мне не давала покоя, но теперь я горд собой!",
        comment_reply_id: null,
      },
      {
        author_id: "543",
        problem_id: 5,
        body: "Не могу поверить, что решил это за одну попытку! Сейчас немного в шоке.",
        comment_reply_id: null,
      },
      {
        author_id: "139",
        problem_id: 5,
        body: "Сложно поверить, что я только что решил это! Спасибо всем за поддержку.",
        comment_reply_id: null,
      },
      {
        author_id: "318",
        problem_id: 5,
        body: "Сколько времени я потратил на решение этой задачи? Не считаясь!",
        comment_reply_id: null,
      },
      {
        author_id: "455",
        problem_id: 5,
        body: "Потратил на решение этой задачи весь день, но это было того стоило!",
        comment_reply_id: null,
      },
      {
        author_id: "63",
        problem_id: 5,
        body: "Как я мог не догадаться о таком подходе? Спасибо за отличное объяснение!",
        comment_reply_id: null,
      },
      {
        author_id: "853",
        problem_id: 5,
        body: "Я так рад, что решил эту задачу! Это действительно научило меня чему-то новому.",
        comment_reply_id: null,
      },
      {
        author_id: "814",
        problem_id: 5,
        body: "У кого-нибудь есть идеи, как можно оптимизировать мое решение? Пока я не совсем доволен своим подходом.",
        comment_reply_id: null,
      },
      {
        author_id: "582",
        problem_id: 5,
        body: "Эта задача заставила меня использовать все свои ресурсы!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title:
          "✅99%🔥||✅Journey From Brute Force to Most 🔥Optimized ✅Three Approaches||🔥Easy to understand",
        body: "Problem Understanding:\nIn simpler terms, you need to find the middle value of the combined, sorted array formed by merging nums1 and nums2. If the combined array has an even number of elements, you should return the average of the two middle values. If it has an odd number of elements, you should return the middle value itself.\n\nHint:\nHint1Hint2Hint3Think of a brute force approach.\nI would recommend you, don't jump directly on solution.\nApproach 1: Merge and Sort\n\nCreate a new array with a size equal to the total number of elements in both input arrays.\nInsert elements from both input arrays into the new array.\nSort the new array.\nFind and return the median of the sorted array.\n\nTime Complexity\n\nIn the worst case TC is O((n + m) * log(n + m)).\n\nSpace Complexity\n\nO(n + m), where ‘n’ and ‘m’ are the sizes of the arrays.\n\nApproach 2: Two-Pointer Method\n\nInitialize two pointers, i and j, both initially set to 0.\nMove the pointer that corresponds to the smaller value forward at each step.\nContinue moving the pointers until you have processed half of the total number of elements.\nCalculate and return the median based on the values pointed to by i and j.\n\nTime Complexity\n\nO(n + m), where ‘n’ & ‘m’ are the sizes of the two arrays.\n\nSpace Complexity\n\nO(1).\n\nApproach 3: Binary Search\n\nUse binary search to partition the smaller of the two input arrays into two parts.\nFind the partition of the larger array such that the sum of elements on the left side of the partition in both arrays is half of the total elements.\nCheck if this partition is valid by verifying if the largest number on the left side is smaller than the smallest number on the right side.\nIf the partition is valid, calculate and return the median.\n\nTime Complexity\n\nO(logm/logn)\n\nSpace Complexity\n\nO(1)\n\n\nSMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated😊😊\n\n\nCode Brute Force- Merge and Sort\nC++JavaPython3class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        // Get the sizes of both input arrays.\n        int n = nums1.size();\n        int m = nums2.size();\n\n        // Merge the arrays into a single sorted array.\n        vector<int> merged;\n        for (int i = 0; i < n; i++) {\n            merged.push_back(nums1[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            merged.push_back(nums2[i]);\n        }\n\n        // Sort the merged array.\n        sort(merged.begin(), merged.end());\n\n        // Calculate the total number of elements in the merged array.\n        int total = merged.size();\n\n        if (total % 2 == 1) {\n            // If the total number of elements is odd, return the middle element as the median.\n            return static_cast<double>(merged[total / 2]);\n        } else {\n            // If the total number of elements is even, calculate the average of the two middle elements as the median.\n            int middle1 = merged[total / 2 - 1];\n            int middle2 = merged[total / 2];\n            return (static_cast<double>(middle1) + static_cast<double>(middle2)) / 2.0;\n        }\n    }\n};\n\nCode for Two-Pointer Method\nC++JavaPythonclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int n = nums1.size();\n        int m = nums2.size();\n        int i = 0, j = 0, m1 = 0, m2 = 0;\n\n        // Find median.\n        for (int count = 0; count <= (n + m) / 2; count++) {\n            m2 = m1;\n            if (i != n && j != m) {\n                if (nums1[i] > nums2[j]) {\n                    m1 = nums2[j++];\n                } else {\n                    m1 = nums1[i++];\n                }\n            } else if (i < n) {\n                m1 = nums1[i++];\n            } else {\n                m1 = nums2[j++];\n            }\n        }\n\n        // Check if the sum of n and m is odd.\n        if ((n + m) % 2 == 1) {\n            return static_cast<double>(m1);\n        } else {\n            double ans = static_cast<double>(m1) + static_cast<double>(m2);\n            return ans / 2.0;\n        }\n    }\n};\n\nCode for Binary Search\nC++JavaPythonclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2) {\n        int n1 = nums1.size(), n2 = nums2.size();\n        \n        // Ensure nums1 is the smaller array for simplicity\n        if (n1 > n2)\n            return findMedianSortedArrays(nums2, nums1);\n        \n        int n = n1 + n2;\n        int left = (n1 + n2 + 1) / 2; // Calculate the left partition size\n        int low = 0, high = n1;\n        \n        while (low <= high) {\n            int mid1 = (low + high) >> 1; // Calculate mid index for nums1\n            int mid2 = left - mid1; // Calculate mid index for nums2\n            \n            int l1 = INT_MIN, l2 = INT_MIN, r1 = INT_MAX, r2 = INT_MAX;\n            \n            // Determine values of l1, l2, r1, and r2\n            if (mid1 < n1)\n                r1 = nums1[mid1];\n            if (mid2 < n2)\n                r2 = nums2[mid2];\n            if (mid1 - 1 >= 0)\n                l1 = nums1[mid1 - 1];\n            if (mid2 - 1 >= 0)\n                l2 = nums2[mid2 - 1];\n            \n            if (l1 <= r2 && l2 <= r1) {\n                // The partition is correct, we found the median\n                if (n % 2 == 1)\n                    return max(l1, l2);\n                else\n                    return ((double)(max(l1, l2) + min(r1, r2))) / 2.0;\n            }\n            else if (l1 > r2) {\n                // Move towards the left side of nums1\n                high = mid1 - 1;\n            }\n            else {\n                // Move towards the right side of nums1\n                low = mid1 + 1;\n            }\n        }\n        \n        return 0; // If the code reaches here, the input arrays were not sorted.\n    }\n};\n\n\nSMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated😊😊\n",
        views: "127373",
        upvotes: "1.9K",
        author_id: "381",
        problem_id: 5,
      },
      {
        title:
          "C++ | | Using Merge Sort | | Simple steps | |  Beat 95.15% ✅✅🔥",
        body: "Intuition\n\nTo find the median of two sorted arrays, we can merge the arrays into a single sorted array and then find the median based on the size of the merged array.\n\nApproach\n\nInitialize Pointers :\n\n\nSet pointers i and j to the start of both arrays nums1 and nums2, respectively. Also, initialize a pointer for the merged array.\n\n\nMerge Arrays :\n\n\nWhile both i and j are within their respective array bounds:\nCompare the elements at indices i and j in nums1 and nums2.\nAdd the smaller element to the merged array and move the corresponding pointer forward.\nRepeat this process until one of the arrays is empty.\n\n\nAdd Remaining Elements :\n\n\nIf there are remaining elements in either nums1 or nums2, add them to the end of the merged array.\n\n\nCalculate Median Index :\n\n\nCalculate the median index based on the total number of elements in the merged array (totalSize = m + n). If the total number of elements is odd, the median index is totalSize / 2; if it's even, there are two middle elements at indices (totalSize / 2) - 1 and totalSize / 2.\n\n\nCalculate Median Value :\n\n\nIf the total number of elements is even, return the average of the two middle elements in the merged array; otherwise, return the middle element.\n\nComplexity\n\n\nTime complexity: O(m+n)O(m + n)O(m+n)\n\n\nSpace complexity: O(m+n)O(m + n)O(m+n)\n\n\nCode\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m = nums1.size();\n        int n = nums2.size();\n        int totalSize = m + n;\n        int medianI = totalSize / 2;\n\n        vector<int> merged;\n        int i = 0, j = 0;\n\n        while (i < m && j < n) {\n            if (nums1[i] <= nums2[j]) {\n                merged.push_back(nums1[i]);\n                i++;\n            } else {\n                merged.push_back(nums2[j]);\n                j++;\n            }\n        }\n\n        while (i < m) {\n            merged.push_back(nums1[i]);\n            i++;\n        }\n\n        while (j < n) {\n            merged.push_back(nums2[j]);\n            j++;\n        }\n\n        if (totalSize % 2 == 0) {\n            return (merged[medianI - 1] + merged[medianI]) / 2.0;\n        } else {\n            return merged[medianI];\n        }\n    }\n};\n",
        views: "373",
        upvotes: "1",
        author_id: "764",
        problem_id: 5,
      },
      {
        title:
          "💯Runtime 4 ms Beats 36.66% of users with Java || 💯Memory 45.06 MB Beats 99.77% of users with Java",
        body: "Intuition\n\nThe given code is a solution to finding the median of two sorted arrays. It combines the two arrays into one, sorts the merged array, and then calculates the median based on whether the total number of elements is even or odd.\nApproach\n\nCalculate the total length of the merged array.\nCreate a new array to store the merged elements.\nMerge the two input arrays into the new array.\nSort the merged array.\nCalculate the median based on whether the total number of elements is even or odd.\nComplexity\n\nTime complexity:\n\n\n\nSpace complexity:\n\n\nCode\nclass Solution {\n    public double findMedianSortedArrays(int[] x, int[] y) {\n        int m=x.length+y.length;\n        int [] res= new int[m];\n        int k=0;\n        for(int i=0;i<x.length;i++){\n            res[k++] =x[i];\n        }\n        for(int j=0;j<y.length;j++ )\n        {\n            res[k++]=y[j];\n        }\n        Arrays.sort(res);\n         int mid = res.length / 2;\n        if(res.length % 2 !=0){\n            \n            return (double) res[mid];\n        }\n        return (double) (res[mid -1 ] + res[mid])/2;\n        \n    }\n    }\n   ",
        views: "561",
        upvotes: "1",
        author_id: "655",
        problem_id: 5,
      },
      {
        title: "C++ || SOLUTION",
        body: "SUGGESTION:\nWhen we are trying to approach a problem, we should always start from brute force solution, even though you have been trained by solving a lot of similar problems previously and been able to give a O(N) solution off the top of your head, I still recommend you to start from a brute force solution. This is the only way you can avoid geting stuck in your fixed mindset when you encounter a completely unseen or unfamiliar problem that unfortunately doesn't match any existing pattern in your trained mind.\n// Brute Force:\n               // 1.Merge Both Array\n              // 2.Sort them\n             // 3.Find Median\n            // TIME COMPLEXITY: O(n)+O(nlogn)+O(n)\n            // SPACE COMPLEXITY: O(1)\n \nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n       // Initialization some neccessary variables\n        vector<int>v;\n        \n        // store the array in the new array\n        for(auto num:nums1)   // O(n1)\n            v.push_back(num);\n        \n        for(auto num:nums2)  // O(n2)\n            v.push_back(num);\n        \n        // Sort the array to find the median\n        sort(v.begin(),v.end());  // O(nlogn)\n        \n        // Find the median and Return it\n        int n=v.size();  // O(n)\n        \n        return n%2?v[n/2]:(v[n/2-1]+v[n/2])/2.0;\n    }\n};\n\n** Accepted **\n// Optimized Using: Two Pointer with Extra Space\n  // Time Complexity: O(m+n)\n  // Space Complexity: O(m+n)\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n        // Create a single sorted by merging two sorted arrays\n        int n1=nums1.size();\n        int n2=nums2.size();\n        int i=0;\n        int j=0;\n        int lastindex=-1;\n             \n        // Initialize a new array\n           vector<int>v(n1+n2,0);\n        \n        while(i<n1&&j<n2)\n        {\n            if(nums1[i]<=nums2[j])\n                v[++lastindex]=nums1[i++];\n            else\n                v[++lastindex]=nums2[j++];\n        }\n        \n        while(i<n1)\n            v[++lastindex]=nums1[i++];\n        while(j<n2)\n            v[++lastindex]=nums2[j++];\n        \n    // Return the result\n        int n=n1+n2;\n        return n%2?v[n/2]:(v[n/2]+v[n/2-1])/2.0;\n        \n    }\n};\n\n** Accepted **\n// Optimized Using: Two Pointer without Extra Space (Insertion Sort)\n  // Time Complexity: O(n1*n2)\n  // Space Complexity: O(1)\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n       // Calculate Total length of final array: O(N)\n        int n1=nums1.size();  \n        int n2=nums2.size();\n        int n=n1+n2;  \n      \n        // Edge Cases\n        if(n2==0)\n            return n1%2?nums1[n1/2]:(nums1[n1/2-1]+nums1[n1/2])/2.0;\n        if(n1==0)\n             return n2%2?nums2[n2/2]:(nums2[n2/2-1]+nums2[n2/2])/2.0;\n        \n        // Resize the array 'nums1': O(N), N is size of resized array\n        nums1.resize(n);\n        \n        // Now use pointer to compare arrays elements \n        int i=0;\n        int j=0;\n        \n       // Store all element in 'array 1' in sorted order \n        while(i<n1)  // O(n1)\n        {\n            if(nums1[i]>nums2[0])\n            {\n                swap(nums1[i],nums2[0]);  // O(1)\n                // Rearrange Array nums2\n                rearrangeArray(nums2);  // O(n2)\n            }\n            i++;\n        }\n        \n        // Store remaining elements of 'array 2' in 'array 1' \n        while(j<nums2.size()) // O(n2)\n            nums1[i++]=nums2[j++];\n        \n    // Return Result\n    return n%2?nums1[n/2]:(nums1[n/2-1]+nums1[n/2])/2.0;\n        \n    }\n    \n    void rearrangeArray(vector<int>&nums2)\n    {\n        // Using insertion sort for insertion \n           // worst case Time Complexity Would be: O(n)\n        for(int i=1;i<nums2.size()&&nums2[i]<nums2[i-1];i++)\n            swap(nums2[i],nums2[i-1]);\n    }\n};\n\n** Accepted **\n// Optimized Approach: Using gap method:\n    // Time Complexity: O((log base 2 power N)*(N))\n   //  Space Complexity: O(1)\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n        // Do some pre-calculation : O(N)\n        int n1=nums1.size();\n        int n2=nums2.size();\n        int n=n1+n2;\n        \n        // Now Create Two Pointer\n        int gap=ceil((n1+n2)/2.0);\n        int i=0;\n        int j=gap;\n        \n        // Edge Cases\n        if(n1==0)\n            return n2%2?nums2[n2/2]:(nums2[n2/2]+nums2[n2/2-1])/2.0;\n        \n        if(n2==0)\n            return n1%2?nums1[n1/2]:(nums1[n1/2]+nums1[n1/2-1])/2.0;\n        \n        // Apply gap method: O((log base 2 power N)*N)\n        \n       while(gap)\n       {   i=0;\n           j=gap;\n       // Move both pointer until they reach at last \n        while(j<n)\n        {\n            // If 'i' in 'nums1' and 'j' is also in 'nums1'\n            if(i<n1&&j<n1&&nums1[i]>nums1[j])\n            swap(nums1[i],nums1[j]);\n        else\n            // if 'i' in 'nums1' and 'j' is in 'nums2'\n            if(i<n1&&j>=n1&&nums1[i]>nums2[j-n1])\n                swap(nums1[i],nums2[j-n1]);\n        else \n            // if 'i' in 'nums2' and 'j' is also in 'nums2'\n            if(i>=n1&&j>=n1&&nums2[i-n1]>nums2[j-n1])\n                 swap(nums2[i-n1],nums2[j-n1]);\n            \n        // Move both pointer ahead by only one step\n        i++;\n        j++;\n        }\n        \n        // Edge Case, because of 'ceil()' gap never becomes zero\n        if(gap==1)\n            gap=0;\n         \n         gap=ceil(gap/2.0);\n       }   \n        \n    //Return Result\n      if(n%2)\n          return n/2<n1?nums1[n/2]:nums2[n/2-n1];\n     else\n         if(n/2<n1)\n             return (nums1[n/2]+nums1[n/2-1])/2.0;\n        else\n            if((n/2-1)<n1)\n               return (nums1[n/2-1]+nums2[n/2-n1])/2.0;\n       else \n           return (nums2[n/2-n1]+nums2[n/2-1-n1])/2.0;\n       \n    }\n};\n\n** Accepted **\n// Optimized Approach: Binary Search\n    // Time Complexity: O(log(min(m,n)))\n   //  Space Complexity: O(1)\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n                   // ** Intuition  **\n        // I have to find out correct left half and correct right half\n          // i.e : // 7 ,  || 12 , 14 , 15  --> parition it\n                  //  1 , 2 , 3 , 4 , || 9 , 11  --> parition it\n                  // Now just findout max(left1,left2), min(right1,right2)\n        \n        \n        // Initilaization of some neccessary variables\n        int n1=nums1.size();\n        int n2=nums2.size();\n        int n=n1+n2;\n         \n      if(n1>n2)  return findMedianSortedArrays(nums2,nums1);\n        \n     // When length is even, let's say 10 then left half length should be: (10+1)/2 =>5\n     // When length is odd, let's say 11 then left half length should be: (11+1)/2 =>6\n        // This mean that this formula gonna work in both condition\n        int partition=(n+1)/2; \n        \n    \n    // Edge Case\n    if(n1==0)\n        return n2%2?nums2[n2/2]:(nums2[n2/2]+nums2[n2/2-1])/2.0;\n    \n    if(n2==0)\n        return n1%2?nums1[n1/2]:(nums1[n1/2]+nums1[n1/2-1])/2.0;\n    \n    // Now do Partioning\n    int left1=0;\n    int right1=n1;\n    int cut1,cut2;\n    int l1,r1,l2,r2;\n    \n    do\n    {   \n        //Findout 'cut1' and 'cut2'\n        cut1=(left1+right1)/2;\n        cut2=partition-cut1;\n   \n        // Calculation for l1\n        l1=cut1==0?INT_MIN:nums1[cut1-1];\n        \n        // Calculation for l2\n        l2=cut2==0?INT_MIN:nums2[cut2-1];\n        \n        // Calculation for r1\n        r1=cut1>=n1?INT_MAX:nums1[cut1];\n        \n        // Calculation for r2\n        r2=cut2>=n2?INT_MAX:nums2[cut2];\n        \n        if(l1<=r2&&l2<=r1)\n             // Return Result\n             return n%2?max(l1,l2):(max(l1,l2)+min(r1,r2))/2.0;\n        else\n            \n        if(l1>r2)\n            right1=cut1-1;\n        else\n             left1=cut1+1;\n       \n       \n    }while(left1<=right1);\n        \n             \n    return 0.0;\n    }\n};\n\n** Accepted **\nPlease correct me if i take time complexity wrong.\nPLEASE UPVOTE IF YOU FIND IT A LITTLE BIT HELPFUL, MEANS A LOT ;)",
        views: "109519",
        upvotes: "695",
        author_id: "691",
        problem_id: 5,
      },
    ],
  },
  {
    title: "5. Longest Palindromic Substring",
    description:
      'Given a string s, return the longest palindromic substring in s.\n\n \nExample 1:\n\nInput: s = "babad"\nOutput: "bab"\nExplanation: "aba" is also a valid answer.\n\n\nExample 2:\n\nInput: s = "cbbd"\nOutput: "bb"\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 1000\n\ts consist of only digits and English letters.\n\n',
    difficulty: "Medium",
    acceptance: "11.44",
    frequency: "80.77",
    topics: [
      [
        "Binary Indexed Tree",
        "Linked List",
        "Minimum Spanning Tree",
        "Array",
        "Queue",
        "Geometry",
        "Memoization",
        "Sorting",
        "Concurrency",
        "Bit Manipulation",
      ],
    ],
    languages: [
      [
        "JavaScript",
        "Racket",
        "Rust",
        "Swift",
        "Python",
        "C#",
        "TypeScript",
        "PHP",
        "Ruby",
        "Elixir",
      ],
    ],
    comments: [
      {
        author_id: "578",
        problem_id: 6,
        body: "Кто бы мог подумать, что решение окажется настолько простым!",
        comment_reply_id: null,
      },
      {
        author_id: "914",
        problem_id: 6,
        body: "Иногда лучшее решение приходит в голову после нескольких неудачных попыток.",
        comment_reply_id: null,
      },
      {
        author_id: "353",
        problem_id: 6,
        body: "Сложно даже представить, сколько попыток ушло на решение этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "206",
        problem_id: 6,
        body: "Сложно даже представить, сколько попыток ушло на решение этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "967",
        problem_id: 6,
        body: "Не могу поверить, что я решил это без помощи Google!",
        comment_reply_id: null,
      },
      {
        author_id: "358",
        problem_id: 6,
        body: "У кого-нибудь есть идеи, как можно оптимизировать мое решение? Пока я не совсем доволен своим подходом.",
        comment_reply_id: null,
      },
      {
        author_id: "451",
        problem_id: 6,
        body: "Я не знал, что это возможно, пока не попробовал! Это было удивительно!",
        comment_reply_id: null,
      },
      {
        author_id: "391",
        problem_id: 6,
        body: "Наконец-то я справился с этой задачей! Вперед к следующей!",
        comment_reply_id: null,
      },
      {
        author_id: "746",
        problem_id: 6,
        body: "Как приятно видеть, что мое решение работает!",
        comment_reply_id: null,
      },
      {
        author_id: "304",
        problem_id: 6,
        body: "Эта задача показала мне, насколько важно быть терпеливым в программировании.",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title:
          "✅ Beats 96.49% 🔥 || 5 Different Approaches 💡 || Brute Force || EAC || DP || MA || Recursion ||",
        body: "It takes a lot of efforts to write such long explanatinon, so please UpVote ⬆️ if this helps you.\nApproach 1: Brute Force\n\nIntuition :\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of n^2 such substrings (excluding the trivial solution where a character itself is a palindrome). Since verifying each substring takes O(n) time, the run time complexity is O(n^3).\nAlgorithm :\n\nPick a starting index for the current substring which is every index from 0 to n-2.\nNow, pick the ending index for the current substring which is every index from i+1 to n-1.\nCheck if the substring from ith index to jth index is a palindrome.\nIf step 3 is true and length of substring is greater than maximum length so far, update maximum length and maximum substring.\nPrint the maximum substring.\n\nComplexity Analysis\n\n\nTime complexity : O(n^3). Assume that n is the length of the input string, there are a total of C(n, 2) = n(n-1)/2 substrings (excluding the trivial solution where a character itself is a palindrome). Since verifying each substring takes O(n) time, the run time complexity is O(n^3).\n\n\nSpace complexity : O(1).\n\n\nCode\nPythonC++Javaclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        if len(s) <= 1:\n            return s\n        \n        Max_Len=1\n        Max_Str=s[0]\n        for i in range(len(s)-1):\n            for j in range(i+1,len(s)):\n                if j-i+1 > Max_Len and s[i:j+1] == s[i:j+1][::-1]:\n                    Max_Len = j-i+1\n                    Max_Str = s[i:j+1]\n\n        return Max_Str\nApproach 2: Expand Around Center\n\nIntuition :\nTo enumerate all palindromic substrings of a given string, we first expand a given string at each possible starting position of a palindrome and also at each possible ending position of a palindrome and keep track of the length of the longest palindrome we found so far.\nApproach :\n\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n - 1 such centers.\nYou might be asking why there are 2n - 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \"abba\") and its center are between the two 'b's.'\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n^2).\n\nAlgorithm :\n\nAt starting we have maz_str = s[0] and max_len = 1 as every single character is a palindrome.\nNow, we will iterate over the string and for every character we will expand around its center.\nFor odd length palindrome, we will consider the current character as the center and expand around it.\nFor even length palindrome, we will consider the current character and the next character as the center and expand around it.\nWe will keep track of the maximum length and the maximum substring.\nPrint the maximum substring.\n\nComplexity Analysis\n\n\nTime complexity : O(n^2). Since expanding a palindrome around its center could take O(n) time, the overall complexity is O(n^2).\n\n\nSpace complexity : O(1).\n\n\nCode\nPythonC++Javaclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        if len(s) <= 1:\n            return s\n\n        def expand_from_center(left, right):\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return s[left + 1:right]\n\n        max_str = s[0]\n\n        for i in range(len(s) - 1):\n            odd = expand_from_center(i, i)\n            even = expand_from_center(i, i + 1)\n\n            if len(odd) > len(max_str):\n                max_str = odd\n            if len(even) > len(max_str):\n                max_str = even\n\n        return max_str\nApproach 3: Dynamic Programming\nIntuition :\n\nTo improve over the brute force solution, we first observe how we can avoid unnecessary re-computation while validating palindromes. Consider the case \"ababa\". If we already knew that \"bab\" is a palindrome, it is obvious that \"ababa\" must be a palindrome since the two left and right end letters are the same.\nAlgorithm :\n\nWe initialize a boolean table dp and mark all the values as false.\nWe will use a variable max_len to keep track of the maximum length of the palindrome.\nWe will iterate over the string and mark the diagonal elements as true as every single character is a palindrome.\nNow, we will iterate over the string and for every character we will expand around its center.\nFor odd length palindrome, we will consider the current character as the center and expand around it.\nFor even length palindrome, we will consider the current character and the next character as the center and expand around it.\nWe will keep track of the maximum length and the maximum substring.\nPrint the maximum substring.\n\nComplexity Analysis\n\n\nTime complexity : O(n^2). This gives us a runtime complexity of O(n^2).\n\n\nSpace complexity : O(n^2). It uses O(n^2) space to store the table.\n\n\nCode\nPythonC++Javaclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        if len(s) <= 1:\n            return s\n        \n        Max_Len=1\n        Max_Str=s[0]\n        dp = [[False for _ in range(len(s))] for _ in range(len(s))]\n        for i in range(len(s)):\n            dp[i][i] = True\n            for j in range(i):\n                if s[j] == s[i] and (i-j <= 2 or dp[j+1][i-1]):\n                    dp[j][i] = True\n                    if i-j+1 > Max_Len:\n                        Max_Len = i-j+1\n                        Max_Str = s[j:i+1]\n        return Max_Str\nApproach 4: Manacher's Algorithm\n\nIntuition :\nTo avoid the unnecessary validation of palindromes, we can use Manacher's algorithm. The algorithm is explained brilliantly in this article. The idea is to use palindrome property to avoid unnecessary validations. We maintain a center and right boundary of a palindrome. We use previously calculated values to determine if we can expand around the center or not. If we can expand, we expand and update the center and right boundary. Otherwise, we move to the next character and repeat the process. We also maintain a variable max_len to keep track of the maximum length of the palindrome. We also maintain a variable max_str to keep track of the maximum substring.\nAlgorithm :\n\nWe initialize a boolean table dp and mark all the values as false.\nWe will use a variable max_len to keep track of the maximum length of the palindrome.\nWe will iterate over the string and mark the diagonal elements as true as every single character is a palindrome.\nNow, we will iterate over the string and for every character we will expand around its center.\nFor odd length palindrome, we will consider the current character as the center and expand around it.\nFor even length palindrome, we will consider the current character and the next character as the center and expand around it.\nWe will keep track of the maximum length and the maximum substring.\nPrint the maximum substring.\n\nComplexity Analysis\n\n\nTime complexity : O(n). Since expanding a palindrome around its center could take O(n) time, the overall complexity is O(n).\n\n\nSpace complexity : O(n). It uses O(n) space to store the table.\n\n\nCode\nPythonC++Javaclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        if len(s) <= 1:\n            return s\n        \n        Max_Len=1\n        Max_Str=s[0]\n        s = '#' + '#'.join(s) + '#'\n        dp = [0 for _ in range(len(s))]\n        center = 0\n        right = 0\n        for i in range(len(s)):\n            if i < right:\n                dp[i] = min(right-i, dp[2*center-i])\n            while i-dp[i]-1 >= 0 and i+dp[i]+1 < len(s) and s[i-dp[i]-1] == s[i+dp[i]+1]:\n                dp[i] += 1\n            if i+dp[i] > right:\n                center = i\n                right = i+dp[i]\n            if dp[i] > Max_Len:\n                Max_Len = dp[i]\n                Max_Str = s[i-dp[i]:i+dp[i]+1].replace('#','')\n        return Max_Str\nApproach 5: Recursive TLE(Time Limit Exceeded)\nIntuition :\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of n^2 such substrings (excluding the trivial solution where a character itself is a palindrome). Since verifying each substring takes O(n) time, the run time complexity is O(n^3). But in this approach we will use recursion to solve the problem. We will check if the string is a palindrome or not. If it is a palindrome, we will return the string. Otherwise, we will recursively call the function for the string excluding the first character and for the string excluding the last character. We will check the length of the returned strings and return the string with the maximum length.\nAlgorithm :\n\nIf the string is a palindrome, we will return the string.\nOtherwise, we will recursively call the function for the string excluding the first character and for the string excluding the last character.\nWe will check the length of the returned strings and return the string with the maximum length.\n\nComplexity Analysis\n\n\nTime complexity : O(n^3). Assume that n is the length of the input string, there are a total of C(n, 2) = n(n-1)/2 substrings (excluding the trivial solution where a character itself is a palindrome). Since verifying each substring takes O(n) time, the run time complexity is O(n^3).\n\n\nSpace complexity : O(n). The recursion stack may go up to n levels deep.\n\n\nCode\nPythonC++Javaclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n\n        if s==s[::-1]: \n            return s\n        left = self.longestPalindrome(s[1:])\n        right = self.longestPalindrome(s[:-1])\n\n        if len(left)>len(right):\n            return left\n        else:\n            return right\n",
        views: "139292",
        upvotes: "1.4K",
        author_id: "425",
        problem_id: 6,
      },
      {
        title: "【Video】Using two pointers - Python, JavaScript, Java, C++",
        body: 'Intuition\nUsing two pointers\n\nSolution Video\n\n■ Timeline of the video\n0:04 How did you find longest palindromic substring?\n0:59 What is start point?\n1:44 Demonstrate how it works with odd case\n4:36 How do you calculate length of palindrome we found?\n7:35 Will you pass all test cases?\n7:53 Consider even case\n9:03 How to deal with even case\n11:26 Coding\n14:52 Explain how to calculate range of palindrome substring\n17:18 Time Complexity and Space Complexity\n⭐️⭐️ Don\'t forget to subscribe to my channel! ⭐️⭐️\n■ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\nSubscribers: 4,190\nThank you for your support!\n\nApproach\nHow we think about a solution\n\nFirst of all, Manacher\'s Algorithm solves this question with O(n)O(n)O(n) time. But in real interviews, nobody will come up with such a solution, so I think O(n2)O(n^2)O(n2) time is enough to pass the interviews.\nIf interviewers ask you about a solution with O(n)O(n)O(n). just leave the room. lol\n\nSeriously from here, first of all, we need to understand Palindromic Substring.\nWhen I think about a solution, I usually start with the small and simple input, because it\'s easy to understand and find a solution. But this time let\'s start with a big input.\nInput: "xkarqzghhgfedcbabcdefgzdekx"\n\n■ Question\nHow did you find longest palindromic substring?\n\nI believe you choose one character, then expand the range to left and right at the same time. If you find longest palindromic substring directly, you are not a human. lol\nActually, that is main idea of my solution today. But problem is that we don\'t know where to start. That\'s why we need to shift start point one by one.\n\n⭐️ Points\nWe need to shift a start point one by one to check longest palindromic substring.\n\nWhat is the start point?\n\nSince palindromic substring is like a mirror from some character, it\'s good idea to consider current index as a center of palindromic substring and expand left and right at the same time.\nFor example,\nInput = "abcba"\nIf we start from c, then\n"ab" "c" "ba"\n      i\n\ni = curerent index\n"ab" and "ba" is a mirror when "c" is center.\n\nLet\'s see one by one.\nInput = "abcba"\nWe use left and right pointers. The both pointers start from index i but let me start from next to index i to make my explanation short. A single character is definitely a palindrome which is length of 1.\ni = 0\n\n"abcba"\nlir\n \nCheck left(= out of bounds) and right(= "b")\nmax_length = 1 (= "a")\n\ni = 1\n\n"abcba"\n lir\n\nCheck left(= "a") and right(= "c")\nmax_length = 1 (= "a" or "b")\n\ni = 2\n\n"abcba"\n  lir\n\nl = 1\nr = 3\nCheck left(= "b") and right(= "b") → "bcb" is a palindrome.😆\n\nLet\'s expand the range!\n\n"abcba"\n l i r\n\nl = 0\nr = 4\nCheck left(= "a") and right(= "a") → "abcba" is a palindrome.😆\nmax_length = 5 (= "abcba")\n\n "abcba"\n l  i  r\n\nl = -1\nr = 5\nNow left and right are out of bounds, so we finish iteration.\n\nLet me skip the cases where we start from later "b" and "a". We already found the max length. (of course solution code will check the later part)\n\nHow do you calculate length of palindrome we found?\n\nFrom the example above, we found 5 as a max length. how do you calculate it? Simply\nright - left\nRight? So,\nright - left\n5 - (-1)\n= 6\nWait? It\'s longer than max length we found. The reason why this happens is because the two pointers stop at the next position of max length of palindrome.\n"abcba"\n l i r\nWhen i = 2 left = 0 and right = 4, we found 5 as a max length, but we don\'t know 5 is the max length in the current iteration, so we try to move to the next place to find longer palindrome, even if we don\'t find it in the end.\nThat\'s why, left and right pointer always overrun and stop at max length in current iteration + 1, so we need to subtract -1 from right - left.\n❌ right - left\n🔴 right - left - 1\nBut still you don\'t get it because we have two pointers expanding at the same time? you think we should subtract -2?\nThis is calculation of index number, so index number usually starts from 0 not 1, so right - left includes -1 already. For example,\n"aba"\n l r\nActual length is 3, but if we calculate the length with index number, that should be 2(index 2 - index 0), so it\'s already including -1 compared with actual length. That\'s why when we have two pointers and calculate actual length, right - left - 1 works well.\nNow you understand main idea of my solution, but I\'m sure you will not pass all cases. Can you geuss why?\nThe answer is I explain the case where we have odd length of input string.\n\n⭐️ Points\nWe have to care about both odd length of input string and even length of input string\n\nInput: "abbc"\nLet\'s see one by one. we can use the same idea. Let me write briefly.\n"abbc"\nlir\n\nmax length = 1\n"abbc"\n lir\n\nmax length = 1\n"abbc"\n  lir\n\nmax length = 1\n"abbc"\n   lir\n\nmax length = 1\n❌ Output: "a" or "b" or "c"  \nOutput should be\n🔴 Output: "bb"  \n\nWhy this happens?\n\nRegarding odd length of input array, center position of palindrome is definitely on some charcter.\n"abcba", center is "c"\nHow about even length of input string\n"abbc"\nCenter of palindrome is "b | b" \n| is center of palindrome. Not on some character.\n\nSo how can you avoid this?\n\nMy idea to avoid this is we start left with current index and right with current index + 1, so we start interation as if we are coming from between the characters. Let me write only when index = 1.\ncurrent index = 1\n\n  lr\n"abbc"\n  i\n\nWe found palindrome "bb"\n\n l  r\n"abbc"\n  i\n\nFinish iteration.\nThen\nright - left - 1\n3 - 0 - 1\n= 2(= length of "bb")\nWe can use the same idea for both cases but start position is different, that\'s why we call the same function twice in one iteration.\nLet\'s see a real algorithm!\nAlgorithm Overview:\n\nInitialize start and end variables to keep track of the starting and ending indices of the longest palindromic substring.\nIterate through each character of the input string s.\nFor each character, expand around it by calling the expand_around_center function with two different center possibilities: (i) the current character as the center (odd length palindrome), and (ii) the current character and the next character as the center (even length palindrome).\nCompare the lengths of the two expanded palindromes and update start and end if a longer palindrome is found.\nFinally, return the longest palindromic substring by slicing the input string s based on the start and end indices.\n\nDetailed Explanation:\n\n\nCheck if the input string s is empty. If it is, return an empty string, as there can be no palindromic substring in an empty string.\n\n\nDefine a helper function expand_around_center that takes three arguments: the input string s, and two indices left and right. This function is responsible for expanding the palindrome around the center indices and returns the length of the palindrome.\n\n\nInitialize start and end variables to 0. These variables will be used to keep track of the indices of the longest palindromic substring found so far.\n\n\nIterate through each character of the input string s using a for loop.\n\n\nInside the loop, call the expand_around_center function twice: once with i as the center for an odd length palindrome and once with i and i + 1 as the center for an even length palindrome.\n\n\nCalculate the length of the palindrome for both cases (odd and even) and store them in the odd and even variables.\n\n\nCalculate the maximum of the lengths of the two palindromes and store it in the max_len variable.\n\n\nCheck if the max_len is greater than the length of the current longest palindromic substring (end - start). If it is, update the start and end variables to include the new longest palindromic substring. The new start is set to i - (max_len - 1) // 2, and the new end is set to i + max_len // 2.\n\n\nContinue the loop until all characters in the input string have been processed.\n\n\nAfter the loop, return the longest palindromic substring by slicing the input string s using the start and end indices. This substring is inclusive of the characters at the start and end indices.\n\n\nComplexity\n\nTime complexity: O(n2)O(n^2)O(n2)\n\n"n" is the length of the input string "s." This is because the code uses nested loops. The outer loop runs for each character in the string, and the inner loop, expand_around_center, can potentially run for the entire length of the string in the worst case, leading to a quadratic time complexity.\n\nSpace complexity: O(1)O(1)O(1)\n\nthe code uses a constant amount of extra space for variables like "start," "end," "left," "right," and function parameters. The space used does not depend on the size of the input string.\nPythonJavaScriptJavaC++class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        if not s:\n            return ""\n\n        def expand_around_center(s: str, left: int, right: int):\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return right - left - 1\n\n\n        start = 0\n        end = 0\n\n        for i in range(len(s)):\n            odd = expand_around_center(s, i, i)\n            even = expand_around_center(s, i, i + 1)\n            max_len = max(odd, even)\n            \n            if max_len > end - start:\n                start = i - (max_len - 1) // 2\n                end = i + max_len // 2\n        \n        return s[start:end+1]\nLet me explain this.\nif max_len > end - start:\n    start = i - (max_len - 1) // 2\n    end = i + max_len // 2\nif statement means just when we find longer length.\nLet\'s use the same example again.\nInput = "abcba"\n\nWhen i = 2, we find 5 as a max length. Let\'s see what will happen.\nstart = i(2) - (max_len(5) - 1) // 2\nend = i(2) + max_len(5) // 2\n↓\nstart = 2 - 2\nend = 2 + 2\n↓\nstart = 0\nend = 4\n\nWhy -1?\n\nThe -1 is used to calculate the length of the palindrome correctly based on whether it is of odd or even length.\nHere, we try to get length of half palindrome except center chracters.\nRegarding odd case, actually it works if we don\'t subtract -1, because we have only one center chracter and we start from the character.\nFor example\n"abcba"\n   ↑\nCenter of palindrome is "c" \nWe will get length of "ab"\nno -1 case, 5 // 2 = 2\n-1 case, 4 // 2 = 2\nThe result is the same.\nBut regarding even case we start from between characters.\n"abbc"\nCenter of palindrome is "bb" \nWe will get length of ""(empty = 0), because center character "bb" itself is whole length of palindrome.\nno -1 case, 2 // 2 = 1\n-1 case, 1 // 2 = 0\nThe result is different.\nIn this case, we have two center charcters, if we remove one character, we can create the same odd case situation from even situaiton, so that we can get correct length except center charcters.\nIn this case, i = 1, we get 2 as a max length.\n"abbc"\nstart = i(1) - (max_len(2) - 1) // 2\nend = i(1) + max_len(2) // 2\n↓\nstart = 1 - 0\nend = 1 + 1\n↓\nstart = 1\nend = 2\nLooks good! 😆\nSince the result is not affected by -1 in odd case, we subtract -1 both odd case and even case.\n\nThank you for reading my post.\n⭐️ Please upvote it and don\'t forget to subscribe to my channel!\n■ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\nMy next daily coding challenge post and video.\npost\nhttps://leetcode.com/problems/count-vowels-permutation/solutions/4218427/video-give-me-10-minutes-how-we-think-about-a-solution-python-javascript-java-c/\nvideo\n\n■ Timeline of the video\n0:04 Convert rules to a diagram\n1:14 How do you count strings with length of n?\n3:58 Coding\n7:39 Time Complexity and Space Complexity\nMy previous daily coding challenge post and video.\npost\nhttps://leetcode.com/problems/binary-trees-with-factors/solutions/4209156/video-give-me-10-minutes-how-we-think-about-a-solution-python-javascript-java-c/\nvideo\n\n■ Timeline of video\n0:04 Understand question exactly and approach to solve this question\n1:33 How can you calculate number of subtrees?\n4:12 Demonstrate how it works\n8:40 Coding\n11:32 Time Complexity and Space Complexity',
        views: "3693",
        upvotes: "40",
        author_id: "548",
        problem_id: 6,
      },
      {
        title:
          "✅☑️ Best C++ 3 solution || DP || String || Brute Force -> Optimize || One Stop Solution.",
        body: 'Intuition\n\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\n\nSolved using string(Three Nested Loop). Brute Force Approach.\nSolved using string(TwoNested Loop). Brute Force Approach.\nSolved using Dynamic Programming Approach(tabulation). Optimized Approach.\n\nApproach\n\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\nComplexity\n\nTime complexity:\n\n\nTime complexity is given in code comment.\n\nSpace complexity:\n\n\nSpace complexity is given in code comment.\nCode\n/*\n\n    Time Complexity : O(N^3), Here three nested loop creates the time complexity. Where N is the size of the\n    string(s).\n\n    Space Complexity : O(1), Constant space.\n\n    Solved using string(Three Nested Loop). Brute Force Approach.\n\n    Note : this may give TLE.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\nprivate: \n    bool check(string &s, int i, int j){\n        while(i<j){\n            if(s[i] != s[j]){\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }            \npublic:\n    string longestPalindrome(string s) {\n        int n = s.size();\n        int starting_index = 0;\n        int max_len = 0;\n        for(int i=0; i<n; i++){\n            for(int j=i; j<n; j++){\n                if(check(s, i, j)){\n                    if(j-i+1 > max_len){\n                        max_len = j-i+1;\n                        starting_index = i;\n                    }\n                }\n            }\n        }\n        return s.substr(starting_index, max_len);\n    }\n}; \n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^2), Here Two nested loop creates the time complexity. Where N is the size of the\n    string(s).\n\n    Space Complexity : O(N^2*N), vector(substring) space.\n\n    Solved using string(TwoNested Loop). Brute Force Approach.\n\n    Note : this may give TLE.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution { \nprivate: \n    bool check(string &s, int i, int j){\n        while(i<j){\n            if(s[i] != s[j]){\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\npublic:\n    string longestPalindrome(string s) {\n        int n = s.size();\n        vector<string> substring;\n        for(int i=0; i<n; i++){\n            string temp = "";\n            for(int j=i; j<n; j++){\n                temp += s[j];\n                substring.push_back(temp);\n            }\n        }\n        int max_len = 0;\n        string finalans = substring[0];\n        int m = substring.size();\n        for(int i=0; i<m; i++){\n            int s = substring[i].size();\n            if(check(substring[i], 0, s-1)){\n                if(s > max_len){\n                    max_len = s;\n                    finalans = substring[i];\n                }\n            }       \n        }\n        return finalans;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^2), The time complexity of the above code is O(N^2) because we are traversing over all\n    the substrings and then checking each substring if it is a palindrome or not. There are N^2 substrings and\n    checking a substring takes O(1) time, so total time complexity is O(N^2).\n\n    Space Complexity : (N^2), The space complexity of the above code is O(N^2) because we are using the dp array\n    in which we are storing whether a substring is a palindrome or not.\n\n    Solved using Dynamic Programming Approach(tabulation). Optimized Approach.\n\n*/\n\n\n/***************************************** Approach 3 *****************************************/\n\nclass Solution {\nprivate: \n    bool solve(vector<vector<bool>> &dp, int i, int j, string &s){\n        if(i == j){\n            return dp[i][j] = true;\n        }\n        if(j-i == 1){\n            if(s[i] == s[j]){\n                return dp[i][j] = true;\n            }\n            else{\n                return dp[i][j] = false;\n            }\n        }\n        if(s[i] == s[j] && dp[i+1][j-1] == true){\n            return dp[i][j] = true;\n        } else {\n            return dp[i][j] = false;\n        }\n    }\npublic:\n    string longestPalindrome(string s) {\n        int n = s.size();\n        int startIndex = 0; int maxlen = 0;\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\n        for(int g=0; g<n; g++){\n            for(int i=0, j=g; j<n; i++, j++){\n                solve(dp, i, j, s);\n                if(dp[i][j] == true){\n                    if(j-i+1 > maxlen){\n                        startIndex = i;\n                        maxlen = j-i+1;\n                    }\n                }\n            }\n        }\n        return s.substr(startIndex, maxlen);\n    }\n};\n\nIF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.\n',
        views: "134154",
        upvotes: "706",
        author_id: "662",
        problem_id: 6,
      },
      {
        title:
          "Intuitive || Easy to Understand || Recursion + Memoization || Java",
        body: "Approach\nTake\nstart = 0\nend = s.length() -1\n\nCompare s[start] and s[end] and furthur check on start + 1 and end -1 for finalMatch\nShrink size using (start + 1, end) and (start, end - 1) if finalMath = false\nupdate maxStart, maxEnd and maxLen if finalMatch = true\n\nCode\nclass Solution {\n    int maxLen = 0;\n    int maxStart = -1;\n    int maxEnd = -1;\n    boolean solveRec(int start, int end, String s, Boolean[][] dp) {\n        if(start > end)\n            return true;\n\n        if(dp[start][end] != null)\n            return dp[start][end];    \n\n        boolean match = false;\n        if(s.charAt(start) == s.charAt(end)) {\n            match = true;\n        }\n\n        boolean finalMatch =  match & solveRec(start + 1, end -1, s, dp);\n        if(!finalMatch) {\n            solveRec(start + 1, end, s, dp);\n            solveRec(start, end - 1, s, dp);\n        }\n\n        if(finalMatch && (end - start + 1 > maxLen) ) {\n            maxStart = start;\n            maxEnd = end;\n            maxLen = end - start + 1;\n        }\n\n        return dp[start][end] = finalMatch;\n    }\n\n    public String longestPalindrome(String s) {\n        int n = s.length();\n        Boolean[][] dp = new Boolean[n + 1][n + 1];\n        solveRec(0, s.length() - 1, s, dp);\n        return s.substring(maxStart, maxEnd + 1);\n\n    }\n}",
        views: "2021",
        upvotes: "1",
        author_id: "287",
        problem_id: 6,
      },
    ],
  },
  {
    title: "6. Zigzag Conversion",
    description:
      'The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\n\nAnd then read line by line: "PAHNAPLSIIGYIR"\n\nWrite the code that will take a string and make this conversion given a number of rows:\n\nstring convert(string s, int numRows);\n\n\n \nExample 1:\n\nInput: s = "PAYPALISHIRING", numRows = 3\nOutput: "PAHNAPLSIIGYIR"\n\n\nExample 2:\n\nInput: s = "PAYPALISHIRING", numRows = 4\nOutput: "PINALSIGYAHRPI"\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\n\nExample 3:\n\nInput: s = "A", numRows = 1\nOutput: "A"\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 1000\n\ts consists of English letters (lower-case and upper-case), \',\' and \'.\'.\n\t1 <= numRows <= 1000\n\n',
    difficulty: "Medium",
    acceptance: "24.16",
    frequency: "15.87",
    topics: [
      [
        "Stack",
        "Two Pointers",
        "Math",
        "Linked List",
        "Doubly-Linked List",
        "Binary Search",
        "Biconnected Component",
        "String Matching",
        "Hash Table",
        "Hash Function",
      ],
    ],
    languages: [
      [
        "C",
        "Rust",
        "Go",
        "Racket",
        "Swift",
        "Ruby",
        "C#",
        "Scala",
        "Erlang",
        "TypeScript",
      ],
    ],
    comments: [
      {
        author_id: "826",
        problem_id: 7,
        body: "Кто-нибудь сталкивался с такой ошибкой раньше? Не могу понять, в чем проблема.",
        comment_reply_id: null,
      },
      {
        author_id: "128",
        problem_id: 7,
        body: "Эта задача преподнесла мне неожиданный поворот! Интересно, как многие это заметили.",
        comment_reply_id: null,
      },
      {
        author_id: "304",
        problem_id: 7,
        body: "Всегда думал, что эта задача невозможна. Но вот я, сделал это!",
        comment_reply_id: null,
      },
      {
        author_id: "703",
        problem_id: 7,
        body: "Сложно даже представить, сколько попыток ушло на решение этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "329",
        problem_id: 7,
        body: "Всегда думал, что эта задача невозможна. Но вот я, сделал это!",
        comment_reply_id: null,
      },
      {
        author_id: "112",
        problem_id: 7,
        body: "Сложно даже представить, сколько попыток ушло на решение этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "152",
        problem_id: 7,
        body: "Я так рад, что решил эту задачу! Это действительно научило меня чему-то новому.",
        comment_reply_id: null,
      },
      {
        author_id: "904",
        problem_id: 7,
        body: "Эта задача мне не давала покоя, но теперь я горд собой!",
        comment_reply_id: null,
      },
      {
        author_id: "72",
        problem_id: 7,
        body: "Кто-нибудь еще решал эту задачу? Хотелось бы услышать ваши мысли!",
        comment_reply_id: null,
      },
      {
        author_id: "363",
        problem_id: 7,
        body: "Не могу поверить, что решил это за одну попытку! Сейчас немного в шоке.",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "【Video】Simple Solution",
        body: "Intuition\nWe can move up and down with 1 and -1\n\nSolution Video\n\n⭐️⭐️ Don't forget to subscribe to my channel! ⭐️⭐️\n■ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\nSubscribers: 4,344\nThank you for your support!\n\nApproach\nLet's think about this example.\ns = \"abcdefghi\", numRows = 4\nIn this case, we put the characters of s like this.\n1 a     g → ag\n2 b   f h → bfh\n3 c e   i → cei\n4 d       → d\nreturn \"agbfhceid\"\nWhat we should do?\n\n⭐️ Points\n\nPut characters on zigzag path\nCreate strings horizontally\n\n\nPut characters on zigzag path\nSeems like tough because we move diagonally but it's very simple.\ns = \"abcdefghi\", numRows = 4\nIn this case\n\"abcdefghi\"\n 123432123 (= row)\nAll we have to do is that we just move up and down. More precisely, if we reach numsRows - 1, we move up next time and if we reach the first row, we move down next time.\nWe will creat direction variable to handle moving direction. When we move down, the variable has 1. On the other hand, when we move up, the variable has -1.\nCreate strings horizontally\nNow we have an array like this.\n1 a     g\n2 b   f h\n3 c e   i\n4 d      \nAll we have to do is just to concatenate all characters in the same row. But there is a point here.\n\n⭐️ Points\nUse 2d array instead of 1d array\n\nWhy?\nThat's because if we use 1d array(of course we can solve the question), we have to concatenate all characters in the same row when we add a new character which is O(n)O(n)O(n). We will repeat the process length of s times, so that is O(n2)O(n^2)O(n2). n is the length of the string s.\nTo avoid O(n2)O(n^2)O(n2), we use 2d array so that we just append a new character to the last position of a target row which is O(1)O(1)O(1).\nThis enables us to keep O(n)O(n)O(n) time instead of O(2)O(^2)O(2).\nI put Python code of O(n2)O(n^2)O(n2) below.\nEasy!😄\nLet's see solution codes and step by step algorithm!\n\n⭐️ I created a video on how I've been using LeetCode to learn.\n\n\nComplexity\n\n\nTime complexity: O(n)O(n)O(n)\nn is the length of the string s\n\n\nSpace complexity: O(n)O(n)O(n)\n\n\n\nPythonJavaScriptJavaC++class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1 or numRows >= len(s):\n            return s\n\n        idx, d = 0, 1\n        rows = [[] for _ in range(numRows)]\n\n        for char in s:\n            rows[idx].append(char)\n            if idx == 0:\n                d = 1\n            elif idx == numRows - 1:\n                d = -1\n            idx += d\n\n        for i in range(numRows):\n            rows[i] = ''.join(rows[i])\n\n        return ''.join(rows)   \nStep by Step Algorithm\n\n\nCheck Special Cases:\n\nIf numRows is 1 or greater than or equal to the length of the input string s, it means that the ZigZag pattern will be the same as the input string. In such cases, just return the input string s as it is.\n\nif numRows == 1 or numRows >= len(s):\n    return s\n\n\nInitialization:\n\nInitialize idx to keep track of the current row index, starting from 0, and d as the direction of traversal (1 for downward, -1 for upward).\nCreate a list of numRows empty lists to represent the rows of the ZigZag pattern.\n\nidx, d = 0, 1\nrows = [[] for row in range(numRows)]\n\n\nTraverse through the String:\n\nIterate through each character char in the input string s.\nAppend the current character to the row indicated by the idx.\nUpdate the direction d based on the current position (idx).\nUpdate the current row index idx according to the direction d.\n\nfor char in s:\n    rows[idx].append(char)\n    if idx == 0:\n        d = 1\n    elif idx == numRows - 1:\n        d = -1\n    idx += d\n\n\nJoin Rows:\n\nIterate through each row in rows.\nJoin the characters in each row to form strings.\nUpdate each row in rows with the joined string.\n\nfor i in range(numRows):\n    rows[i] = ''.join(rows[i])\n\n\nJoin Rows into Result String:\n\nJoin all the rows together to form the final ZigZag pattern.\n\nreturn ''.join(rows)\n\n\n\nBonus\nThis is O(n2)O(n^2)O(n2).\nPythonclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1 or numRows >= len(s):\n            return s\n\n        idx, d = 0, 1\n        rows = [''] * numRows\n\n        for char in s:\n            rows[idx] += char\n            if idx == 0:\n                d = 1\n            elif idx == numRows - 1:\n                d = -1\n            idx += d\n\n        return ''.join(rows)  \n\nThank you for reading my post.\n⭐️ Please upvote it and don't forget to subscribe to my channel!\n⭐️ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n⭐️ Twitter\nhttps://twitter.com/CodingNinjaAZ\nMy previous post and video\n⭐️ Best Time to Buy and Sell Stock\npost\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/\nvideo\n",
        views: "5171",
        upvotes: "39",
        author_id: "928",
        problem_id: 7,
      },
      {
        title:
          "C++✅✅ | Faster🧭 than 95%🔥 | Easy Understanding | Clean & Concise Code |",
        body: 'PLEASE DO UPVOTE!!!!!\nConnect with Me on Linkedin -> https://www.linkedin.com/in/md-kamran-55b98521a/\nCode\n\n\nclass Solution {\npublic:\n\n    string convert(string s, int numRows) {\n    \n    if(numRows <= 1) return s;\n\n    vector<string>v(numRows, ""); \n\n    int j = 0, dir = -1;\n\n    for(int i = 0; i < s.length(); i++)\n    {\n\n        if(j == numRows - 1 || j == 0) dir *= (-1); \n\t\t \n        v[j] += s[i];\n\n        if(dir == 1) j++;\n\n        else j--;\n    }\n\n    string res;\n\n    for(auto &it : v) res += it; \n\n    return res;\n\n    }\n};\n\n\n',
        views: "72160",
        upvotes: "491",
        author_id: "210",
        problem_id: 7,
      },
      {
        title: "Simpe Java Solution | Easy to understand",
        body: 'Intuition\nThe main intuition behind this zigzag conversion lies in visualizing how characters are placed into rows as if they\'re written in a zigzag pattern on paper. For instance, with the string "PAYPALISHIRING" and 3 rows, the pattern on paper would look something like:\nP   A   H   N\nA P L S I I G\nY   I   R\nThe idea is to simulate this pattern formation using arrays where each array corresponds to a row in the zigzag pattern. By doing this, you can then simply concatenate all arrays (rows) to get the final transformed string.\nApproach\n\n\nHandle Special Cases:\nIf numRows is 1 or if numRows is greater than or equal to the length of the string s, the zigzag pattern doesn\'t alter the arrangement of s, so you can directly return the original string s.\n\n\nInitialization:\nInitialize an array of strings, where each string corresponds to a row in the zigzag pattern. Initially, all these strings are empty.\n\n\nBuilding the Zigzag Pattern:\nUse two nested loops to simulate the down and up movements in the zigzag pattern\nDownward Loop: Start from the first row and move downwards, appending characters to the respective row until you reach the bottom row.\nUpward Loop: Once the bottom is reached, move upwards (starting from the second last row to the second row), appending characters to the respective row. This forms the diagonal upward movement in the zigzag pattern.\nIn both loops, ensure that the index i (which tracks the current character of the string s being processed) does not exceed the bounds of the string. Increment i after appending a character to a row to move to the next character.\n\n\nConcatenate Rows:\nAfter the rows have been populated according to the zigzag pattern, concatenate all the rows. Traverse the array of rows and concatenate each row\'s string to build the final result string.\n\n\nReturn Result:\nReturn the concatenated result string which now holds the characters in the zigzag read order.\n\n\nCode\npublic class Solution {\n    public String convert(String s, int numRows) {\n        if (numRows == 1 || numRows >= s.length()) {\n            return s;\n        }\n\n        int len = s.length();\n        String[] rows = new String[numRows];\n        for (int j = 0; j < numRows; j++) {\n            rows[j] = "";\n        }\n\n        int i = 0;\n        while (i < len) {\n            // Going down the rows\n            for (int j = 0; j < numRows && i < len; j++) {\n                rows[j] += s.charAt(i++);\n            }\n            // Going up in a zigzag manner\n            for (int k = numRows - 2; k > 0 && i < len; k--) {\n                rows[k] += s.charAt(i++);\n            }\n        }\n\n        // Combining rows into a single string output\n        String res = "";\n        for (String row : rows) {\n            res += row;\n        }\n        return res;\n    }\n}\n',
        views: "753",
        upvotes: "1",
        author_id: "183",
        problem_id: 7,
      },
      {
        title: "Simple Implementation.",
        body: 'Intuition\n\nApproach\n\nComplexity\n\nTime complexity:\n\n\n\nSpace complexity:\n\n\nCode\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        int method = 0;\n        string ans = "";\n        vector<string> V;\n        if(numRows == 1) {\n            return s;\n        }\n        for(int i=0;i<numRows;i++) {\n            V.push_back("");\n        }\n        int index = 0;\n        for(int i=0;i<s.size();i++) {\n            V[index] += s[i];\n            if(method==0) {\n                if(index==(numRows-1)) {\n                    method = 1;\n                    index--;\n                } else {\n                    index++;\n                }\n            } else {\n                if(index==0) {\n                    method = 0;\n                    index++;\n                } else {\n                    index--;\n                }\n            }\n        }\n        for(int i=0;i<V.size();i++) {\n            ans += V[i];\n        }\n        return ans;\n    }\n};',
        views: "346",
        upvotes: "1",
        author_id: "11",
        problem_id: 7,
      },
    ],
  },
  {
    title: "7. Reverse Integer",
    description:
      "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n \nExample 1:\n\nInput: x = 123\nOutput: 321\n\n\nExample 2:\n\nInput: x = -123\nOutput: -321\n\n\nExample 3:\n\nInput: x = 120\nOutput: 21\n\n\n \nConstraints:\n\n\n\t-231 <= x <= 231 - 1\n\n",
    difficulty: "Medium",
    acceptance: "66.51",
    frequency: "32.45",
    topics: [
      [
        "Linked List",
        "Suffix Array",
        "Database",
        "Ordered Set",
        "Topological Sort",
        "Backtracking",
        "Data Stream",
        "Matrix",
        "Queue",
        "Array",
      ],
    ],
    languages: [
      [
        "Java",
        "C++",
        "Racket",
        "Python3",
        "Rust",
        "C",
        "Swift",
        "Elixir",
        "Kotlin",
        "Scala",
      ],
    ],
    comments: [
      {
        author_id: "6",
        problem_id: 8,
        body: "Не могу поверить, что я решил это без помощи Google!",
        comment_reply_id: null,
      },
      {
        author_id: "15",
        problem_id: 8,
        body: "Чувствую себя настоящим гений после того, как решил эту задачу!",
        comment_reply_id: null,
      },
      {
        author_id: "964",
        problem_id: 8,
        body: "Иногда простые решения лучше всех! Не всегда нужно усложнять.",
        comment_reply_id: null,
      },
      {
        author_id: "358",
        problem_id: 8,
        body: "Сколько времени я потратил на решение этой задачи? Не считаясь!",
        comment_reply_id: null,
      },
      {
        author_id: "666",
        problem_id: 8,
        body: "Кто-нибудь еще решал эту задачу? Хотелось бы услышать ваши мысли!",
        comment_reply_id: null,
      },
      {
        author_id: "880",
        problem_id: 8,
        body: "Наконец-то я справился с этой задачей! Вперед к следующей!",
        comment_reply_id: null,
      },
      {
        author_id: "36",
        problem_id: 8,
        body: "Какие интересные подходы у других людей к этой задаче",
        comment_reply_id: null,
      },
      {
        author_id: "310",
        problem_id: 8,
        body: "Эта задача заставила меня подумать вне коробки. Очень интересное решение!",
        comment_reply_id: null,
      },
      {
        author_id: "268",
        problem_id: 8,
        body: "Это был настоящий вызов для моего ума, но я его преодолел!",
        comment_reply_id: null,
      },
      {
        author_id: "103",
        problem_id: 8,
        body: "Всегда думал, что эта задача невозможна. Но вот я, сделал это!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title:
          "Java Easy to Understand Solution with Explanation || 100% beats",
        body: "Intuition\n\nWe need to extract each decimal digit from the given number and place it in the reversed number, while ensuring that the result does not exceed the bounds of a 32-bit integer.\n\nApproach\n\n\nInitialization: Initialize a variable reverse to store the reversed number and a variable temp to store the remainder of x when divided by 10.\n\n\nReverse Calculation: Enter a while loop that continues as long as x is not equal to 0. In each iteration:\n\nCalculate the last digit of x by taking the remainder when x is divided by 10 (temp = x % 10).\nUpdate reverse by multiplying it by 10 and adding temp (reverse = reverse * 10 + temp).\nUpdate x by dividing it by 10 to remove the last digit (x = x / 10).\n\n\n\nOverflow Check: Inside the loop, check if reverse exceeds the bounds of a 32-bit signed integer (Integer.MAX_VALUE and Integer.MIN_VALUE). If it does, return 0 to indicate an overflow condition.\n\n\nReturn Reversed Number: Once the loop finishes, return the reversed number reverse as an integer.\n\n\n\nComplexity\n\nTime complexity: O(log(x))O(log(x))O(log(x))\n\n\n\nSpace complexity: O(1)O(1)O(1)\n\n\nCode\n\nclass Solution {\n    public int reverse(int x) {\n        long reverse = 0;\n        int temp;\n\n        while (x != 0) {\n            temp = x % 10;\n            reverse = reverse * 10 + temp;\n            x = x / 10;\n\n            if (reverse > Integer.MAX_VALUE || reverse < Integer.MIN_VALUE) {\n                return 0;\n            }\n        }\n\n        return (int)reverse;\n    }\n}\n",
        views: "972",
        upvotes: "6",
        author_id: "1",
        problem_id: 8,
      },
      {
        title: "✅ My C++Solution Beats 100% || 0ms Run time ✅",
        body: "\nLinkedin Profile (https://linkedin.com/in/ayush-kumar-a276a124a)\n//-------------> 👻 Pls Upvote if it is helpful for You 👻 <-----------------//\n\nApproach\n\n\nFirst we decleare a variable r and initilise it to 0\n\n\nThen each time find remainder Using modulus Operator\n\n\nThen add remainder to r Lets Understand with example\n\n\n\n\nThen compare The value of  r  to check it is inside the 32-bit   integer range [-2^31, 2^31 - 1]   Then  return r\nOtherwise return 0;\n\n\n- Space complexity:  O(1) \n\nCode using 64 bit integer\nclass Solution {                      \npublic:\n    int reverse(int x) {\n        long r=0;      // decleare r \n        while(x){\n         r=r*10+x%10; // find remainder and add its to r\n         x=x/10;     // Update the value of x\n        }\n        if(r>INT_MAX || r<INT_MIN) return 0; // check range if r is outside the range then return 0  \n        return int(r);  // if r in the 32 bit range then return r\n    }\n}; \n**\nCode using 32 bit integer\nclass Solution {                      \npublic:\n    int reverse(int x) {\n        int r=0;      // decleare r \n        while(x){\n         if (r>INT_MAX/10 || r<INT_MIN/10) return 0; // check 32 bit range if r is outside the range then return 0 \n         r=r*10+x%10; // find remainder and add its to r\n         x=x/10;     // Update the value of x\n        } \n        return r;  // if r in the 32 bit range then return r\n    }\n}; \n**\n\n\n👻 IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION👻*\n\n",
        views: "115860",
        upvotes: "615",
        author_id: "581",
        problem_id: 8,
      },
      {
        title: "【Video】2 ways to solve this question",
        body: 'Intuition\nConvert input to string or use remainders.\nSolution Video\n\n⭐️⭐️ Don\'t forget to subscribe to my channel! ⭐️⭐️\n■ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\nSubscribers: 4,010\nThank you for your support!\n\nApproach\nI think there are several ways to reverse integer but I\'ll show you two ways to solve this question.\nSolution 1 - Convert to string\nSimply, if we convert input number to string, we can reverse the string number then convert it to integer again.\nInput: x = 123\nConvert to string.\n123 → "123"\nThen reverse "123".\n"123" → "321"\nThen Convert it to integer again.\n"321" → 321\nreturn 321\nBe careful! We have also negative case. In that case, start reversing the string from index 1, not index 0.\nEasy!😄\nLet\'s see a solution codes and step by step algorithm!\nIn the solution codes, we have\nif res > 2 ** 31 - 1 or res < -2 ** 31:\n    return 0\nbut we don\'t have to worry about it. It\'s a requirement the description says.\n\nIf reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.\n\n\n⭐️ I recently created a video on how I\'ve been using LeetCode to learn.\n\n\nPythonJavaScriptJavaclass Solution:\n    def reverse(self, x: int) -> int:\n        res = 0\n        if x < 0:\n            res = int(str(x)[1:][::-1]) * -1\n        else:\n            res = int(str(x)[::-1])\n        \n        if res > 2 ** 31 - 1 or res < -2 ** 31:\n            return 0\n        \n        return res\nStep by step algorithm\n\n\nInitialize the result variable res:\nres = 0\n\nWe start by initializing the variable res to store the reversed integer.\n\n\n\nCheck if the input number x is negative:\nif x < 0:\n\nWe check if the given integer x is negative.\n\n\n\nReverse the digits of the integer:\nres = int(str(x)[1:][::-1]) * -1\n\nIf x is negative, we convert it to a string, remove the negative sign (str(x)[1:]), reverse the string ([::-1]), convert it back to an integer, and then multiply by -1 to keep the sign negative.\n\n\n\nHandle positive integers:\nelse:\n    res = int(str(x)[::-1])\n\nIf x is positive, we simply convert it to a string, reverse the string, and then convert it back to an integer.\n\n\n\nCheck for overflow:\nif res > 2 ** 31 - 1 or res < -2 ** 31:\n    return 0\n\nWe check if the reversed integer res is within the range of a 32-bit signed integer. If it exceeds this range, we return 0 to indicate overflow.\n\n\n\nReturn the reversed integer:\nreturn res\n\nFinally, we return the reversed integer.\n\n\n\nOverall, the code efficiently reverses the digits of the given integer while handling negative numbers and checking for overflow. It demonstrates a concise approach to solve the problem.\n\nSolution 2 - Using remainder\nLet me use the same input.\nInput: x = 123\nIn the end, we want to return 321, so how we can move 3 to the first position?\nMy strategy is to use remainder divided by 10.\n123 % 10 = 3\nWe can get 3 easily and add 3 to result variable(=res).\nres = 3\nBut the next question is "How can we get 2 from 123?"\nMy answer is to divide 123 by 10 so that we can get 12 for the next process. This time not remainder, we use the answer.\n123 // 10 = 12\nx = 12\nWe will get remainder of\n12 % 10 = 2\nThe next problem is now res = 3 and we got 2. We want to create 32 right? Because in the end we want to return 321. How can we create 32 with 3 and 2?\nMy answer is to multiply 10 with res, then add remainder(= 2) to it.\n\n⭐️ Points\nres = (res * 10) + (x % 10)\nres = (3 * 10) + (12 % 10)\n= 32\n\nWe got 32. Next, we want 1 to create 321, so devide 12 by 10.\n12 // 10 = 1\nx = 1\nThen we use the same formula above.\nres = (res * 10) + (x % 10)\nres = (32 * 10) + (1 % 10)\n= 321\n\nx(= 1) // 10 = 0\nWhen we reach 0, we finish iteration.\nreturn 321\nOf course, we handle negative case, but I believe you can understand it easily if you see the solution codes. Just convert a negative to a positive, reverse numbers, then convert the positive to a negative before we return output.\nPythonJavaScriptJavaclass Solution:\n    def reverse(self, x: int) -> int:\n        is_negative = False\n\n        if x < 0:\n            is_negative = True\n            x *= -1\n        \n        res = 0\n        while x > 0:\n            res = (res * 10) + (x % 10)\n            x //= 10\n        \n        if res > 2 ** 31 - 1:\n            return 0\n        \n        return res * -1 if is_negative else res\n                \nStep by step algorithm\n\n\nInitialize a boolean variable to track negativity:\nis_negative = False\n\nWe initialize a boolean variable is_negative to keep track of whether the input integer x is negative.\n\n\n\nCheck if the input number x is negative:\nif x < 0:\n    is_negative = True\n    x *= -1\n\nIf the input integer x is negative, we set is_negative to True and make x positive by multiplying it by -1.\n\n\n\nReverse the digits of the integer:\nres = 0\nwhile x > 0:\n    res = (res * 10) + (x % 10)\n    x //= 10\n\nWe initialize a variable res to store the reversed integer.\nInside the while loop, we repeatedly extract the last digit of x using the modulo operator %, add it to the current value of res multiplied by 10, and then update x by removing its last digit using integer division //.\n\n\n\nCheck for integer overflow:\nif res > 2 ** 31 - 1:\n    return 0\n\nWe check if the reversed integer res exceeds the range of a 32-bit signed integer. If it does, we return 0 to indicate integer overflow.\n\n\n\nReturn the reversed integer:\nreturn res * -1 if is_negative else res\n\nIf the original input integer x was negative, we return the reversed integer with a negative sign. Otherwise, we return the reversed integer as is.\n\n\n\nThe code efficiently reverses the digits of the given integer while handling negative numbers and checking for integer overflow. It demonstrates a concise approach to solve the problem.\n\nThank you for reading my post. Please upvote it and don\'t forget to subscribe to my channel!\n⭐️ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n⭐️ Twitter\nhttps://twitter.com/CodingNinjaAZ',
        views: "6622",
        upvotes: "25",
        author_id: "150",
        problem_id: 8,
      },
      {
        title:
          "# EASY JAVA 100% easy and best approach with explaination in HINDI+ENGLISH BOTH",
        body: "Intuition\njust like reversing of an integer we have to solve the question in addition with the overflow and underflow condition 🤧\nApproach\nENGLISH MEIN:\n1.Initialize the reversed number (rev) to 0.\n2.Loop through each digit of the input number.\nFor each digit, check if adding it to the reversed number will cause an overflow.\n3.If an overflow is detected, return 0.\nOtherwise, update the reversed number by multiplying it by 10 and adding the current digit.\n4.Continue this process until all digits are processed.\n5.Return the reversed number with the appropriate sign.\nHINDI MEIN:\n*********1.Reversed number (rev) ko 0 se shuru karo:\nJaise hi humein ek number ka reverse nikalna hai, hum shuruwat mein reverse number ko 0 se initialize karte hain.\n2.Har digit ko loop ke dwara check karo:\nHar digit ko dekho, iske liye hum loop ka istemal karte hain.\n3.Har digit ko reversed number mein add karne se overflow hoga ya nahi, yeh check karo:\nHar bar jab hum ek digit ko reversed number mein add karte hain, tab yeh dekhte hain ki kya yeh next iteration mein overflow karega ya nahi.\n4.Agar overflow hota hai, toh 0 return karo:\nAgar overflow detect hota hai, matlab agar reversed number bahut bada ho gaya hai, toh hum 0 return karte hain.\n5.Warna, reversed number ko 10 se multiply karke current digit ko add karo aur process ko continue karo:\nAgar overflow nahi hua, toh hum reversed number ko 10 se multiply karte hain aur current digit ko add karte hain. Fir hum next digit ke liye is process ko continue karte hain.\n6.Yeh process tab tak chalti hai jab tak saare digits process ho jaye:\nHum yeh process har digit ke liye repeat karte hain jab tak saare digits process ho jaye.\n7.Reversed number ko appropriate sign ke sath return karo:\nAnt mein, hum reversed number ko input number ke sign ke hisaab se return karte hain*.*****\nComplexity\n-Time Complexity: O(log(x))\n-Space Complexity: O(1)\n\n**\nCode\nclass Solution {\n    public int reverse(int x) {\n        int num = Math.abs(x);  // Original number ka absolute value nikala\n        \n        int rev = 0;  // Reversed number\n        \n        while (num != 0) {\n            int ld = num % 10;  // Last digit nikala\n            \n            // Overflow check\n            if (rev > (Integer.MAX_VALUE - ld) / 10) {\n                return 0;  // Agar overflow hua, toh 0 return kardo\n            }\n            \n            rev = rev * 10 + ld;  // Reverse mein digit ko add kiya\n            num = num / 10;  // Last digit hata diya, next iteration ke liye\n        }\n        \n        return (x < 0) ? (-rev) : rev;  // Original number ke sign ke hisaab se result diya\n    }\n}\nGUYS ACCHA LAGA TO UPVOTE KARANA !!!!😊",
        views: "13974",
        upvotes: "101",
        author_id: "224",
        problem_id: 8,
      },
    ],
  },
  {
    title: "8. String to Integer (atoi)",
    description:
      'Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.\n\nThe algorithm for myAtoi(string s) is as follows:\n\n\n\tWhitespace: Ignore any leading whitespace (" ").\n\tSignedness: Determine the sign by checking if the next character is \'-\' or \'+\', assuming positivity is neither present.\n\tConversion: Read the integer by skipping leading zeros until a non-digit character is encountered or the end of the string is reached. If no digits were read, then the result is 0.\n\tRounding: If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then round the integer to remain in the range. Specifically, integers less than -231 should be rounded to -231, and integers greater than 231 - 1 should be rounded to 231 - 1.\n\n\nReturn the integer as the final result.\n\n \nExample 1:\n\n\nInput: s = "42"\n\nOutput: 42\n\nExplanation:\n\nThe underlined characters are what is read in and the caret is the current reader position.\nStep 1: "42" (no characters read because there is no leading whitespace)\n         ^\nStep 2: "42" (no characters read because there is neither a \'-\' nor \'+\')\n         ^\nStep 3: "42" ("42" is read in)\n           ^\n\n\n\nExample 2:\n\n\nInput: s = " -042"\n\nOutput: -42\n\nExplanation:\n\nStep 1: "   -042" (leading whitespace is read and ignored)\n            ^\nStep 2: "   -042" (\'-\' is read, so the result should be negative)\n             ^\nStep 3: "   -042" ("042" is read in, leading zeros ignored in the result)\n               ^\n\n\n\nExample 3:\n\n\nInput: s = "1337c0d3"\n\nOutput: 1337\n\nExplanation:\n\nStep 1: "1337c0d3" (no characters read because there is no leading whitespace)\n         ^\nStep 2: "1337c0d3" (no characters read because there is neither a \'-\' nor \'+\')\n         ^\nStep 3: "1337c0d3" ("1337" is read in; reading stops because the next character is a non-digit)\n             ^\n\n\n\nExample 4:\n\n\nInput: s = "0-1"\n\nOutput: 0\n\nExplanation:\n\nStep 1: "0-1" (no characters read because there is no leading whitespace)\n         ^\nStep 2: "0-1" (no characters read because there is neither a \'-\' nor \'+\')\n         ^\nStep 3: "0-1" ("0" is read in; reading stops because the next character is a non-digit)\n          ^\n\n\n\nExample 5:\n\n\nInput: s = "words and 987"\n\nOutput: 0\n\nExplanation:\n\nReading stops at the first non-digit character \'w\'.\n\n\n \nConstraints:\n\n\n\t0 <= s.length <= 200\n\ts consists of English letters (lower-case and upper-case), digits (0-9), \' \', \'+\', \'-\', and \'.\'.\n\n',
    difficulty: "Medium",
    acceptance: "38.97",
    frequency: "175.95",
    topics: [
      [
        "Bit Manipulation",
        "String",
        "String Matching",
        "Eulerian Circuit",
        "Quickselect",
        "Trie",
        "Binary Search",
        "Ordered Set",
        "Hash Function",
        "Recursion",
      ],
    ],
    languages: [
      [
        "Python3",
        "Dart",
        "TypeScript",
        "Scala",
        "Go",
        "Python",
        "Elixir",
        "Erlang",
        "Racket",
        "C#",
      ],
    ],
    comments: [
      {
        author_id: "192",
        problem_id: 9,
        body: "Вот почему я люблю программирование - за такие интересные задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "157",
        problem_id: 9,
        body: "У кого-нибудь есть идеи, как можно оптимизировать мое решение? Пока я не совсем доволен своим подходом.",
        comment_reply_id: null,
      },
      {
        author_id: "293",
        problem_id: 9,
        body: "Кто-нибудь еще решал эту задачу? Хотелось бы услышать ваши мысли!",
        comment_reply_id: null,
      },
      {
        author_id: "333",
        problem_id: 9,
        body: "Как я мог пропустить этот трюк? Благодарю за подсказку!",
        comment_reply_id: null,
      },
      {
        author_id: "280",
        problem_id: 9,
        body: "Эта задача была настоящим испытанием ума! Сложность на высшем уровне.",
        comment_reply_id: null,
      },
      {
        author_id: "467",
        problem_id: 9,
        body: "Не могу поверить, что я решил это без помощи Google!",
        comment_reply_id: null,
      },
      {
        author_id: "793",
        problem_id: 9,
        body: "Было трудно, но я нашел путь к решению этой задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "74",
        problem_id: 9,
        body: "Теперь я чувствую, что могу решить что угодно!",
        comment_reply_id: null,
      },
      {
        author_id: "846",
        problem_id: 9,
        body: "Я так рад, что решил эту задачу! Это действительно научило меня чему-то новому.",
        comment_reply_id: null,
      },
      {
        author_id: "755",
        problem_id: 9,
        body: "Какие интересные подходы у других людей к этой задаче",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "75 Lines of Code-C# -> Beginner Level",
        body: 'Intuition\n\nApproach\n\nComplexity\n\nTime complexity:\n\n\n\nSpace complexity:\n\n\nCode\npublic class Solution {\n    public int MyAtoi(string s) {\n        long aq=0;\n          string str="";  string plus=""; int mmvalue=0;  s=s.Trim();\n          string n=""; int num=0; int flag=0; string its=""; long fg=0;\n          for(int i=0;i<s.Length;i++){\n            if(s[i]>=48 && s[i]<=57) fg++;\n            if(fg==s.Length){\n    BigInteger hj=BigInteger.Parse(s); if(hj>=int.MaxValue){ return int.MaxValue;  } \n    else if(hj<=int.MinValue){ return int.MinValue; } } }\n          try{\n          if(s[0]==\'-\'){\n            for(int it=1;it<s.Length;it++){\n            if(s[it]>=48 && s[it]<=57) its+=s[it]; else break;\n        }\n         BigInteger aqq=BigInteger.Parse(its)*-1;\n        if(aqq>=int.MaxValue){ return int.MaxValue;  } \n        else if(aqq<=int.MinValue){ return int.MinValue; } \n        return Convert.ToInt32(its)*-1; \n          } }\n          catch {\n            \n           return 0;}\n          try{\n    if(s[0]!=\'-\'){\n        for(int i=0;i<s.Length;i++){\n            if(s[i]>=48 && s[i]<=57)\n            mmvalue++;\n        }\n        if(mmvalue==s.Length){\n    long mm=Convert.ToInt64(s); if(mm>=int.MaxValue){ return int.MaxValue;  } \n    else if(mm<=int.MinValue){ return int.MinValue; } } }\n            if(s[0]==\'+\'){\n                for(int j=1;j<s.Length;j++){\n                    if(s[j]>=48 && s[j]<=57) plus+=s[j]; \n                    else break;\n                } \n    BigInteger oo=BigInteger.Parse(plus); if(oo>=int.MaxValue){ return int.MaxValue;  } \n    else if(oo<=int.MinValue){ return int.MinValue; } \n            return Convert.ToInt32(plus); \n        }\n       \n       else if(s[0]==\'-\'){\n             string st=s.Substring(1,s.Length-1);\n             long stin=Convert.ToInt64(st);\n            for(int i=1;i<s.Length;i++){\n                if(s[i]>=48 && s[i]<=57){ n+=s[i]; num++; flag=1; }\n                Console.WriteLine(s[i]+" "+(s.Length-1)+" "+num+" "+n);\n            }\n             long ans=Convert.ToInt64(n);\n             int anss=(int)ans;\n             Console.WriteLine(stin+" "+ans);\n             if((s.Length-1)==num && stin!=anss) return Int32.MinValue;\n             if((s.Length-1)==num && flag==1) return (int)ans*-1;\n        }\n       \n      int c=0;\n        for(int i=0;i<s.Length;i++){\n            if(s[i]>=48 && s[i]<=57){\n                 str+=s[i]; c++;\n            }\n            else if(s[i]>=97 && s[i]<=122 && c==0){ return 0; }\n            else break;\n        }\n         Console.WriteLine(str);\n    BigInteger yu=BigInteger.Parse(str); if(yu>=int.MaxValue){ return int.MaxValue;  } \n    else if(yu<=int.MinValue){ return int.MinValue; } \n         return Convert.ToInt32(str);\n    }\n    catch {\n       return 0; \n    }\n       return 0;\n    }\n}',
        views: "79",
        upvotes: "1",
        author_id: "520",
        problem_id: 9,
      },
      {
        title:
          "Beats 100% of users with C++ || Best Solution || Fast Solution || Easy to Understand",
        body: "Abhiraj Pratap Singh\n\nif you like the solution please UPVOTE IT...\n\nIntuition\n\n\nThe given code appears to be a C++ implementation of a function myAtoi that converts a string to an integer. The function processes the input string character by character, skipping leading whitespaces, determining the sign of the number, and converting the numeric characters to an integer. It also handles overflow conditions and returns the converted integer.\n\n\n\n\nApproach\n\n\nInitialize variables i (for iterating through the string), sign (to store the sign of the number), and ans (to accumulate the converted integer).\nSkip leading whitespaces by incrementing i until a non-whitespace character is encountered.\nDetermine the sign of the number by checking for '-' or '+'. Update the sign variable accordingly.\nIterate through the remaining characters of the string, converting numeric characters to integers and updating the result (ans).\nCheck for overflow conditions during the conversion process. If overflow occurs, return INT_MIN or INT_MAX depending on the sign\nReturn the final result, considering the sign of the number.\n\n\n\nComplexity\n\n\nTime complexity: O(n), *where n is the length of the input string. The function processes each character in the string once.\n\n\n\nSpace complexity: O(1), as the function uses a constant amount of extra space regardless of the input size.\n\n\n\nNote: The code has a small issue. The check for overflow condition if(ans>INT_MAX && sign==-1) should be if(ans>INT_MAX && sign==1) because for negative numbers, INT_MIN is the lower bound.\n\n\nCode\nclass Solution {\npublic:\n    int myAtoi(string s) \n    {\n        int i=0;\n        int sign=1;\n        long ans=0;\n        while(i<s.length() && s[i]==' ')\n            i++;\n        if(s[i]=='-')\n        {\n            sign=-1;\n            i++;\n        }\n        else if(s[i]=='+')\n            i++;\n        while(i<s.length())\n        {\n            if(s[i]>='0' && s[i]<='9')\n            {\n                ans=ans*10+(s[i]-'0');\n                if(ans>INT_MAX && sign==-1)\n                    return INT_MIN;\n                else if(ans>INT_MAX && sign==1)\n                    return INT_MAX;\n                i++;\n            }\n            else\n                return ans*sign;\n        }\n        return (ans*sign);\n    }\n};\n\nIF YOU LIKE THE APPROACH PLEASE UPVOTE IT\n\n\n\n",
        views: "10942",
        upvotes: "80",
        author_id: "446",
        problem_id: 9,
      },
      {
        title:
          "✅☑️ Best C++ Solution Ever || Easy to understand || String || One Stop Solution.",
        body: "Intuition\n\nWe can solve this problem using String.\nApproach\n\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\nComplexity\n\nTime complexity:\n\n\nTime Complexity : O(logN), Since we are going through the entire number digit by digit, the time complexity should be O(log10N). The reason behind log10 is because we are dealing with integers which are base 10.\n\nSpace complexity:\n\n\nSpace Complexity : O(1), We are not using any data structure for interim operations, therefore, the space complexity is O(1).\nCode\n/*\n\n    Time Complexity : O(logN), Since we are going through the entire number digit by digit, the time complexity\n    should be O(log10N). The reason behind log10 is because we are dealing with integers which are base 10.\n\n    Space Complexity : O(1), We are not using any data structure for interim operations, therefore, the space\n    complexity is O(1).\n\n    Solved using String.\n\n*/\n\nclass Solution {\npublic:\n    int myAtoi(string s) {\n        int len = s.size();\n        double num = 0;\n        int i=0;\n        while(s[i] == ' '){\n            i++;\n        }\n        bool positive = s[i] == '+';\n        bool negative = s[i] == '-';\n        positive == true ? i++ : i;\n        negative == true ? i++ : i;\n        while(i < len && s[i] >= '0' && s[i] <= '9'){\n            num = num*10 + (s[i]-'0');\n            i++;\n        }\n        num = negative ? -num : num;\n        cout<<num<<endl;\n        num = (num > INT_MAX) ? INT_MAX : num;\n        num = (num < INT_MIN) ? INT_MIN : num;\n        cout<<num<<endl;\n        return int(num);\n    }\n};\n\nIF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.\n",
        views: "41385",
        upvotes: "237",
        author_id: "787",
        problem_id: 9,
      },
      {
        title: "sollution in c++",
        body: "Intuition\n\nApproach\n\nComplexity\n\nTime complexity:\n\n\n\nSpace complexity:\n\n\nCode\nclass Solution {\n public:\n  int myAtoi(string s) {\n    trim(s);\n    if (s.empty())\n      return 0;\n\n    const int sign = s[0] == '-' ? -1 : 1;\n    if (s[0] == '+' || s[0] == '-')\n      s = s.substr(1);\n\n    long num = 0;\n\n    for (const char c : s) {\n      if (!isdigit(c))\n        break;\n      num = num * 10 + (c - '0');\n      if (sign * num < INT_MIN)\n        return INT_MIN;\n      if (sign * num > INT_MAX)\n        return INT_MAX;\n    }\n\n    return sign * num;\n  }\n\n private:\n  void trim(string& s) {\n    s.erase(0, s.find_first_not_of(' '));\n    s.erase(s.find_last_not_of(' ') + 1);\n  }\n};\n\n        \n    \n",
        views: "1573",
        upvotes: "1",
        author_id: "380",
        problem_id: 9,
      },
    ],
  },
  {
    title: "9. Palindrome Number",
    description:
      "Given an integer x, return true if x is a palindrome, and false otherwise.\n\n \nExample 1:\n\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\n\n\nExample 2:\n\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\n\nExample 3:\n\nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n\n\n \nConstraints:\n\n\n\t-231 <= x <= 231 - 1\n\n\n \nFollow up: Could you solve it without converting the integer to a string?",
    difficulty: "Easy",
    acceptance: "28.34",
    frequency: "23.35",
    topics: [
      [
        "Reservoir Sampling",
        "Rejection Sampling",
        "Greedy",
        "Number Theory",
        "Minimum Spanning Tree",
        "Recursion",
        "Rolling Hash",
        "Strongly Connected Component",
        "Trie",
        "Two Pointers",
      ],
    ],
    languages: [
      [
        "Python3",
        "Scala",
        "Kotlin",
        "C++",
        "C#",
        "Elixir",
        "Python",
        "JavaScript",
        "TypeScript",
        "Erlang",
      ],
    ],
    comments: [
      {
        author_id: "9",
        problem_id: 10,
        body: "Эта задача показала мне, насколько важно быть терпеливым в программировании.",
        comment_reply_id: null,
      },
      {
        author_id: "174",
        problem_id: 10,
        body: "Подсказки были такими полезными! Они действительно помогли мне решить эту задачу.",
        comment_reply_id: null,
      },
      {
        author_id: "156",
        problem_id: 10,
        body: "Эта задача показала мне, насколько важно быть терпеливым в программировании.",
        comment_reply_id: null,
      },
      {
        author_id: "232",
        problem_id: 10,
        body: "Это моя новая любимая задача! Хочу попробовать еще раз!",
        comment_reply_id: null,
      },
      {
        author_id: "722",
        problem_id: 10,
        body: "Эта задача вынудила меня глубже погрузиться в язык программирования.",
        comment_reply_id: null,
      },
      {
        author_id: "990",
        problem_id: 10,
        body: "Кто-нибудь сталкивался с такой ошибкой раньше? Не могу понять, в чем проблема.",
        comment_reply_id: null,
      },
      {
        author_id: "894",
        problem_id: 10,
        body: "Я просто в восторге от того, как эффективно работает мое решение!",
        comment_reply_id: null,
      },
      {
        author_id: "176",
        problem_id: 10,
        body: "Мой мозг сейчас в кипении от этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "659",
        problem_id: 10,
        body: "Это моя новая любимая задача! Хочу попробовать еще раз!",
        comment_reply_id: null,
      },
      {
        author_id: "374",
        problem_id: 10,
        body: "Всегда думал, что эта задача невозможна. Но вот я, сделал это!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title:
          "✅2 Method's || C++ || JAVA || PYTHON || Beginner Friendly🔥🔥🔥",
        body: "Intuition:\nThe intuition behind this code is to reverse the entire input number and check if the reversed number is equal to the original number. If they are the same, then the number is a palindrome.\nApproach 1: Reversing the Entire Number\nExplanation:\n\n\nWe begin by performing an initial check. If the input number x is negative, it cannot be a palindrome since palindromes are typically defined for positive numbers. In such cases, we immediately return false.\n\n\nWe initialize two variables:\n\nreversed: This variable will store the reversed value of the number x.\ntemp: This variable is a temporary placeholder to manipulate the input number without modifying the original value.\n\n\n\nWe enter a loop that continues until temp becomes zero:\n\nInside the loop, we extract the last digit of temp using the modulo operator % and store it in the digit variable.\nTo reverse the number, we multiply the current value of reversed by 10 and add the extracted digit.\nWe then divide temp by 10 to remove the last digit and move on to the next iteration.\n\n\n\nOnce the loop is completed, we have reversed the entire number. Now, we compare the reversed value reversed with the original input value x.\n\nIf they are equal, it means the number is a palindrome, so we return true.\nIf they are not equal, it means the number is not a palindrome, so we return false.\n\n\n\nThe code uses a long long data type for the reversed variable to handle potential overflow in case of large input numbers.\nCode\nC++JavaPython3class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x < 0) {\n            return false;\n        }\n\n        long long reversed = 0;\n        long long temp = x;\n\n        while (temp != 0) {\n            int digit = temp % 10;\n            reversed = reversed * 10 + digit;\n            temp /= 10;\n        }\n\n        return (reversed == x);\n    }\n};\n\nApproach 2: Reversing Half of the Number\nInstead of reversing the entire number, we can reverse only the last half of the number. This approach is tricky because when we reverse the last half of the number, we don't want the middle digit to be reversed back to its original value. This can happen if the number has an odd number of digits. To resolve this, we can compare the first half of the number with the reversed second half of the number.\nExplanation:\n\n\nWe begin with an initial check to handle special cases:\n\nIf the input number x is negative, it cannot be a palindrome since palindromes are typically defined for positive numbers. In such cases, we immediately return false.\nIf x is non-zero and ends with a zero, it cannot be a palindrome because leading zeros are not allowed in palindromes. We return false for such cases.\n\n\n\nWe initialize two variables:\n\nreversed: This variable will store the reversed second half of the digits of the number.\ntemp: This variable is a temporary placeholder to manipulate the input number without modifying the original value.\n\n\n\nWe enter a loop that continues until the first half of the digits (x) becomes less than or equal to the reversed second half (reversed):\n\nInside the loop, we extract the last digit of x using the modulo operator % and add it to the reversed variable after multiplying it by 10 (shifting the existing digits to the left).\nWe then divide x by 10 to remove the last digit and move towards the center of the number.\n\n\n\nOnce the loop is completed, we have reversed the second half of the digits. Now, we compare the first half of the digits (x) with the reversed second half (reversed) to determine if the number is a palindrome:\n\nFor an even number of digits, if x is equal to reversed, then the number is a palindrome. We return true.\nFor an odd number of digits, if x is equal to reversed / 10 (ignoring the middle digit), then the number is a palindrome. We return true.\nIf none of the above conditions are met, it means the number is not a palindrome, so we return false.\n\n\n\nThe code avoids the need for reversing the entire number by comparing only the necessary parts. This approach reduces both time complexity and memory usage, resulting in a more efficient solution.\nCode\nC++JavaPython3class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x < 0 || (x != 0 && x % 10 == 0)) {\n            return false;\n        }\n\n        int reversed = 0;\n        while (x > reversed) {\n            reversed = reversed * 10 + x % 10;\n            x /= 10;\n        }\n        return (x == reversed) || (x == reversed / 10);\n    }\n};\n\nIf you are a beginner solve these problems which makes concepts clear for future coding:\n\nTwo Sum\nRoman to Integer\nPalindrome Number\nMaximum Subarray\nRemove Element\nContains Duplicate\nAdd Two Numbers\nMajority Element\nRemove Duplicates from Sorted Array\nPractice them in a row for better understanding and please Upvote for more questions.\n\nIf you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.",
        views: "287092",
        upvotes: "1.2K",
        author_id: "684",
        problem_id: 10,
      },
      {
        title: "",
        body: "",
        views: 0,
        upvotes: 0,
        author_id: "113",
        problem_id: 10,
      },
      {
        title: "✅ Fastest JAVA solution",
        body: "For better Visualization:\n\nIdea\nWe're going to convert our int to String and then compare the first element to the very last element, second element to second last element and so on [elements at the same distance from the beginning and from the end].. If they don't match we return a False\nJAVA Code\nJAVAclass Solution {\n    public boolean isPalindrome(int x) {\n        String s = String.valueOf(x); // Convert to String\n        int n = s.length(); // Store the String length to int n\n\n        for (int i=0; i<n/2; i++) {\n            // We check whether the elements at the same distance from\n            // beginning and from ending are same, if not we return false\n            if (s.charAt(i) != s.charAt(n-i-1)) return false;\n        }\n\n        // if no flaws are found we return true\n        return true;\n    }\n}\nThere is another approach to this problem:\nWe can store one half of the integer in a another variable in reversed order. Then we compare it to the other unaltered half of the number and see if they are equal or not [which should be in case of palindromes]\nJAVAclass Solution {\n    public boolean isPalindrome(int x) {\n        if (x<0 || (x!=0 && x%10==0)) return false;\n        int rev = 0;\n        while (x>rev){\n            rev = rev*10 + x%10;\n            x = x/10;\n        }\n        return (x==rev || x==rev/10);\n    }\n}\n",
        views: "128626",
        upvotes: "717",
        author_id: "796",
        problem_id: 10,
      },
      {
        title: "Easy Solution | beginner friendly | understandable",
        body: "Approach\n\nIterative\nComplexity\n\nTime complexity:O(n)\n\n\n\nSpace complexity:O(1)\n\n\nCode\nbool isPalindrome(int x)\n{\n\n    long int x1 = 0;\n    long int s = x;\n\n    if (x < 0)\n    {\n        return 0;\n    }\n\n    while (x > 0)\n    {\n\n        x1 *= 10;\n        x1 += x % 10;\n        x /= 10;\n    }\n\n    if (s == x1)\n    {\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}",
        views: "1138",
        upvotes: "1",
        author_id: "784",
        problem_id: 10,
      },
    ],
  },
  {
    title: "10. Regular Expression Matching",
    description:
      'Given an input string s and a pattern p, implement regular expression matching with support for \'.\' and \'*\' where:\n\n\n\t\'.\' Matches any single character.​​​​\n\t\'*\' Matches zero or more of the preceding element.\n\n\nThe matching should cover the entire input string (not partial).\n\n \nExample 1:\n\nInput: s = "aa", p = "a"\nOutput: false\nExplanation: "a" does not match the entire string "aa".\n\n\nExample 2:\n\nInput: s = "aa", p = "a*"\nOutput: true\nExplanation: \'*\' means zero or more of the preceding element, \'a\'. Therefore, by repeating \'a\' once, it becomes "aa".\n\n\nExample 3:\n\nInput: s = "ab", p = ".*"\nOutput: true\nExplanation: ".*" means "zero or more (*) of any character (.)".\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 20\n\t1 <= p.length <= 20\n\ts contains only lowercase English letters.\n\tp contains only lowercase English letters, \'.\', and \'*\'.\n\tIt is guaranteed for each appearance of the character \'*\', there will be a previous valid character to match.\n\n',
    difficulty: "Hard",
    acceptance: "49.84",
    frequency: "140.29",
    topics: [
      [
        "Shell",
        "Ordered Set",
        "Monotonic Queue",
        "Hash Table",
        "Counting",
        "Iterator",
        "Enumeration",
        "Union Find",
        "Topological Sort",
        "Randomized",
      ],
    ],
    languages: [
      [
        "Scala",
        "Elixir",
        "Dart",
        "PHP",
        "Python",
        "Java",
        "C++",
        "C",
        "TypeScript",
        "C#",
      ],
    ],
    comments: [
      {
        author_id: "29",
        problem_id: 11,
        body: "Всегда думал, что эта задача невозможна. Но вот я, сделал это!",
        comment_reply_id: null,
      },
      {
        author_id: "350",
        problem_id: 11,
        body: "Самая сложная часть в этой задаче - это формулировка.",
        comment_reply_id: null,
      },
      {
        author_id: "618",
        problem_id: 11,
        body: "Не могу поверить, что решил это за одну попытку! Сейчас немного в шоке.",
        comment_reply_id: null,
      },
      {
        author_id: "980",
        problem_id: 11,
        body: "Эта задача показала мне, насколько важно быть терпеливым в программировании.",
        comment_reply_id: null,
      },
      {
        author_id: "565",
        problem_id: 11,
        body: "Не могу поверить, что я решил это без помощи Google!",
        comment_reply_id: null,
      },
      {
        author_id: "891",
        problem_id: 11,
        body: "Эта задача показала мне, насколько важно быть терпеливым в программировании.",
        comment_reply_id: null,
      },
      {
        author_id: "491",
        problem_id: 11,
        body: "Как я мог пропустить этот трюк? Благодарю за подсказку!",
        comment_reply_id: null,
      },
      {
        author_id: "165",
        problem_id: 11,
        body: "Не могу поверить, что я наконец-то разобрался с этой задачей. Спасибо, сообщество!",
        comment_reply_id: null,
      },
      {
        author_id: "238",
        problem_id: 11,
        body: "Не могу поверить, что я решил это без помощи Google!",
        comment_reply_id: null,
      },
      {
        author_id: "831",
        problem_id: 11,
        body: "Вот почему я люблю программирование - за такие интересные задачи!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "Solution",
        body: "C++Python3Javaclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int n = s.length(), m = p.length();\n        bool dp[n+1][m+1];\n        memset(dp, false, sizeof(dp));\n        dp[0][0] = true;\n        \n        for(int i=0; i<=n; i++){\n            for(int j=1; j<=m; j++){\n                if(p[j-1] == '*'){\n                    dp[i][j] = dp[i][j-2] || (i > 0 && (s[i-1] == p[j-2] || p[j-2] == '.') && dp[i-1][j]);\n                }\n                else{\n                    dp[i][j] = i > 0 && dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.');\n                }\n            }\n        }\n        \n        return dp[n][m];\n    }\n};",
        views: "41570",
        upvotes: "468",
        author_id: "547",
        problem_id: 11,
      },
      {
        title: "My Bright Solution",
        body: 'class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        return fullmatch(p.replace("***", "*"), s)',
        views: "329",
        upvotes: "2",
        author_id: "405",
        problem_id: 11,
      },
      {
        title:
          "🚀 ✅ Detailed explaination 🔥 with Pictures ✅ 🔥 🚀 in C++,Java , Python , DP bottom up tabulation.",
        body: "Approach\n\nHere the approach is very simple we basically must create a DP to store the states. For any DP problem all follow the same rule that we should memoize the truth value of (n,m)(n,m)(n,m) then we need the values of (n−1,m)(n-1 , m)(n−1,m) or (n,m−1)(n ,m-1)(n,m−1) or (n−1,m−1)(n-1 , m-1)(n−1,m−1) this would be the whole point of DP.\n\n\n\n\nThe example of mississippi is taken and the DP table is depicted below and the explaination is provided down.\n\n\n\nHere we basically broke the entire one into three cases as shown in the below picture.Now we procced based on the below three cases and construct our DP table and thus we finally obtain our answer.\n\n\n\nComplexity\n\n\nTime complexity: Here the complexity would be O(n2)O(n^2)O(n2) as we need a 2D loop for keeping the track of length of both the strings.\n\n\n\n\nSpace complexity: Here the space would also be O(n2)O(n^2)O(n2) which can later be optimised to O(n)O(n)O(n) by making space optimisation into two 1D arrays but we must do this to store the truth values of the lengths.\n\n\n\nCode\nC++JavaPythonclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int n = s.length(), m = p.length();\n        bool dp[n+1][m+1];\n        memset(dp, false, sizeof(dp));\n        dp[0][0] = true;\n        \n        for(int i=0; i<=n; i++){\n            for(int j=1; j<=m; j++){\n                if(p[j-1] == '*'){\n                    dp[i][j] = dp[i][j-2] || (i > 0 && (s[i-1] == p[j-2] || p[j-2] == '.') && dp[i-1][j]);\n                }\n                else{\n                    dp[i][j] = i > 0 && dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.');\n                }\n            }\n        }\n        \n        return dp[n][m];\n    }\n};\n\nIF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.\n",
        views: "35936",
        upvotes: "275",
        author_id: "613",
        problem_id: 11,
      },
      {
        title: "Beginner Iterative Dp",
        body: "Intuition\n\nApproach\n\nComplexity\n\nTime complexity: O(n*m)\n\n\n\nSpace complexity: O(n*m)\n\n\nCode\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int n = s.length();\n        int m = p.length();\n        bool dp[n+1][m+1];\n        dp[0][0] = true;\n        for(int i = 1; i <= n; i++){\n            dp[i][0] = false;\n        }\n        for(int i = 1; i <= m; i++){\n            dp[0][i] = false;\n        }\n        for(int i = 1; i <= m; i++){\n            if(i > 1 && p[i-1] == '*') dp[0][i] |= dp[0][i-2];\n        }\n        for(int i = 1; i <= n; i++){\n            for(int j = 1; j <= m; j++){\n                if(p[j-1] == '.'){\n                    dp[i][j] = dp[i-1][j-1];\n                }\n                else if(p[j-1] == '*'){\n                    if(j >= 2){\n                        if(s[i-1] == p[j-2] || p[j-2] == '.') dp[i][j] = dp[i-1][j];\n                        else dp[i][j] = false;\n                    }\n                    else dp[i][j] = false;\n                    if(j > 1){\n                        dp[i][j] = dp[i][j] || dp[i][j-2];\n                    }\n                }\n                else if(s[i-1] == p[j-1]){\n                    dp[i][j] = dp[i-1][j-1];\n                }\n                else dp[i][j] = false;\n            }\n        }\n\n        return dp[n][m];\n    }\n};",
        views: "885",
        upvotes: "1",
        author_id: "281",
        problem_id: 11,
      },
    ],
  },
  {
    title: "11. Container With Most Water",
    description:
      "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn the maximum amount of water a container can store.\n\nNotice that you may not slant the container.\n\n \nExample 1:\n\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n\nExample 2:\n\nInput: height = [1,1]\nOutput: 1\n\n\n \nConstraints:\n\n\n\tn == height.length\n\t2 <= n <= 105\n\t0 <= height[i] <= 104\n\n",
    difficulty: "Medium",
    acceptance: "75.00",
    frequency: "78.09",
    topics: [
      [
        "Ordered Set",
        "Trie",
        "Divide and Conquer",
        "Interactive",
        "Brainteaser",
        "Hash Table",
        "String Matching",
        "Shortest Path",
        "Queue",
        "Shell",
      ],
    ],
    languages: [
      [
        "Ruby",
        "Erlang",
        "C++",
        "C",
        "Python3",
        "Kotlin",
        "Racket",
        "JavaScript",
        "C#",
        "Go",
      ],
    ],
    comments: [
      {
        author_id: "878",
        problem_id: 12,
        body: "Как я мог не догадаться о таком подходе? Спасибо за отличное объяснение!",
        comment_reply_id: null,
      },
      {
        author_id: "695",
        problem_id: 12,
        body: "Эта задача вынудила меня глубже погрузиться в язык программирования.",
        comment_reply_id: null,
      },
      {
        author_id: "210",
        problem_id: 12,
        body: "Иногда простые решения лучше всех! Не всегда нужно усложнять.",
        comment_reply_id: null,
      },
      {
        author_id: "691",
        problem_id: 12,
        body: "Вот почему я люблю программирование - за такие интересные задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "686",
        problem_id: 12,
        body: "Это было круто! Какая следующая задача?",
        comment_reply_id: null,
      },
      {
        author_id: "778",
        problem_id: 12,
        body: "Эта задача вынудила меня глубже погрузиться в язык программирования.",
        comment_reply_id: null,
      },
      {
        author_id: "82",
        problem_id: 12,
        body: "Теперь я чувствую, что могу решить что угодно!",
        comment_reply_id: null,
      },
      {
        author_id: "194",
        problem_id: 12,
        body: "Вот почему я люблю программирование - за такие интересные задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "928",
        problem_id: 12,
        body: "Эта задача вынудила меня глубже погрузиться в язык программирования.",
        comment_reply_id: null,
      },
      {
        author_id: "928",
        problem_id: 12,
        body: "Эта задача заставила меня подумать вне коробки. Очень интересное решение!",
        comment_reply_id: null,
      },
    ],
    solutions: [],
  },
  {
    title: "12. Integer to Roman",
    description:
      'Seven different symbols represent Roman numerals with the following values:\n\nSymbolValueI1V5X10L50C100D500M1000\n\nRoman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:\n\n\n\tIf the value does not start with 4 or 9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.\n\tIf the value starts with 4 or 9 use the subtractive form representing one symbol subtracted from the following symbol, for example, 4 is 1 (I) less than 5 (V): IV and 9 is 1 (I) less than 10 (X): IX. Only the following subtractive forms are used: 4 (IV), 9 (IX), 40 (XL), 90 (XC), 400 (CD) and 900 (CM).\n\tOnly powers of 10 (I, X, C, M) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5 (V), 50 (L), or 500 (D) multiple times. If you need to append a symbol 4 times use the subtractive form.\n\n\nGiven an integer, convert it to a Roman numeral.\n\n \nExample 1:\n\n\nInput: num = 3749\n\nOutput: "MMMDCCXLIX"\n\nExplanation:\n\n3000 = MMM as 1000 (M) + 1000 (M) + 1000 (M)\n 700 = DCC as 500 (D) + 100 (C) + 100 (C)\n  40 = XL as 10 (X) less of 50 (L)\n   9 = IX as 1 (I) less of 10 (X)\nNote: 49 is not 1 (I) less of 50 (L) because the conversion is based on decimal places\n\n\n\nExample 2:\n\n\nInput: num = 58\n\nOutput: "LVIII"\n\nExplanation:\n\n50 = L\n 8 = VIII\n\n\n\nExample 3:\n\n\nInput: num = 1994\n\nOutput: "MCMXCIV"\n\nExplanation:\n\n1000 = M\n 900 = CM\n  90 = XC\n   4 = IV\n\n\n\n \nConstraints:\n\n\n\t1 <= num <= 3999\n\n',
    difficulty: "Medium",
    acceptance: "26.26",
    frequency: "146.65",
    topics: [
      [
        "Depth-First Search",
        "Prefix Sum",
        "Combinatorics",
        "Bucket Sort",
        "Union Find",
        "Number Theory",
        "Counting",
        "Suffix Array",
        "Breadth-First Search",
        "Graph",
      ],
    ],
    languages: [
      [
        "Java",
        "Kotlin",
        "Go",
        "TypeScript",
        "Python3",
        "Dart",
        "C",
        "Python",
        "Ruby",
        "Elixir",
      ],
    ],
    comments: [
      {
        author_id: "307",
        problem_id: 13,
        body: "Когда я столкнулся с этой задачей впервые, я думал, что это невозможно. Теперь я знаю иначе!",
        comment_reply_id: null,
      },
      {
        author_id: "143",
        problem_id: 13,
        body: "У кого-нибудь есть идеи, как можно оптимизировать мое решение? Пока я не совсем доволен своим подходом.",
        comment_reply_id: null,
      },
      {
        author_id: "149",
        problem_id: 13,
        body: "Это было как головоломка, но я нашел свой путь к решению!",
        comment_reply_id: null,
      },
      {
        author_id: "32",
        problem_id: 13,
        body: "У кого-нибудь есть идеи, как можно оптимизировать мое решение? Пока я не совсем доволен своим подходом.",
        comment_reply_id: null,
      },
      {
        author_id: "955",
        problem_id: 13,
        body: "Не могу поверить, что я наконец-то разобрался с этой задачей. Спасибо, сообщество!",
        comment_reply_id: null,
      },
      {
        author_id: "207",
        problem_id: 13,
        body: "Самая сложная часть в этой задаче - это формулировка.",
        comment_reply_id: null,
      },
      {
        author_id: "444",
        problem_id: 13,
        body: "Чувствую себя настоящим гений после того, как решил эту задачу!",
        comment_reply_id: null,
      },
      {
        author_id: "532",
        problem_id: 13,
        body: "Не могу поверить, что я решил это без помощи Google!",
        comment_reply_id: null,
      },
      {
        author_id: "248",
        problem_id: 13,
        body: "Эта задача заставила меня использовать все свои ресурсы!",
        comment_reply_id: null,
      },
      {
        author_id: "822",
        problem_id: 13,
        body: "Это было как головоломка, но я нашел свой путь к решению!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "Easiest O(1)😎 FAANG Method Ever !!! 💥",
        body: 'Code\nclass Solution {\npublic:\n    string intToRoman(int num) {\n        string ones[] = {"","I","II","III","IV","V","VI","VII","VIII","IX"};\n        string tens[] = {"","X","XX","XXX","XL","L","LX","LXX","LXXX","XC"};\n        string hrns[] = {"","C","CC","CCC","CD","D","DC","DCC","DCCC","CM"};\n        string ths[]={"","M","MM","MMM"};\n        \n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\n    }\n};\nPlease Upvote if it helps ❤️',
        views: "98707",
        upvotes: "546",
        author_id: "216",
        problem_id: 13,
      },
      {
        title: "Converting Integer to Roman Numeral",
        body: 'Intuition\nTo convert an integer to its corresponding Roman numeral representation, we need to break down the integer into its decimal place values and construct the Roman numeral string based on these values.\nApproach\n\nDefine arrays to store the symbols and values for each decimal place (ones, tens, hundreds, thousands).\nIterate through the values array in reverse order (from highest to lowest decimal place).\nFor each value, determine how many times it fits into the given number.\nAppend the corresponding symbol to the Roman numeral string based on the count of occurrences.\nUpdate the given number by subtracting the value multiplied by the count.\nRepeat steps 3-5 until the given number becomes zero.\nReturn the constructed Roman numeral string.\n\nComplexity\n\n\nTime complexity:\nO(1) since the maximum number of iterations is constant, depending on the number of decimal places.\n\n\nSpace complexity:\nO(1) since we use a constant amount of extra space for storing arrays and variables.\n\n\nCode\nclass Solution {\n\n    /**\n     * @param Integer $num\n     * @return String\n     */\n    function intToRoman($num) {\n        // Define symbols and values for each decimal place\n        $symbols = ["I", "IV", "V", "IX", "X", "XL", "L", "XC", "C", "CD", "D", "CM", "M"];\n        $values = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n\n        $romanNumeral = "";\n\n        // Iterate through values and symbols arrays simultaneously\n        for ($i = count($values) - 1; $i >= 0; $i--) {\n            while ($num >= $values[$i]) {\n                // Subtract the current value and append the corresponding symbol\n                $num -= $values[$i];\n                $romanNumeral .= $symbols[$i];\n            }\n        }\n\n        return $romanNumeral;\n    }\n}',
        views: "262",
        upvotes: "1",
        author_id: "881",
        problem_id: 13,
      },
      {
        title: "Simple Solution",
        body: 'public static String intToRoman(int num) {\n    String M[] = {"", "M", "MM", "MMM"};\n    String C[] = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};\n    String X[] = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};\n    String I[] = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};\n    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];\n}',
        views: "190464",
        upvotes: "2.6K",
        author_id: "211",
        problem_id: 13,
      },
      {
        title: "Simple Code in Java",
        body: 'Complexity\n\n\nTime complexity:\nO(N^2)\n\n\nSpace complexity:\nO(N)\n\n\nCode\nclass Solution {\n    public String intToRoman(int num) {\n        int intValue[] = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\n        String code[] = {"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};\n\n        StringBuilder sb = new StringBuilder();\n        for(int i=0;i<intValue.length;i++) {\n            while(num>=intValue[i]) {\n                sb.append(code[i]);\n                num=num-intValue[i];\n            }\n        }\n        return sb.toString();\n    }\n}',
        views: "1107",
        upvotes: "2",
        author_id: "104",
        problem_id: 13,
      },
    ],
  },
  {
    title: "13. Roman to Integer",
    description:
      "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\nFor example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\n\n\tI can be placed before V (5) and X (10) to make 4 and 9. \n\tX can be placed before L (50) and C (100) to make 40 and 90. \n\tC can be placed before D (500) and M (1000) to make 400 and 900.\n\n\nGiven a roman numeral, convert it to an integer.\n\n \nExample 1:\n\nInput: s = \"III\"\nOutput: 3\nExplanation: III = 3.\n\n\nExample 2:\n\nInput: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\n\n\nExample 3:\n\nInput: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 15\n\ts contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\n\tIt is guaranteed that s is a valid roman numeral in the range [1, 3999].\n\n",
    difficulty: "Easy",
    acceptance: "67.83",
    frequency: "85.42",
    topics: [
      [
        "Sorting",
        "Queue",
        "Enumeration",
        "Minimum Spanning Tree",
        "Rejection Sampling",
        "Hash Table",
        "Strongly Connected Component",
        "Binary Indexed Tree",
        "Graph",
        "Collapse",
      ],
    ],
    languages: [
      [
        "Kotlin",
        "Dart",
        "C++",
        "Racket",
        "Erlang",
        "JavaScript",
        "Python3",
        "Scala",
        "PHP",
        "C",
      ],
    ],
    comments: [
      {
        author_id: "38",
        problem_id: 14,
        body: "Это моя новая любимая задача! Хочу попробовать еще раз!",
        comment_reply_id: null,
      },
      {
        author_id: "425",
        problem_id: 14,
        body: "Не могу поверить, что решил это за одну попытку! Сейчас немного в шоке.",
        comment_reply_id: null,
      },
      {
        author_id: "341",
        problem_id: 14,
        body: "Сложно поверить, что я только что решил это! Спасибо всем за поддержку.",
        comment_reply_id: null,
      },
      {
        author_id: "219",
        problem_id: 14,
        body: "Не могу поверить, что я решил это без помощи Google!",
        comment_reply_id: null,
      },
      {
        author_id: "701",
        problem_id: 14,
        body: "Всегда думал, что эта задача невозможна. Но вот я, сделал это!",
        comment_reply_id: null,
      },
      {
        author_id: "295",
        problem_id: 14,
        body: "Подсказки были такими полезными! Они действительно помогли мне решить эту задачу.",
        comment_reply_id: null,
      },
      {
        author_id: "767",
        problem_id: 14,
        body: "Это было круто! Какая следующая задача?",
        comment_reply_id: null,
      },
      {
        author_id: "792",
        problem_id: 14,
        body: "Не могу поверить, что я решил это без помощи Google!",
        comment_reply_id: null,
      },
      {
        author_id: "774",
        problem_id: 14,
        body: "Идея для этого решения пришла ко мне во сне! Удивительно, как мозг работает иногда.",
        comment_reply_id: null,
      },
      {
        author_id: "550",
        problem_id: 14,
        body: "Эта задача мне не давала покоя, но теперь я горд собой!",
        comment_reply_id: null,
      },
    ],
    solutions: [],
  },
  {
    title: "14. Longest Common Prefix",
    description:
      'Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string "".\n\n \nExample 1:\n\nInput: strs = ["flower","flow","flight"]\nOutput: "fl"\n\n\nExample 2:\n\nInput: strs = ["dog","racecar","car"]\nOutput: ""\nExplanation: There is no common prefix among the input strings.\n\n\n \nConstraints:\n\n\n\t1 <= strs.length <= 200\n\t0 <= strs[i].length <= 200\n\tstrs[i] consists of only lowercase English letters.\n\n',
    difficulty: "Easy",
    acceptance: "66.83",
    frequency: "29.20",
    topics: [
      [
        "Bucket Sort",
        "Combinatorics",
        "Greedy",
        "Radix Sort",
        "Biconnected Component",
        "Shell",
        "Prefix Sum",
        "Eulerian Circuit",
        "Bitmask",
        "Number Theory",
      ],
    ],
    languages: [
      [
        "C",
        "Python3",
        "Java",
        "Ruby",
        "JavaScript",
        "Kotlin",
        "Dart",
        "Go",
        "Swift",
        "TypeScript",
      ],
    ],
    comments: [
      {
        author_id: "710",
        problem_id: 15,
        body: "Чувствую, что становлюсь лучше с каждой решенной задачей!",
        comment_reply_id: null,
      },
      {
        author_id: "692",
        problem_id: 15,
        body: "Кто бы мог подумать, что решение окажется настолько простым!",
        comment_reply_id: null,
      },
      {
        author_id: "6",
        problem_id: 15,
        body: "Это было круто! Какая следующая задача?",
        comment_reply_id: null,
      },
      {
        author_id: "278",
        problem_id: 15,
        body: "У кого-нибудь есть идеи, как можно оптимизировать мое решение? Пока я не совсем доволен своим подходом.",
        comment_reply_id: null,
      },
      {
        author_id: "488",
        problem_id: 15,
        body: "Как приятно видеть, что мое решение работает!",
        comment_reply_id: null,
      },
      {
        author_id: "887",
        problem_id: 15,
        body: "Не могу поверить, что решил это за одну попытку! Сейчас немного в шоке.",
        comment_reply_id: null,
      },
      {
        author_id: "154",
        problem_id: 15,
        body: "Это был настоящий вызов для моего ума, но я его преодолел!",
        comment_reply_id: null,
      },
      {
        author_id: "947",
        problem_id: 15,
        body: "Чувствую, что становлюсь лучше с каждой решенной задачей!",
        comment_reply_id: null,
      },
      {
        author_id: "828",
        problem_id: 15,
        body: "Кто-нибудь сталкивался с такой ошибкой раньше? Не могу понять, в чем проблема.",
        comment_reply_id: null,
      },
      {
        author_id: "513",
        problem_id: 15,
        body: "Чувствую себя чемпионом после этой задачи!",
        comment_reply_id: null,
      },
    ],
    solutions: [],
  },
  {
    title: "15. 3Sum",
    description:
      "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.\n\n \nExample 1:\n\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n\n\nExample 2:\n\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\n\n\nExample 3:\n\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.\n\n\n \nConstraints:\n\n\n\t3 <= nums.length <= 3000\n\t-105 <= nums[i] <= 105\n\n",
    difficulty: "Medium",
    acceptance: "72.29",
    frequency: "112.41",
    topics: [
      [
        "Combinatorics",
        "Doubly-Linked List",
        "Monotonic Queue",
        "Radix Sort",
        "Bit Manipulation",
        "Bitmask",
        "Design",
        "String Matching",
        "Memoization",
        "Hash Table",
      ],
    ],
    languages: [
      [
        "Rust",
        "TypeScript",
        "Swift",
        "JavaScript",
        "Scala",
        "Python",
        "Kotlin",
        "Python3",
        "C++",
        "C",
      ],
    ],
    comments: [
      {
        author_id: "864",
        problem_id: 16,
        body: "Было трудно, но я нашел путь к решению этой задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "240",
        problem_id: 16,
        body: "Чувствую себя настоящим гений после того, как решил эту задачу!",
        comment_reply_id: null,
      },
      {
        author_id: "523",
        problem_id: 16,
        body: "Иногда лучшее решение приходит в голову после нескольких неудачных попыток.",
        comment_reply_id: null,
      },
      {
        author_id: "515",
        problem_id: 16,
        body: "Чувствую себя настоящим гений после того, как решил эту задачу!",
        comment_reply_id: null,
      },
      {
        author_id: "611",
        problem_id: 16,
        body: "Это моя новая любимая задача! Хочу попробовать еще раз!",
        comment_reply_id: null,
      },
      {
        author_id: "738",
        problem_id: 16,
        body: "Чувствую, что становлюсь лучше с каждой решенной задачей!",
        comment_reply_id: null,
      },
      {
        author_id: "364",
        problem_id: 16,
        body: "Сложно даже представить, сколько попыток ушло на решение этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "784",
        problem_id: 16,
        body: "Это было как головоломка, но я нашел свой путь к решению!",
        comment_reply_id: null,
      },
      {
        author_id: "435",
        problem_id: 16,
        body: "Это был настоящий вызов для моего ума, но я его преодолел!",
        comment_reply_id: null,
      },
      {
        author_id: "379",
        problem_id: 16,
        body: "Наконец-то, я разобрался с этой задачей! Спасибо за все подсказки.",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "【Video】Two Pointer Solution",
        body: "Intuition\nUsing two pointers\n\nSolution Video\n\n■ Timeline\n0:04 Understanding a strategy to solve 3Sum\n2:05 Demonstrate how to solve 3Sum\n7:01 Coding\n9:49 Time Complexity and Space Complexity\n⭐️⭐️ Don't forget to subscribe to my channel! ⭐️⭐️\n■ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\nSubscribers: 4,509\nThank you for your support!\n\nApproach\nI think it's tough to manage 3 indices at the same time, so my strategy is to fix i.\nInput: nums = [-1,0,1,2,-1,-4]\n[-1,0,1,2,-1,-4]\n  i\nWe fix i at index 0 at first. Then we have other two indices j and k. j starts from i + 1 and k starts from the last index.\n[-1,0,1,2,-1,-4]\n  i j         k\nBasically, we calculate a total of 3 numbers, then if the total is 0, that is one of target triplets.\nBut there are many cases where the total is not 0. In that case we should move j or k to the next, because we fix i at index 0 at first. All calculations in a loop this time, we must use i number.\n\nQuestion\nHow can we decide and move j or k to the next index?\n\nMy strategy is to sort input array, so that we can decide which index we should move.\n[-1,0,1,2,-1,-4]\n↓\n[-4,-1,-1,0,1,2]\n  i  j        k\n\n⭐️ Points\n\nWhy do we need to sort input array?\n\nThat's because if the total is greater than 0, we want small total next time. In that case, we should move k to the next because input array is sorted, we are sure that if k move to left index, we will get small total compared with the current total.\nOn the other hand, if the total is smaller than 0, we want big total next time. In that case we should move j to the right index to get big total.\n\nLet's see one by one.\n[-4,-1,-1,0,1,2]\n  i  j        k\n\nnums[i] + nums[j] + nums[k] = -3\nWe should move j to the next.\nI'll speed up\n[-4,-1,-1,0,1,2]\n  i     j     k\n\nnums[i] + nums[j] + nums[k] = -3\n\nj moves to the next\n\n[-4,-1,-1,0,1,2]\n  i       j   k\n\nnums[i] + nums[j] + nums[k] = -2\n\nj moves to the next\n\n[-4,-1,-1,0,1,2]\n  i         j k\n\nnums[i] + nums[j] + nums[k] = -1\n\nj moves to the next\n\n[-4,-1,-1,0,1,2]\n  i           k\n              j\nNow j and k are the same index, so we stop iteration. For this question, we have to find all triplets.\nNext, we fix i at index 1. j starts from i + 1 and k starts from the last index.\n[-4,-1,-1,0,1,2]\n     i  j     k\nWe do the same thing.\n[-4,-1,-1,0,1,2]\n     i  j     k\n\nnums[i] + nums[j] + nums[k] = 0\nWe found total 0 and 3 indices are different, so current combination meets condition the description says. That is one of answers.\nres = [[-1,-1,2]]\nWhen we found the target triplet, there are several ways to move pointers. I think easiest way is to move j once.\nBut there is problem. What if the next number is the same as current number like this.\n[-4,-1,-1,-1,1,2]\n     i    j   k\n\nI changed 0 to -1 at index 3.\nIn this case, we found [-1,-1,2] again. It's the target triplet but the description says \"No duplicate\".\nTo avoid this, when we found one of the target triplets, we move j once but we check the number after we move j. If the number is the same previous number, we continue to move j until we find differnt number, so that we can avoid duplicate combination.\n\n⭐️ Points\nMove j until we find different number when we find one of the target triplets.\n\nLet's go back to main topic.\n[-4,-1,-1,0,1,2]\n     i    j   k\n\nnums[i] + nums[j] + nums[k] = 1\nNow the total is greater than 0. We should move k to the right index to get small total.\n[-4,-1,-1,0,1,2]\n     i    j k\n\nnums[i] + nums[j] + nums[k] = 0\nWe found a new triplets that meets the conditions.\nres = [[-1,-1,2], [-1,0,1]]\nThis example is example 1 in the description. It says those two combinations are return value, so I stop explanation.\nAfter that, we do the same thing. j and k are the same index, so we fix i at index 2. j starts from i + 1 and k starts from the last index.\n[-4,-1,-1,0,1,2]\n        i j   k\nIn the end,\nreturn [[-1,-1,2], [-1,0,1]]\nEasy!😄\nLet's see solution codes and step by step algorithm.\n\nThis question is similar to Two Sum Ⅱ question.\n\n\nComplexity\n\nTime complexity: O(n2)O(n^2)O(n2)\n\n\n\nSpace complexity: O(n)O(n)O(n)\nDepends on language you use. In python, sorting algorithm use Timsort which uses O(n)O(n)O(n) space.\n\nPythonJavaScriptJavaC++class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        nums.sort()\n\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            \n            j = i + 1\n            k = len(nums) - 1\n\n            while j < k:\n                total = nums[i] + nums[j] + nums[k]\n\n                if total > 0:\n                    k -= 1\n                elif total < 0:\n                    j += 1\n                else:\n                    res.append([nums[i], nums[j], nums[k]])\n                    j += 1\n\n                    while nums[j] == nums[j-1] and j < k:\n                        j += 1\n        \n        return res\nStep by Step Algorithm\n\n\nInitialize Result List:\n\nCreate an empty list res to store the triplets whose sum is zero.\nres = []\n\n\n\n\nSort the Input Array:\n\nSort the input array nums in non-decreasing order. Sorting the array helps in avoiding duplicate triplets.\nnums.sort()\n\n\n\n\nIterate Through the Array:\n\nIterate through each element in the sorted array nums.\nfor i in range(len(nums)):\n\n\n\n\nSkip Duplicate Elements:\n\nCheck if the current element is a duplicate of the previous element and skip it if it is.\nif i > 0 and nums[i] == nums[i-1]:\n    continue\n\n\n\n\nInitialize Pointers:\n\nInitialize two pointers j and k to point to the elements next to the current element i and at the end of the array, respectively.\nj = i + 1\nk = len(nums) - 1\n\n\n\n\nTwo-Pointer Approach:\n\nUse a two-pointer approach with pointers j and k to find triplets whose sum equals zero.\nwhile j < k:\n\n\n\n\nCalculate Total:\n\nCalculate the total sum of the current triplet.\ntotal = nums[i] + nums[j] + nums[k]\n\n\n\n\nAdjust Pointers Based on Total:\n\nIf the total sum is greater than zero, decrement the k pointer to decrease the total sum.\nif total > 0:\n    k -= 1\n\nIf the total sum is less than zero, increment the j pointer to increase the total sum.\nelif total < 0:\n    j += 1\n\nIf the total sum equals zero, add the triplet [nums[i], nums[j], nums[k]] to the result list res.\nelse:\n    res.append([nums[i], nums[j], nums[k]])\n\n\n\n\nHandle Duplicate Triplets:\n\nIncrement the j pointer to skip any duplicate elements.\nj += 1\nwhile nums[j] == nums[j-1] and j < k:\n    j += 1\n\n\n\n\nReturn Result:\n\n\n\nReturn the list res containing all the unique triplets whose sum is zero.\nreturn res\n\n\nThis algorithm efficiently finds all unique triplets in the given array nums whose sum equals zero using a two-pointer approach. It avoids duplicate triplets by skipping duplicate elements during traversal.\n\nThank you for reading my post.\n⭐️ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n⭐️ Twitter\nhttps://twitter.com/CodingNinjaAZ\nHow to Use LeetCode Effectively - 3 steps to improve problem-solving techniques from beginner\n",
        views: "9961",
        upvotes: "41",
        author_id: "894",
        problem_id: 16,
      },
      {
        title:
          "✅98.21%🔥HashMap & Two Pointer | C++ , Java, Python , Javascript",
        body: "✅98.21%🔥HashMap & Two Pointer 🔥 🔥\nRead article and Contain Codes c++, java , Python ,Javascript : https://bit.ly/Three-sum\n\n\nTwo Pointer\nCpp\nJava\nJavaScript\nPython\n\n\nHashmap\nCpp\nJava\nJavaScript\nPython\n\n\nFirst, we can create a HashMap to store the frequency of each number in the array. Then, we can iterate through the array and for each element, we can check if there exists two other numbers in the array that add up to the target sum minus the current element. We can do this by using two pointers - one starting from the next index of the current element and another starting from the last index of the array.\nBy incrementing or decrementing these pointers based on whether their sum with the current element is greater or smaller than the target sum, we can find all possible triplets that satisfy the condition. We also need to make sure that we don't consider duplicate triplets, so we can use additional conditions to skip over duplicates.\nOverall, this approach has a time complexity of O(N^2): we are using one for loops to get values of a, and for every value of a, we find the pair b,c (such that a+b+c=0) using two pointer approach that takes O(N) time. so total time complexity is of the order of O(N^2).. However, by using HashMaps and Two Pointers, we can efficiently solve the three sum problem and find all unique triplets that add up to a given target sum.\n",
        views: "1606",
        upvotes: "8",
        author_id: "146",
        problem_id: 16,
      },
      {
        title:
          "C++ - Easiest Beginner friendly Sol || Set + Two Pointer Approach || O(n^2 logn) time and O(n) space",
        body: "Intuition of this Problem:\nSet is used to prevent duplicate triplets and parallely we will use two pointer approach to maintain J and k.\n\nNOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.\nApproach for this Problem:\n\nSort the input array\nInitialize a set to store the unique triplets and an output vector to store the final result\nIterate through the array with a variable i, starting from index 0.\nInitialize two pointers, j and k, with j starting at i+1 and k starting at the end of the array.\nIn the while loop, check if the sum of nums[i], nums[j], and nums[k] is equal to 0. If it is, insert the triplet into the set and increment j and decrement k to move the pointers.\nIf the sum is less than 0, increment j. If the sum is greater than 0, decrement k.\nAfter the while loop, iterate through the set and add each triplet to the output vector.\nReturn the output vector\n\n\nCode:\nC++C++JavaPython//Optimized Approach - O(n^2 logn + nlogn) - o(n^2 logn) time and O(n) space\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int target = 0;\n        sort(nums.begin(), nums.end());\n        set<vector<int>> s;\n        vector<vector<int>> output;\n        for (int i = 0; i < nums.size(); i++){\n            int j = i + 1;\n            int k = nums.size() - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == target) {\n                    s.insert({nums[i], nums[j], nums[k]});\n                    j++;\n                    k--;\n                } else if (sum < target) {\n                    j++;\n                } else {\n                    k--;\n                }\n            }\n        }\n        for(auto triplets : s)\n            output.push_back(triplets);\n        return output;\n    }\n};\nTime Complexity and Space Complexity:\n\nTime complexity: O(n^2 logn) // where n is the size of array\nSorting takes O(nlogn) time and loop takes O(n^2) time, So the overall time complexity is O(nlogn + n^2 logn) - O(n^2 logn)\n\n\n\nSpace complexity: O(n) // for taking hashset.\n\n",
        views: "224256",
        upvotes: "704",
        author_id: "778",
        problem_id: 16,
      },
      {
        title: "easy approach in C++",
        body: "Intuition\nusing two sum approach by using mathematical equations\nApproach\n1.You need to sort the vector.\n2.you need to take each and every element from the vector and pass it to the two sum function so that it verifies the sum of three numbers will  be equal to zero\n3.if two sum value is equal to the target value then you need to push those elements into new vector which need to be created.\n4.return the new vector\nComplexity\n\n\nTime complexity:\nO(n)\n\n\nSpace complexity:\nO(n)\n\n\nCode\nclass Solution {\npublic:\n    vector<vector<int>>result;\n    void twoSum(vector<int>&nums,int target,int i,int j){\n        while(i<j){\n            if(nums[i]+nums[j]>target){\n                j--;\n            }\n            else if(nums[i]+nums[j]<target){\n                i++;\n            }else{\n                while(i<j && nums[i]==nums[i+1]) i++;\n                while(i<j && nums[j]==nums[j-1]) j--;\n                result.push_back({-target,nums[i],nums[j]});\n                i++;\n                j--;\n            }\n        }\n    }\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int n  =nums.size();\n        if(n<3) return{};\n        sort(nums.begin(),nums.end());\n        for(int i=0;i<=n-3;i++){\n            if(i>0 && nums[i]==nums[i-1]){\n                continue;\n            }\n            int n1 = nums[i];\n            int target  = -n1;\n            twoSum(nums,target,i+1,n-1);\n        }\n        return result;\n    }\n};",
        views: "664",
        upvotes: "1",
        author_id: "205",
        problem_id: 16,
      },
    ],
  },
  {
    title: "16. 3Sum Closest",
    description:
      "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\n\nReturn the sum of the three integers.\n\nYou may assume that each input would have exactly one solution.\n\n \nExample 1:\n\nInput: nums = [-1,2,1,-4], target = 1\nOutput: 2\nExplanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n\n\nExample 2:\n\nInput: nums = [0,0,0], target = 1\nOutput: 0\nExplanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n\n\n \nConstraints:\n\n\n\t3 <= nums.length <= 500\n\t-1000 <= nums[i] <= 1000\n\t-104 <= target <= 104\n\n",
    difficulty: "Medium",
    acceptance: "51.48",
    frequency: "33.45",
    topics: [
      [
        "Math",
        "Bit Manipulation",
        "Quickselect",
        "Geometry",
        "Doubly-Linked List",
        "Suffix Array",
        "Prefix Sum",
        "Topological Sort",
        "Backtracking",
        "Divide and Conquer",
      ],
    ],
    languages: [
      [
        "PHP",
        "C",
        "Dart",
        "Kotlin",
        "Python3",
        "Go",
        "Ruby",
        "C++",
        "JavaScript",
        "Rust",
      ],
    ],
    comments: [
      {
        author_id: "894",
        problem_id: 17,
        body: "Эта задача показала мне, насколько важно быть терпеливым в программировании.",
        comment_reply_id: null,
      },
      {
        author_id: "541",
        problem_id: 17,
        body: "Как приятно видеть, что мое решение работает!",
        comment_reply_id: null,
      },
      {
        author_id: "124",
        problem_id: 17,
        body: "Какие интересные подходы у других людей к этой задаче",
        comment_reply_id: null,
      },
      {
        author_id: "320",
        problem_id: 17,
        body: "Как приятно видеть, что мое решение работает!",
        comment_reply_id: null,
      },
      {
        author_id: "620",
        problem_id: 17,
        body: "Иногда простые решения лучше всех! Не всегда нужно усложнять.",
        comment_reply_id: null,
      },
      {
        author_id: "397",
        problem_id: 17,
        body: "Иногда лучшее решение приходит в голову после нескольких неудачных попыток.",
        comment_reply_id: null,
      },
      {
        author_id: "808",
        problem_id: 17,
        body: "Чувствую себя настоящим гений после того, как решил эту задачу!",
        comment_reply_id: null,
      },
      {
        author_id: "265",
        problem_id: 17,
        body: "Чувствую, что становлюсь лучше с каждой решенной задачей!",
        comment_reply_id: null,
      },
      {
        author_id: "579",
        problem_id: 17,
        body: "Как я мог пропустить этот трюк? Благодарю за подсказку!",
        comment_reply_id: null,
      },
      {
        author_id: "23",
        problem_id: 17,
        body: "Эта задача показала мне, насколько важно быть терпеливым в программировании.",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "Easy to Understand :) || Beats 97% || Happy Coding",
        body: "Intuition\nPlease solve Q.15 before solving these question :)\nRead the question twice even thrice and jot down the points !!\nNow focus on last question(15) and build the logic !!\nIf uh don't understand now look into my solution !!\nApproach\nA quite upgrade version frm previous question !!\nComplexity\n\n\nTime complexity:\nO(N)^2\n\n\nSpace complexity:\nO(1)\n\n\nCode\nclass Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        \n        int n = nums.length;\n        int closest = 0;\n        // int min = Integer.MAX_VALUE;\n        int max = Integer.MAX_VALUE;\n        Arrays.sort(nums);\n        //target += 1;\n\n\n        for(int i=0; i<n-2; i++){\n            int j=i+1;\n            int k  = n-1;\n            // min = Math.min(min,max);\n\n            while(j<k){\n                int sum = nums[i] + nums[j] + nums[k];\n\n                if(sum == target)\n                    return sum;\n\n                else if(sum < target)\n                    j++;\n\n                else\n                    k--;\n                    int diff = Math.abs(sum - target);\n                    if(diff < max){\n                        max = diff;\n                        closest = sum;\n                    }\n                }\n            }   \n            \n        return closest;\n    }\n}\n\n",
        views: "159",
        upvotes: "1",
        author_id: "969",
        problem_id: 17,
      },
      {
        title: "C++ easy to understand, simple solution",
        body: "class Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n        int front;\n        int sum=nums[0]+nums[1]+nums[2],sum1=0;\n        for(int i=0;i<nums.size();i++){\n            front=i+1;\n            int back=nums.size()-1;\n            while(front<back){\n            sum1=nums[front]+nums[back]+nums[i];\n            if(abs(sum1-target)<=abs(sum-target)){\n                sum=sum1;\n            }\n            if(sum1>target) \n                back--;\n            else if(sum1<target) \n               front++;\n            else return sum1;\n            }\n        }\n        return sum;\n    }\n};",
        views: "3210",
        upvotes: "3",
        author_id: "74",
        problem_id: 17,
      },
      {
        title: "C++ solution | O(N^2) TC | O(1) SC |  Same as 3 Sum",
        body: "class Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n        int n = nums.size(),ans = -1, diff = INT_MAX;\n        \n        for(int i=0;i<n;i++){\n            int s = i+1,e = n-1;\n            \n            while(s<e){\n                int sum = nums[i]+nums[s]+nums[e];\n                if(abs(target-sum)<diff){\n                    ans = sum;\n                    diff = abs(target-sum);\n                }\n                if(sum<=target)s++;\n                else e--;\n            }\n        }\n        \n        return ans;\n    }\n};",
        views: "945",
        upvotes: "1",
        author_id: "270",
        problem_id: 17,
      },
      {
        title: "Easy and simple code",
        body: "Intuition\n\nApproach\n\nComplexity\n\nTime complexity:\n\n\n\nSpace complexity:\n\n\nCode\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n        int front;\n        int sum=nums[0]+nums[1]+nums[2],sum1=0;\n        for(int i=0;i<nums.size();i++){\n            front=i+1;\n            int back=nums.size()-1;\n            while(front<back){\n            sum1=nums[front]+nums[back]+nums[i];\n            if(abs(sum1-target)<=abs(sum-target)){\n                sum=sum1;\n            }\n            if(sum1>target) \n                back--;\n            else if(sum1<target) \n               front++;\n            else return sum1;\n            }\n        }\n        return sum;\n    }\n};",
        views: "1591",
        upvotes: "4",
        author_id: "45",
        problem_id: 17,
      },
    ],
  },
  {
    title: "17. Letter Combinations of a Phone Number",
    description:
      'Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n \nExample 1:\n\nInput: digits = "23"\nOutput: ["ad","ae","af","bd","be","bf","cd","ce","cf"]\n\n\nExample 2:\n\nInput: digits = ""\nOutput: []\n\n\nExample 3:\n\nInput: digits = "2"\nOutput: ["a","b","c"]\n\n\n \nConstraints:\n\n\n\t0 <= digits.length <= 4\n\tdigits[i] is a digit in the range [\'2\', \'9\'].\n\n',
    difficulty: "Medium",
    acceptance: "41.31",
    frequency: "7.93",
    topics: [
      [
        "Minimum Spanning Tree",
        "Eulerian Circuit",
        "Shell",
        "Simulation",
        "Sliding Window",
        "Recursion",
        "Shortest Path",
        "Hash Function",
        "Quickselect",
        "Bucket Sort",
      ],
    ],
    languages: [
      [
        "Scala",
        "Elixir",
        "C#",
        "Erlang",
        "PHP",
        "Dart",
        "Rust",
        "Swift",
        "Racket",
        "Python",
      ],
    ],
    comments: [
      {
        author_id: "394",
        problem_id: 18,
        body: "Эта задача мне не давала покоя, но теперь я горд собой!",
        comment_reply_id: null,
      },
      {
        author_id: "966",
        problem_id: 18,
        body: "Кто-нибудь еще решал эту задачу? Хотелось бы услышать ваши мысли!",
        comment_reply_id: null,
      },
      {
        author_id: "988",
        problem_id: 18,
        body: "Чувствую себя настоящим гений после того, как решил эту задачу!",
        comment_reply_id: null,
      },
      {
        author_id: "251",
        problem_id: 18,
        body: "Мой мозг сейчас в кипении от этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "67",
        problem_id: 18,
        body: "Не могу поверить, что я решил это без помощи Google!",
        comment_reply_id: null,
      },
      {
        author_id: "805",
        problem_id: 18,
        body: "Я не знал, что это возможно, пока не попробовал! Это было удивительно!",
        comment_reply_id: null,
      },
      {
        author_id: "658",
        problem_id: 18,
        body: "Эта задача преподнесла мне неожиданный поворот! Интересно, как многие это заметили.",
        comment_reply_id: null,
      },
      {
        author_id: "19",
        problem_id: 18,
        body: "Наконец-то, я разобрался с этой задачей! Спасибо за все подсказки.",
        comment_reply_id: null,
      },
      {
        author_id: "687",
        problem_id: 18,
        body: "Я так рад, что решил эту задачу! Это действительно научило меня чему-то новому.",
        comment_reply_id: null,
      },
      {
        author_id: "475",
        problem_id: 18,
        body: "Сколько времени я потратил на решение этой задачи? Не считаясь!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "【Video】Simple Solution",
        body: "Intuition\nUsing backtracking to create all possible combinations\n\nSolution Video\n\nPlease subscribe to my channel from here.\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n\nApproach\nThis is based on Python solution. Other might be differnt a bit.\n\n\nInitialize an empty list res to store the generated combinations.\n\n\nCheck if the digits string is empty. If it is, return an empty list since there are no digits to process.\n\n\nCreate a dictionary digit_to_letters that maps each digit from '2' to '9' to the corresponding letters on a phone keypad.\n\n\nDefine a recursive function backtrack(idx, comb) that takes two parameters:\n\nidx: The current index of the digit being processed in the digits string.\ncomb: The current combination being formed by appending letters.\n\n\n\nInside the backtrack function:\n\nCheck if idx is equal to the length of the digits string. If it is, it means a valid combination has been formed, so append the current comb to the res list.\nIf not, iterate through each letter corresponding to the digit at digits[idx] using the digit_to_letters dictionary.\nFor each letter, recursively call backtrack with idx + 1 to process the next digit and comb + letter to add the current letter to the combination.\n\n\n\nInitialize the res list.\n\n\nStart the initial call to backtrack with idx set to 0 and an empty string as comb. This will start the process of generating combinations.\n\n\nAfter the recursive calls have been made, return the res list containing all the generated combinations.\n\n\nThe algorithm works by iteratively exploring all possible combinations of letters that can be formed from the given input digits. It uses a recursive approach to generate combinations, building them one letter at a time. The base case for the recursion is when all digits have been processed, at which point a combination is complete and added to the res list. The backtracking nature of the algorithm ensures that all possible combinations are explored.\nComplexity\n\n\nTime complexity: O(3^n) or O(4^n)\nn is length of input string. Each digit has 3 or 4 letters. For example, if you get \"23\"(n) as input string, we will create 9 combinations which is O(3^2) = 9\n\n\nSpace complexity: O(n)\nn is length of input string. This is for recursive call stack.\n\n\nPythonJavaScriptJavaC++class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n        \n        digit_to_letters = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz',\n        }\n\n        def backtrack(idx, comb):\n            if idx == len(digits):\n                res.append(comb[:])\n                return\n            \n            for letter in digit_to_letters[digits[idx]]:\n                backtrack(idx + 1, comb + letter)\n\n        res = []\n        backtrack(0, \"\")\n\n        return res\n\nThank you for reading my post. Please upvote it and don't forget to subscribe to my channel!\n⭐️ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n⭐️ Twitter\nhttps://twitter.com/CodingNinjaAZ\n⭐️ Related question #15 - 3Sum\nvideo\n",
        views: "1201",
        upvotes: "13",
        author_id: "213",
        problem_id: 18,
      },
      {
        title: "[Java] Easy 100% backtracking solution",
        body: 'class Solution {\n    public List<String> letterCombinations(final String digits) {\n        final Map<String, String> mapping = new HashMap<>();\n\n        mapping.put("2", "abc");\n        mapping.put("3", "def");\n        mapping.put("4", "ghi");\n        mapping.put("5", "jkl");\n        mapping.put("6", "mno");\n        mapping.put("7", "pqrs");\n        mapping.put("8", "tuv");\n        mapping.put("9", "wxyz");\n\n        final List<String> result = new ArrayList<>();\n\n        if(digits.length() > 0)\n            backtrack(result, new StringBuilder(), mapping, digits, 0);\n\n        return result;\n    }\n\n    private void backtrack(final List<String> result, final StringBuilder sb, final Map<String, String> mapping, final String digits, final int idx) {\n        if(idx >= digits.length()) {\n            result.add(sb.toString());\n            return;\n        }\n\n        final String values = mapping.get(String.valueOf(digits.charAt(idx)));\n\n        for(int i = 0; i < values.length(); ++i) {\n            sb.append(values.charAt(i));\n            backtrack(result, sb, mapping, digits, idx + 1);\n            sb.setLength(sb.length() - 1);\n        }\n    }\n}',
        views: "257",
        upvotes: "1",
        author_id: "895",
        problem_id: 18,
      },
      {
        title: "Backtracking || Map || Easy to Understand",
        body: 'class Solution {\n    List<String> ans;\n    \n    public void letterUtil(String str, Map<Character,String> map,\n                          String cur, int index) {\n        if(index > str.length()) return;\n        \n        if(index == str.length()) {\n            if(cur != "")\n                ans.add(cur);\n            \n            return;\n        }\n        \n        String s = map.get(str.charAt(index));\n        \n        for(int i = 0 ; i < s.length() ; i++) {\n            letterUtil(str,map,cur+s.charAt(i),index+1);\n        }\n    }\n    \n    public List<String> letterCombinations(String str) {\n        Map<Character, String> map = new HashMap<>();\n        \n        ans = new ArrayList<>();\n        \n        map.put(\'2\',"abc");\n        map.put(\'3\',"def");\n        map.put(\'4\',"ghi");\n        map.put(\'5\',"jkl");\n        map.put(\'6\',"mno");\n        map.put(\'7\',"pqrs");\n        map.put(\'8\',"tuv");\n        map.put(\'9\',"wxyz");\n        \n        \n        \n        letterUtil(str,map,"",0);\n        return ans;\n    }\n}',
        views: "353",
        upvotes: "4",
        author_id: "863",
        problem_id: 18,
      },
      {
        title:
          "📞 100% Backtracking & Iterative [VIDEO]  Letter Combinations of a Phone Number",
        body: "Intuition\nGiven a string containing digits from 2-9 inclusive, we need to return all possible letter combinations that the number could represent, just like on a telephone's buttons. To accomplish this, we present two different approaches:\n\n\nBacktracking Approach: This approach leverages recursion to explore all possible combinations. We create a recursive function that takes the current combination and the next digits to explore. For each digit, we iterate through its corresponding letters and recursively explore the remaining digits. We append the combination when no more digits are left to explore.\n\n\nIterative Approach: This approach builds the combinations iteratively without using recursion. We start with an empty combination and iteratively add letters for each digit in the input string. For each existing combination, we append each corresponding letter for the current digit, building new combinations.\n\n\nDifferences:\n\nThe backtracking approach relies on recursion to explore all possible combinations, whereas the iterative approach builds combinations step by step using loops.\nBoth approaches have similar time complexity, but the iterative approach might save some function call overhead, leading to more efficient execution in some cases.\n\nDetailed explanations of both approaches, along with their corresponding code, are provided below. By presenting both methods, we offer a comprehensive view of how to tackle this problem, allowing for flexibility and understanding of different programming paradigms.\n\nApproach - Backtracking\n\n\nInitialize a Mapping: Create a dictionary that maps each digit from 2 to 9 to their corresponding letters on a telephone's buttons. For example, the digit '2' maps to \"abc,\" '3' maps to \"def,\" and so on.\n\n\nBase Case: Check if the input string digits is empty. If it is, return an empty list, as there are no combinations to generate.\n\n\nRecursive Backtracking:\n\nDefine Recursive Function: Create a recursive function, backtrack, that will be used to explore all possible combinations. It takes two parameters: combination, which holds the current combination of letters, and next_digits, which holds the remaining digits to be explored.\nTermination Condition: If next_digits is empty, it means that all digits have been processed, so append the current combination to the result.\nExploration: If there are more digits to explore, take the first digit from next_digits and iterate over its corresponding letters in the mapping. For each letter, concatenate it to the current combination and recursively call the backtrack function with the new combination and the remaining digits.\nExample: If the input is \"23\", the first recursive call explores all combinations starting with 'a', 'b', and 'c' (from '2'), and the next level of recursive calls explores combinations starting with 'd', 'e', 'f' (from '3'), building combinations like \"ad,\" \"ae,\" \"af,\" \"bd,\" \"be,\" etc.\n\n\n\nResult: Once the recursive exploration is complete, return the collected combinations as the final result. By using recursion, we ensure that all possible combinations are explored, and the result includes all valid letter combinations that the input digits can represent.\n\n\nComplexity\n\nTime complexity: ( O(4^n) ), where ( n ) is the length of the input string. In the worst case, each digit can represent 4 letters, so there will be 4 recursive calls for each digit.\nSpace complexity: ( O(n) ), where ( n ) is the length of the input string. This accounts for the recursion stack space.\n\nCode - Backtracking\nPythonC++JavaJavaSxriptC#GoRustclass Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n\n        phone_map = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n\n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                output.append(combination)\n            else:\n                for letter in phone_map[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n\n        output = []\n        backtrack(\"\", digits)\n        return output\nThis code can handle any input string containing digits from 2 to 9 and will return the possible letter combinations in any order. The function backtrack is used to handle the recursive exploration of combinations, and phone_map contains the mapping between digits and letters.\nPerformance - Backtracking\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLanguageRuntime (ms)Beats (%)Memory (MB)C++0100.006.4Go0100.002.0Rust182.502.1Java550.3041.6Swift282.3814.0Python33496.9116.3TypeScript4996.3644.3JavaScript5855.1742.2Ruby5897.98211.1C#13689.1443.9\nVideo Iterative\n\nApproach - Iterative\n\nInitialize a Mapping: Create a dictionary that maps each digit from 2 to 9 to their corresponding letters on a telephone's buttons.\nBase Case: If the input string digits is empty, return an empty list.\nIteratively Build Combinations: Start with an empty combination in a list and iteratively build the combinations by processing each digit in the input string.\n\nFor each existing combination, append each corresponding letter for the current digit, building new combinations.\n\n\nResult: Return the generated combinations as the final result.\n\nComplexity\n\nTime complexity: ( O(4^n) ), where ( n ) is the length of the input string. In the worst case, each digit can represent 4 letters.\nSpace complexity: ( O(n) ), where ( n ) is the length of the input string.\n\nCode - Iterative\nPythonJavaScriptC++Goclass Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n\n        phone_map = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        combinations = [\"\"]\n\n        for digit in digits:\n            new_combinations = []\n            for combination in combinations:\n                for letter in phone_map[digit]:\n                    new_combinations.append(combination + letter)\n            combinations = new_combinations\n\n        return combinations\nIf you find the solution understandable and helpful, don't hesitate to give it an upvote. Engaging with the code across different languages might just lead you to discover new techniques and preferences! Happy coding! 🚀🦀📞",
        views: "31212",
        upvotes: "154",
        author_id: "284",
        problem_id: 18,
      },
    ],
  },
  {
    title: "18. 4Sum",
    description:
      "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n\n\t0 <= a, b, c, d < n\n\ta, b, c, and d are distinct.\n\tnums[a] + nums[b] + nums[c] + nums[d] == target\n\n\nYou may return the answer in any order.\n\n \nExample 1:\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n\nExample 2:\n\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 200\n\t-109 <= nums[i] <= 109\n\t-109 <= target <= 109\n\n",
    difficulty: "Medium",
    acceptance: "11.27",
    frequency: "164.96",
    topics: [
      [
        "Linked List",
        "Rejection Sampling",
        "Randomized",
        "Combinatorics",
        "Interactive",
        "Quickselect",
        "Shortest Path",
        "Hash Table",
        "Strongly Connected Component",
        "Radix Sort",
      ],
    ],
    languages: [
      [
        "Go",
        "Scala",
        "Java",
        "PHP",
        "C",
        "Elixir",
        "Ruby",
        "Kotlin",
        "TypeScript",
        "Python",
      ],
    ],
    comments: [
      {
        author_id: "579",
        problem_id: 19,
        body: "Я так рад, что решил эту задачу! Это действительно научило меня чему-то новому.",
        comment_reply_id: null,
      },
      {
        author_id: "931",
        problem_id: 19,
        body: "Чувствую себя настоящим гений после того, как решил эту задачу!",
        comment_reply_id: null,
      },
      {
        author_id: "545",
        problem_id: 19,
        body: "Эта задача вынудила меня глубже погрузиться в язык программирования.",
        comment_reply_id: null,
      },
      {
        author_id: "172",
        problem_id: 19,
        body: "Наконец-то я справился с этой задачей! Вперед к следующей!",
        comment_reply_id: null,
      },
      {
        author_id: "161",
        problem_id: 19,
        body: "Когда я столкнулся с этой задачей впервые, я думал, что это невозможно. Теперь я знаю иначе!",
        comment_reply_id: null,
      },
      {
        author_id: "370",
        problem_id: 19,
        body: "Какие интересные подходы у других людей к этой задаче",
        comment_reply_id: null,
      },
      {
        author_id: "915",
        problem_id: 19,
        body: "Чувствую себя чемпионом после этой задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "532",
        problem_id: 19,
        body: "Сколько времени я потратил на решение этой задачи? Не считаясь!",
        comment_reply_id: null,
      },
      {
        author_id: "313",
        problem_id: 19,
        body: "Идея для этого решения пришла ко мне во сне! Удивительно, как мозг работает иногда.",
        comment_reply_id: null,
      },
      {
        author_id: "358",
        problem_id: 19,
        body: "Самая сложная часть в этой задаче - это формулировка.",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "✅ Easy C++ Solution",
        body: "Code\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        vector<vector<int>> v;\n        sort(nums.begin(),nums.end());\n        int n = nums.size();\n        for(int i=0;i<n-3;i++)\n        {\n            if(i > 0 && nums[i] == nums[i - 1])\n            {\n                continue;\n            }\n            for(int j=i+1;j<n-2;j++)\n            {\n                if(j > i + 1 && nums[j] == nums[j - 1])\n                {\n                    continue;\n                }\n                int k = j+1;\n                int l = n-1;\n                while(k < l)\n                {\n                    long long sum = static_cast<long long>(nums[i]) + nums[j] + nums[k] + nums[l];\n                    if(sum > target)\n                    {\n                        l--;\n                    }\n                    else if(sum < target)\n                    {\n                        k++;\n                    }\n                    else\n                    {\n                        v.push_back({nums[i], nums[j], nums[k], nums[l]});\n                        while(k < l && nums[k] == nums[k+1])\n                        {\n                            k++;\n                        }\n                        while(k < l && nums[l] == nums[l-1])\n                        {\n                            l--;\n                        }\n                        k++;\n                        l--;\n                    }\n                }\n            }\n        }\n        return v;\n    }\n};",
        views: "352",
        upvotes: "1",
        author_id: "270",
        problem_id: 19,
      },
      {
        title:
          "✅☑️ Best C++ 3 Solution || Two Pointers || Sorting || Hash Table || Brute Force->Optimize.",
        body: "Intuition\n\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\n\nSolved using Array(Four Nested Loop) + Sorting + Hash Table(set). Brute Force Approach.\nSolved using Array(Three Nested Loop) + Sorting + Hash Table(set).\nSolved using Array(Three Nested Loop) + Sorting. Optimized Approach.\n\nApproach\n\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\nComplexity\n\nTime complexity:\n\n\nTime complexity is given in code comment.\n\nSpace complexity:\n\n\nSpace complexity is given in code comment.\nCode\n/*\n\n    Time Complexity : O(N^4), Here Four nested loop creates the time complexity. Where N is the size of the\n    array(nums).\n\n    Space Complexity : O(N), Hash Table(set) space.\n\n    Solved using Array(Four Nested Loop) + Sorting + Hash Table(set). Brute Force Approach.\n\n    Note : this will give TLE.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        set<vector<int>> set;\n        vector<vector<int>> output;\n        for(int i=0; i<n-3; i++){\n            for(int j=i+1; j<n-2; j++){\n                for(int k=j+1; k<n-1; k++){\n                    for(int l=k+1; l<n; l++){\n                        if((long long)nums[i] + (long long)nums[j] + (long long)nums[k] + \n                        (long long)nums[l] == target){\n                            set.insert({nums[i], nums[j], nums[k], nums[l]});\n                        }\n                    }\n                }\n            }\n        }\n        for(auto it : set){\n            output.push_back(it);\n        }\n        return output;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^3), Here Three nested loop creates the time complexity. Where N is the size of the\n    array(nums).\n\n    Space Complexity : O(N), Hash Table(set) space.\n\n    Solved using Array(Three Nested Loop) + Sorting + Hash Table(set).\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        set<vector<int>> set;\n        vector<vector<int>> output;\n        for(int i=0; i<n-3; i++){\n            for(int j=i+1; j<n-2; j++){\n                long long newTarget = (long long)target - (long long)nums[i] - (long long)nums[j];\n                int low = j+1, high = n-1;\n                while(low < high){\n                    if(nums[low] + nums[high] < newTarget){\n                        low++;\n                    }\n                    else if(nums[low] + nums[high] > newTarget){\n                        high--;\n                    }\n                    else{\n                        set.insert({nums[i], nums[j], nums[low], nums[high]});\n                        low++; high--;\n                    }\n                }\n            }\n        }\n        for(auto it : set){\n            output.push_back(it);\n        }\n        return output;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N^3), Here Three nested loop creates the time complexity. Where N is the size of the\n    array(nums).\n\n    Space Complexity : O(1), Constant space. Extra space is only allocated for the Vector(output), however the\n    output does not count towards the space complexity.\n\n    Solved using Array(Three Nested Loop) + Sorting. Optimized Approach.\n\n*/\n\n\n/***************************************** Approach 3 *****************************************/\n\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> output;\n        for(int i=0; i<n-3; i++){\n            for(int j=i+1; j<n-2; j++){\n                long long newTarget = (long long)target - (long long)nums[i] - (long long)nums[j];\n                int low = j+1, high = n-1;\n                while(low < high){\n                    if(nums[low] + nums[high] < newTarget){\n                        low++;\n                    }\n                    else if(nums[low] + nums[high] > newTarget){\n                        high--;\n                    }\n                    else{\n                        output.push_back({nums[i], nums[j], nums[low], nums[high]});\n                        int tempIndex1 = low, tempIndex2 = high;\n                        while(low < high && nums[low] == nums[tempIndex1]) low++;\n                        while(low < high && nums[high] == nums[tempIndex2]) high--;\n                    }\n                }\n                while(j+1 < n && nums[j] == nums[j+1]) j++;\n            }\n            while(i+1 < n && nums[i] == nums[i+1]) i++;\n        }\n        return output;\n    }\n};\n\nIF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.\n",
        views: "49795",
        upvotes: "359",
        author_id: "912",
        problem_id: 19,
      },
      {
        title:
          "Navigating the 4Sum Challenge: Sorting and Two-Pointer Strategy",
        body: "Intuition\nThe intuition behind the code is to find all unique quadruplets in the given array that sum up to the target value.\nMy approach uses a nested loop along with a two-pointer technique.\nApproach\n\n\nSorting: The input array nums is sorted in non-decreasing order. Sorting the array allows us to efficiently find pairs of elements that sum up to a certain target by using the two-pointer technique.\n\n\nNested Loops: Two nested loops are used to iterate over pairs of elements in the array. The outer loop (a) iterates from the first element to the second-to-last element, and the inner loop (b) iterates from the element after the current outer loop element to the last element. This setup ensures that all possible pairs of elements are considered.\n\n\nTwo-Pointer Technique: Within the nested loops, two pointers (c and d) are used to find pairs of elements that sum up to the target. The c pointer starts from the element after the current b, and the d pointer starts from the last element of the array. These pointers move towards each other, checking the sum of elements at their respective positions.\n\n\nSum Calculation: At each iteration of the while loop, the sum of four elements (nums[a], nums[b], nums[c], and nums[d]) is calculated.\n\n\nComparison with Target: If the sum is less than the target, the c pointer is incremented, moving towards larger elements. If the sum is greater than the target, the d pointer is decremented, moving towards smaller elements. If the sum equals the target, a valid quadruplet is found.\n\n\nQuadruplet Formation: If a valid quadruplet is found, it is added to the ans vector. Before adding, however, the code checks if the quadruplet is already present in the ans vector to avoid duplicates.\nReturn: After both loops complete execution, the function returns the vector ans containing all unique quadruplets that sum up to the target.\nThis approach efficiently finds all unique quadruplets in the sorted array that sum up to the given target value.\n\n\nComplexity\n\n\nTime complexity:\nTime complexity of the algorithm is dominated by the sorting step, resulting in O(n log n) time complexity.\n\n\nSpace complexity:\nThe overall space complexity is O(n^2) due to the result vector and O(log n) due to the sorting step.\n\n\nCode\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        int n=nums.size();\n        vector<vector<int>>ans;\n        sort(nums.begin(),nums.end());\n\n        for(int a=0;a<n;a++)\n        {\n            for(int b=a+1;b<n;b++)\n            {\n                int c=b+1;\n                int d=n-1;\n                while(c<d)\n                {\n                    long long sum=nums[a];\n                    sum+=nums[b];\n                    sum+=nums[c];\n                    sum+=nums[d];\n                    if(sum<target)\n                    {\n                        c++;\n                    }\n                    else if(sum>target)\n                    {\n                        d--;\n                    }\n                    else\n                    {\n                        vector<int>v={nums[a],nums[b],nums[c],nums[d]};\n                        //if new quads then push to main vector\n                        if(find(ans.begin(),ans.end(),v)==ans.end()) \n                        {\n                            ans.push_back(v);\n                        }\n                        c++;\n                        d--;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n",
        views: "696",
        upvotes: "4",
        author_id: "21",
        problem_id: 19,
      },
      {
        title: "🚀 Beats 100% | Binary Search | Most Optimal Approach 🔥",
        body: "🤔 Intuition:\nThe code aims to find all unique quadruplets in an array that sum up to a given target. To achieve this, it employs a nested loop structure with pointers, sorting the array first to simplify the search process.\n🛠️ Approach:\n\nSorting: The array is sorted in ascending order, allowing us to efficiently explore combinations and eliminate duplicates.\nNested Loops: Two outer loops iterate through unique pairs (i, j), avoiding duplicates by skipping identical elements.\nTwo Pointers: Two pointers (start and end) are used to navigate through the remaining elements while checking for quadruplet sums.\nChecking Sums: The sum of four elements is calculated, and based on the comparison with the target, the pointers are adjusted accordingly.\nAvoiding Duplicates: Duplicates are avoided by incrementing or decrementing pointers when equal elements are encountered.\nBuilding Result: Valid quadruplets are added to the result vector.\n\n⏰ Time Complexity:\n\nSorting the array takes O(n log n) time.\nThe triple nested loop structure has an overall time complexity of O(n^3).\nThe inner while loop can be considered as O(n) in the worst case.\n\nCombining these, the overall time complexity is O(n log n) + O(n^3), which simplifies to O(n^3).\n💾 Space Complexity:\n\nThe space complexity is primarily dominated by the result vector, which stores the quadruplets.\nAdditional space is used for variables like sum, start, end, etc., but they are constant in nature.\nTherefore, the space complexity is O(n) for the result vector.\n\nCode\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n        vector<vector<int>> ans;\n\n        int n = nums.size();\n        for(int i = 0; i < n; i++)\n        {\n            if(i > 0 and nums[i] == nums[i - 1]) continue;\n            for(int j = i + 1; j < n; j++)\n            {\n                if(j > (i + 1) and nums[j] == nums[j - 1]) continue;\n                \n                int start = j + 1;\n                int end = n - 1;\n\n                while(start < end)\n                {\n                    long long sum = nums[i];\n                    sum += nums[j];\n                    sum += nums[start];\n                    sum += nums[end];\n\n                    if(sum == target)\n                    {\n                        ans.push_back({nums[i] , nums[j] , nums[start] , nums[end]});\n                        int low = nums[start];\n                        int high = nums[end];\n                        start++,end--;\n                        while(start < end and nums[start] == low) start++;\n                        while(start < end and nums[end] == high) end--;\n                    }\n                    else if(sum > target) end--;\n                    else start++;\n                }\n            }\n        }\n        return ans;\n    }\n};\n",
        views: "10404",
        upvotes: "37",
        author_id: "244",
        problem_id: 19,
      },
    ],
  },
  {
    title: "19. Remove Nth Node From End of List",
    description:
      "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\n \nExample 1:\n\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\n\nExample 2:\n\nInput: head = [1], n = 1\nOutput: []\n\n\nExample 3:\n\nInput: head = [1,2], n = 1\nOutput: [1]\n\n\n \nConstraints:\n\n\n\tThe number of nodes in the list is sz.\n\t1 <= sz <= 30\n\t0 <= Node.val <= 100\n\t1 <= n <= sz\n\n\n \nFollow up: Could you do this in one pass?\n",
    difficulty: "Medium",
    acceptance: "15.41",
    frequency: "78.25",
    topics: [
      [
        "String",
        "Merge Sort",
        "Monotonic Queue",
        "Matrix",
        "Combinatorics",
        "Binary Indexed Tree",
        "Monotonic Stack",
        "Simulation",
        "Doubly-Linked List",
        "Segment Tree",
      ],
    ],
    languages: [
      [
        "Swift",
        "C#",
        "C",
        "PHP",
        "Rust",
        "Python",
        "Python3",
        "Dart",
        "Elixir",
        "Kotlin",
      ],
    ],
    comments: [
      {
        author_id: "899",
        problem_id: 20,
        body: "Эта задача преподнесла мне неожиданный поворот! Интересно, как многие это заметили.",
        comment_reply_id: null,
      },
      {
        author_id: "992",
        problem_id: 20,
        body: "Это моя новая любимая задача! Хочу попробовать еще раз!",
        comment_reply_id: null,
      },
      {
        author_id: "409",
        problem_id: 20,
        body: "Эта задача вынудила меня глубже погрузиться в язык программирования.",
        comment_reply_id: null,
      },
      {
        author_id: "261",
        problem_id: 20,
        body: "Чувствую себя настоящим гений после того, как решил эту задачу!",
        comment_reply_id: null,
      },
      {
        author_id: "587",
        problem_id: 20,
        body: "Было трудно, но я нашел путь к решению этой задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "859",
        problem_id: 20,
        body: "Чувствую себя настоящим гений после того, как решил эту задачу!",
        comment_reply_id: null,
      },
      {
        author_id: "678",
        problem_id: 20,
        body: "Это было как головоломка, но я нашел свой путь к решению!",
        comment_reply_id: null,
      },
      {
        author_id: "916",
        problem_id: 20,
        body: "Эта задача мне не давала покоя, но теперь я горд собой!",
        comment_reply_id: null,
      },
      {
        author_id: "415",
        problem_id: 20,
        body: "Потратил на решение этой задачи весь день, но это было того стоило!",
        comment_reply_id: null,
      },
      {
        author_id: "927",
        problem_id: 20,
        body: "Эта задача заставила меня подумать вне коробки. Очень интересное решение!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "⚡️Beat 100.00% | ✅ Full explanation with pictures 🧩",
        body: "\n\n\n\n\n\n\n\nCode\nPythonPython3C++JavaScriptclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        dummy = ListNode(0)\n        dummy.next = head\n        first = dummy\n        second = dummy\n\n        for _ in range(n + 1):\n            first = first.next\n\n        while first is not None:\n            first = first.next\n            second = second.next\n\n        second.next = second.next.next\n\n        return dummy.next\n\nMy solutions\n🟢 - easyeasyeasy\n🟡 - mediummediummedium\n🔴 - hardhardhard\n🟡 17. Letter Combinations of a Phone Number\n🟡 22. Generate Parentheses\n🟡 39. Combination Sum\n🟢 2540. Minimum Common Value\n🟢 3005. Count Elements With Maximum Frequency\n🟢 3028. Ant on the Boundary\n🟢 876. Middle of the Linked List\n🟡 1750. Minimum Length of String After Deleting Similar Ends\n🟡 948. Bag of Tokens\n🟡 19. Remove Nth Node From End of List\n🟢 977. Squares of a Sorted Array\n🟢 2864. Maximum Odd Binary Number\n🟡 1609. Even Odd Tree\n🟢 9. Palindrome Number\n🟡 513. Find Bottom Left Tree Value\n🟢 1. Two Sum\n🟢 543. Diameter of Binary Tree\nMore...",
        views: "24516",
        upvotes: "142",
        author_id: "817",
        problem_id: 20,
      },
      {
        title: "【Video】Using distance between two pointers",
        body: "Intuition\nUsing distance between two pointers to find nth node from the last.\nSolution Video\n\n⭐️⭐️ Don't forget to subscribe to my channel! ⭐️⭐️\n■ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\nSubscribers: 4,565\nThank you for your support!\n\nApproach\nA challenging point of this question is that Linked List doesn't have index number, so we don't know which node is the last Nth node from the last.\nMy strategy is to create dummy pointer and create distance dummy pointer and head pointer.\nInput: head = [1,2,3,4,5], n = 2\n[1,2,3,4,5]\n d   h\n r\n\nd = dummy\nh = head\nr = res (return value)\nNow we move dummy and head at the same time until head is at the last node.\n[1,2,3,4,5]\n   d   h\n r\n\n[1,2,3,4,5]\n     d   h\n r\nThis example has n = 2, so we should remove  node 4. Luckily, we stop at node 3 which is right before node 4. That is very important.\nWhy?\nThat's because if we stop right before target node, we can remove the target node like this.\ndummy.next = dummy.next.next(= 5 in this case)\nBut what if we stop at the target node.\n[1,2,3,4,5]\n       d   h\nIt's going to be tough to remove the target node. That's why it's important to stop right before the target node.\nBefore we return a new list, we have one more problem. How can we return whole new list? Because head pointer is now the last node and dummy pointer is pointing to node 3.\n[1,2,3,4,5]\n     d   h\n r\nThat's why at first we have dummy pointer and result pointer. The result pointer is still pointing to node 1.\nAll we have to do is just\nreturn res.next\n\n\n\nComplexity\n\nTime complexity: O(n)O(n)O(n)\n\n\n\nSpace complexity: O(1)O(1)O(1)\n\n\nPythonJavaScriptJavaC++class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        res = ListNode(0, head)\n        dummy = res\n\n        for _ in range(n):\n            head = head.next\n        \n        while head:\n            head = head.next\n            dummy = dummy.next\n        \n        dummy.next = dummy.next.next\n\n        return res.next\nStep by Step Algorithm\n\n\nInitialize variables:\n\nWe create a dummy node res with a value of 0 and set its next pointer to the head of the original list. This dummy node helps in handling edge cases when removing the first node.\nWe initialize another pointer dummy to the dummy node res. This pointer will be used to traverse the list.\n\nres = ListNode(0, head)\ndummy = res\n\n\nMove head pointer forward by n nodes:\n\nWe iterate n times using a for loop to advance the head pointer n nodes forward. This effectively moves head to the nth node from the beginning.\n\nfor _ in range(n):\n    head = head.next\n\n\nFind the node before the node to be removed:\n\nWe use a while loop to traverse the list with both head and dummy pointers.\nAs long as head is not None, we move both head and dummy pointers one node forward in each iteration.\nAfter this loop, dummy will be pointing to the node right before the node to be removed.\n\nwhile head:\n    head = head.next\n    dummy = dummy.next\n\n\nRemove the nth node from the end:\n\nOnce the loop finishes, dummy will be pointing to the node right before the node to be removed.\nWe update the next pointer of the node pointed by dummy to skip the next node, effectively removing the nth node from the end.\n\ndummy.next = dummy.next.next\n\n\nReturn the modified list:\n\nFinally, we return the next node after the dummy node res, which is the head of the modified list.\n\nreturn res.next\n\n\nThis algorithm effectively removes the nth node from the end of the linked list by traversing it only once.\n\nThank you for reading my post. Please upvote it and don't forget to subscribe to my channel!\n⭐️ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n⭐️ Twitter\nhttps://twitter.com/CodingNinjaAZ\n⭐️ Related question #167 - Two Sum II - Input Array Is Sorted\n",
        views: "1045",
        upvotes: "23",
        author_id: "811",
        problem_id: 20,
      },
      {
        title:
          "JS, Python, Java, C++ | Easy Two-Pointer Solution w/ Explanation",
        body: "(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, please upvote this post.)\n\nIdea:\nWith a singly linked list, the only way to find the end of the list, and thus the n'th node from the end, is to actually iterate all the way to the end. The challenge here is attemping to find the solution in only one pass. A naive approach here might be to store pointers to each node in an array, allowing us to calculate the n'th from the end once we reach the end, but that would take O(M) extra space, where M is the length of the linked list.\nA slightly less naive approach would be to only store only the last n+1 node pointers in the array. This could be achieved by overwriting the elements of the storage array in circlular fashion as we iterate through the list. This would lower the space complexity to O(N+1).\nIn order to solve this problem in only one pass and O(1) extra space, however, we would need to find a way to both reach the end of the list with one pointer and also reach the n'th node from the end simultaneously with a second pointer.\nTo do that, we can simply stagger our two pointers by n nodes by giving the first pointer (fast) a head start before starting the second pointer (slow). Doing this will cause slow to reach the n'th node from the end at the same time that fast reaches the end.\n\nSince we will need access to the node before the target node in order to remove the target node, we can use fast.next == null as our exit condition, rather than fast == null, so that we stop one node earlier.\nThis will unfortunately cause a problem when n is the same as the length of the list, which would make the first node the target node, and thus make it impossible to find the node before the target node. If that's the case, however, we can just return head.next without needing to stitch together the two sides of the target node.\nOtherwise, once we succesfully find the node before the target, we can then stitch it together with the node after the target, and then return head.\n\nImplementation:\nThere are only minor differences between the code of all four languages.\n\nJavascript Code:\nThe best result for the code below is 60ms / 40.6MB (beats 100% / 13%).\nvar removeNthFromEnd = function(head, n) {\n    let fast = head, slow = head\n    for (let i = 0; i < n; i++) fast = fast.next\n    if (!fast) return head.next\n    while (fast.next) fast = fast.next, slow = slow.next\n    slow.next = slow.next.next\n    return head\n};\n\nPython Code:\nThe best result for the code below is 28ms / 13.9MB (beats 92% / 99%).\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        fast, slow = head, head\n        for _ in range(n): fast = fast.next\n        if not fast: return head.next\n        while fast.next: fast, slow = fast.next, slow.next\n        slow.next = slow.next.next\n        return head\n\nJava Code:\nThe best result for the code below is 0ms / 36.5MB (beats 100% / 97%).\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode fast = head, slow = head;\n        for (int i = 0; i < n; i++) fast = fast.next;\n        if (fast == null) return head.next;\n        while (fast.next != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        slow.next = slow.next.next;\n        return head;\n    }\n}\n\nC++ Code:\nThe best result for the code below is 0ms / 10.6MB (beats 100% / 93%).\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode *fast = head, *slow = head;\n        for (int i = 0; i < n; i++) fast = fast->next;\n        if (!fast) return head->next;\n        while (fast->next) fast = fast->next, slow = slow->next;\n        slow->next = slow->next->next;\n        return head;\n    }\n};",
        views: "138468",
        upvotes: "1.3K",
        author_id: "963",
        problem_id: 20,
      },
      {
        title: "🔥✅✅ Beats 100% with Proof | Very Easy to Understand ✅✅🔥",
        body: "Proof - Upvote if you watching the proof\n\nIntuition\n\nGiven the head of a linked list, remove the nth node from the end of the list and return its head.\n\nApproach\n\n\nCalculate the size of the Single Linked List. We need to travel to the prev node of the node to be removed thus we perform reduce size by n\nIf the node to be removed is the first node (size == 0) then we can simply return the next node of head since it will be null if the list has only one node.\nTraverse till the prev node using a loop again\nSkip the next node by linking the prev node to the next of next node. If not present, assign null.\n\n\nFinally return the head.\n\nComplexity\n\nTime complexity: O(N)\n\n\n\nSpace complexity: O(1)\n\n\nCode\nJavaCC++C#PythonPython3JavascriptTypescript/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        int length = findLength(head);\n        int i = 0, traverseTill = length - n - 1;\n        if(traverseTill == -1) return head.next;\n        ListNode curr = head;\n        while(i < traverseTill){\n            curr = curr.next;\n            i++;\n        }\n        curr.next = curr.next.next;\n        return head;\n    }\n    public int findLength(ListNode head){\n        int count = 0;\n        if(head == null) return count;\n        ListNode curr = head;\n        while(curr != null){\n            count++;\n            curr = curr.next;\n        }\n        return count;\n    }\n}\nUpvote\n",
        views: "14708",
        upvotes: "84",
        author_id: "337",
        problem_id: 20,
      },
    ],
  },
  {
    title: "20. Valid Parentheses",
    description:
      "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n\n\n\tOpen brackets must be closed by the same type of brackets.\n\tOpen brackets must be closed in the correct order.\n\tEvery close bracket has a corresponding open bracket of the same type.\n\n\n \nExample 1:\n\nInput: s = \"()\"\nOutput: true\n\n\nExample 2:\n\nInput: s = \"()[]{}\"\nOutput: true\n\n\nExample 3:\n\nInput: s = \"(]\"\nOutput: false\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 104\n\ts consists of parentheses only '()[]{}'.\n\n",
    difficulty: "Easy",
    acceptance: "16.62",
    frequency: "112.96",
    topics: [
      [
        "Geometry",
        "Brainteaser",
        "Dynamic Programming",
        "Prefix Sum",
        "String Matching",
        "Hash Table",
        "Graph",
        "Iterator",
        "Divide and Conquer",
        "Rejection Sampling",
      ],
    ],
    languages: [
      [
        "Swift",
        "Rust",
        "PHP",
        "C#",
        "Go",
        "Python3",
        "Erlang",
        "C",
        "JavaScript",
        "Java",
      ],
    ],
    comments: [
      {
        author_id: "345",
        problem_id: 21,
        body: "Вот почему я люблю программирование - за такие интересные задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "291",
        problem_id: 21,
        body: "Это был настоящий вызов для моего ума, но я его преодолел!",
        comment_reply_id: null,
      },
      {
        author_id: "873",
        problem_id: 21,
        body: "Какие интересные подходы у других людей к этой задаче",
        comment_reply_id: null,
      },
      {
        author_id: "421",
        problem_id: 21,
        body: "Какие интересные подходы у других людей к этой задаче",
        comment_reply_id: null,
      },
      {
        author_id: "693",
        problem_id: 21,
        body: "Всегда думал, что эта задача невозможна. Но вот я, сделал это!",
        comment_reply_id: null,
      },
      {
        author_id: "318",
        problem_id: 21,
        body: "Всегда думал, что эта задача невозможна. Но вот я, сделал это!",
        comment_reply_id: null,
      },
      {
        author_id: "295",
        problem_id: 21,
        body: "Подсказки были такими полезными! Они действительно помогли мне решить эту задачу.",
        comment_reply_id: null,
      },
      {
        author_id: "339",
        problem_id: 21,
        body: "У кого-нибудь есть идеи, как можно оптимизировать мое решение? Пока я не совсем доволен своим подходом.",
        comment_reply_id: null,
      },
      {
        author_id: "714",
        problem_id: 21,
        body: "Самая сложная часть в этой задаче - это формулировка.",
        comment_reply_id: null,
      },
      {
        author_id: "676",
        problem_id: 21,
        body: "Не могу поверить, что я наконец-то разобрался с этой задачей. Спасибо, сообщество!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "【Video】2 ways to solve this question",
        body: 'Intuition\nUsing Stack\n\nSolution Video\n\n⭐️⭐️ Don\'t forget to subscribe to my channel! ⭐️⭐️\n■ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\nSubscribers: 4,616\nThank you for your support!\n\nApproach\nWe use HashMap and Stack. We know valid combination, so initialize the combination with HashMap before we iterate through the input string.\nmapping = { ")":"(", "}":"{", "]":"[" }\nStack has only open parentheses. When a close parenthesis comes, we use it as a key to find valid open parenthesis in the mapping. If the two parentheses(current parenthesis and the latest parenthesis in Stack) are not valid combination, we should return False.\nAt last, if Stack is empty, we should return True.\n\n\n\nComplexity\n\nTime complexity: O(n)O(n)O(n)\n\n\n\nSpace complexity: O(n)O(n)O(n)\n\n\nPythonJavaScriptJavaC++class Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        mapping = {")":"(", "}":"{", "]":"["}\n\n        for char in s:\n            if char in mapping.values():\n                stack.append(char)\n            elif char in mapping.keys():\n                if not stack or mapping[char] != stack.pop():\n                    return False\n        \n        return not stack\n\nSolution 2\nWe can solve this question with Stack only. If Stack has some parenthesis, we check the latest parenthesis in Stack and current parenthesis are valid combination.\nIf true, just pop the parenthesis from the Stack and move next, if false, add current parenthesis to the Stack.\nAt last, if Stack is empty, return True.\n\nComplexity\n\nTime complexity: O(n)O(n)O(n)\n\n\n\nSpace complexity: O(n)O(n)O(n)\n\n\nPythonJavaScriptJavaC++class Solution:\n    def isValid(self, s: str) -> bool:\n        st = []\n\n        for i in range(len(s)):\n            if st:\n                last = st[-1]\n                if self.is_pair(last, s[i]):\n                    st.pop()\n                    continue\n            st.append(s[i])\n        \n        return not st\n    \n    def is_pair(self, last, cur):\n        if last == "(" and cur == ")" or last == "{" and cur == "}" or last == "[" and cur == "]":\n            return True\n        return False\n\nThank you for reading my post.\n⭐️ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n⭐️ Twitter\nhttps://twitter.com/CodingNinjaAZ\n⭐️ My previous video - Merge Two Sorted Lists #21\n',
        views: "2266",
        upvotes: "27",
        author_id: "358",
        problem_id: 21,
      },
      {
        title:
          "✔️✔️Easy Solutions in Java ✔️✔️, Python ✔️, and C++ ✔️🧐Look at once 💻 with Exaplanation",
        body: "Intuition\n\nThe problem requires us to determine if the given string of brackets is valid or not. We can use a stack data structure to keep track of opening brackets encountered and check if they match with the corresponding closing brackets.\nApproach\n\nHere is the step-by-step approach of the algorithm:\n\n\nInitialize an empty stack.\n\n\nTraverse the input string character by character.\n\n\nIf the current character is an opening bracket (i.e., '(', '{', '['), push it onto the stack.\n\n\nIf the current character is a closing bracket (i.e., ')', '}', ']'), check if the stack is empty. If it is empty, return false, because the closing bracket does not have a corresponding opening bracket. Otherwise, pop the top element from the stack and check if it matches the current closing bracket. If it does not match, return false, because the brackets are not valid.\n\n\nAfter traversing the entire input string, if the stack is empty, return true, because all opening brackets have been matched with their corresponding closing brackets. Otherwise, return false, because some opening brackets have not been matched with their corresponding closing brackets.\n\n\nComplexity\n\nTime complexity:\n\n\nThe time complexity of the solution is O(n)O(n)O(n), where n is the length of the input string. This is because we traverse the string once and perform constant time operations for each character.\n\nSpace complexity:\n\n\nThe space complexity of the solution is O(n)O(n)O(n), where n is the length of the input string. This is because the worst-case scenario is when all opening brackets are present in the string and the stack will have to store them all.\n\nPlease Upvote👍👍\nThanks for visiting my solution.😊 Keep Learning\nPlease give my solution an upvote! 👍\nIt's a simple way to show your appreciation and\nkeep me motivated. Thank you! 😊\nCode\nJavaJavaPythonc++JavaScriptclass Solution {\n    public boolean isValid(String s) {\n        Stack<Character> stack = new Stack<Character>(); // create an empty stack\n        for (char c : s.toCharArray()) { // loop through each character in the string\n            if (c == '(') // if the character is an opening parenthesis\n                stack.push(')'); // push the corresponding closing parenthesis onto the stack\n            else if (c == '{') // if the character is an opening brace\n                stack.push('}'); // push the corresponding closing brace onto the stack\n            else if (c == '[') // if the character is an opening bracket\n                stack.push(']'); // push the corresponding closing bracket onto the stack\n            else if (stack.isEmpty() || stack.pop() != c) // if the character is a closing bracket\n                // if the stack is empty (i.e., there is no matching opening bracket) or the top of the stack\n                // does not match the closing bracket, the string is not valid, so return false\n                return false;\n        }\n        // if the stack is empty, all opening brackets have been matched with their corresponding closing brackets,\n        // so the string is valid, otherwise, there are unmatched opening brackets, so return false\n        return stack.isEmpty();\n    }\n}\n\nJAVA solution without using stack\nJavapublic class Solution {\n    public static boolean isValid(String s) {\n        while (true) {\n            if (s.contains(\"()\")) {\n                s = s.replace(\"()\", \"\");\n            } else if (s.contains(\"{}\")) {\n                s = s.replace(\"{}\", \"\");\n            } else if (s.contains(\"[]\")) {\n                s = s.replace(\"[]\", \"\");\n            } else {\n                // If the string becomes empty, it indicates all brackets are matched.\n                return s.isEmpty();\n            }\n        }\n    }\n}\nPlease Comment👍👍\nThanks for visiting my solution comment below if you like it.😊",
        views: "291555",
        upvotes: "1.9K",
        author_id: "455",
        problem_id: 21,
      },
    ],
  },
  {
    title: "21. Merge Two Sorted Lists",
    description:
      "You are given the heads of two sorted linked lists list1 and list2.\n\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.\n\n \nExample 1:\n\nInput: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n\n\nExample 2:\n\nInput: list1 = [], list2 = []\nOutput: []\n\n\nExample 3:\n\nInput: list1 = [], list2 = [0]\nOutput: [0]\n\n\n \nConstraints:\n\n\n\tThe number of nodes in both lists is in the range [0, 50].\n\t-100 <= Node.val <= 100\n\tBoth list1 and list2 are sorted in non-decreasing order.\n\n",
    difficulty: "Easy",
    acceptance: "46.95",
    frequency: "158.49",
    topics: [
      [
        "Hash Function",
        "Greedy",
        "Trie",
        "Math",
        "Binary Indexed Tree",
        "Game Theory",
        "Array",
        "Collapse",
        "Backtracking",
        "Data Stream",
      ],
    ],
    languages: [
      [
        "JavaScript",
        "Erlang",
        "Java",
        "Python",
        "Python3",
        "Scala",
        "C#",
        "Racket",
        "PHP",
        "TypeScript",
      ],
    ],
    comments: [
      {
        author_id: "221",
        problem_id: 22,
        body: "Какие интересные подходы у других людей к этой задаче",
        comment_reply_id: null,
      },
      {
        author_id: "633",
        problem_id: 22,
        body: "Вот почему я люблю программирование - за такие интересные задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "690",
        problem_id: 22,
        body: "Чувствую себя настоящим гений после того, как решил эту задачу!",
        comment_reply_id: null,
      },
      {
        author_id: "619",
        problem_id: 22,
        body: "Теперь я чувствую, что могу решить что угодно!",
        comment_reply_id: null,
      },
      {
        author_id: "458",
        problem_id: 22,
        body: "Чувствую, что становлюсь лучше программистом с каждой решенной задачей.",
        comment_reply_id: null,
      },
      {
        author_id: "321",
        problem_id: 22,
        body: "Самая сложная часть в этой задаче - это формулировка.",
        comment_reply_id: null,
      },
      {
        author_id: "98",
        problem_id: 22,
        body: "Подсказки были такими полезными! Они действительно помогли мне решить эту задачу.",
        comment_reply_id: null,
      },
      {
        author_id: "48",
        problem_id: 22,
        body: "Я так рад, что решил эту задачу! Это действительно научило меня чему-то новому.",
        comment_reply_id: null,
      },
      {
        author_id: "993",
        problem_id: 22,
        body: "Как я мог пропустить этот трюк? Благодарю за подсказку!",
        comment_reply_id: null,
      },
      {
        author_id: "553",
        problem_id: 22,
        body: "Это было как головоломка, но я нашел свой путь к решению!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title:
          "✅ C++ || Easy To Understand || 2 Approaches || Recursive || Iterative",
        body: "21. Merge Two Sorted Lists\nKNOCKCAT\n1. Easy C++\n2. Line by Line Explanation with Comments.\n3. Detailed Explanation ✅\n4. Linked list problem, merge.\n5. Please Upvote if it helps⬆️\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. ⬇️\n\t// 😉If you Like the repository don't foget to star & fork the repository😉\nLeetCode    LINK TO LEETCODE REPOSITORY\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\nHappy new Year 2023 to all of you\nkeep solving keep improving\nLink To comment\nLeetcode Give away comment\nEXPLANATION\n\n\nMaintain a head and a tail pointer on the merged linked list.\n\n\nThen choose the head of the merged linked list by comparing the first node of both linked lists.\n\n\nFor all subsequent nodes in both lists, you choose the smaller current node and link it to the tail of the merged list, and moving the current pointer of that list one step forward.\n\n\nYou keep doing this while there are some remaining elements in both the lists.\n\n\nIf there are still some elements in only one of the lists, you link this remaining list to the tail of the merged list.\n\n\nInitially, the merged linked list is NULL.\n\n\nCompare the value of the first two nodes and make the node with the smaller value the head node of the merged linked list.\n\n\nSince it’s the first and only node in the merged list, it will also be the tail.\n\n\nThen move head1 one step forward.\n\n\nTime Complexity O(n+m)\nSpace Complexity O(n+m) this is auxiliary stack space due to recursion.\nRECURSIVE APPROACH\n\t\t\t\t\t// 😉😉😉😉Please upvote if it helps 😉😉😉😉\nclass Solution {\npublic:\n\tListNode* mergeTwoLists(ListNode* l1, ListNode* l2) \n  {\n\t\t// if list1 happen to be NULL\n\t\t// we will simply return list2.\n\t\tif(l1 == NULL)\n        {\n\t\t\treturn l2;\n\t\t}\n\t\t\n\t\t// if list2 happen to be NULL\n\t\t// we will simply return list1.\n\t\tif(l2 == NULL)\n        {\n\t\t\treturn l1;\n\t\t} \n\t\t\n\t\t// if value pointend by l1 pointer is less than equal to value pointed by l2 pointer\n\t\t// we wall call recursively l1 -> next and whole l2 list.\n\t\tif(l1 -> val <= l2 -> val)\n        {\n\t\t\tl1 -> next = mergeTwoLists(l1 -> next, l2);\n\t\t\treturn l1;\n\t\t}\n\t\t// we will call recursive l1 whole list and l2 -> next\n\t\telse\n        {\n\t\t\tl2 -> next = mergeTwoLists(l1, l2 -> next);\n\t\t\treturn l2;            \n\t\t}\n\t}\n};\t\nITERATIVE APPROACH\nTime Complexity O(n+m)\nSpace Complexity O(1)\n\t\t\t\t\t// 😉😉😉😉Please upvote if it helps 😉😉😉😉\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n       \n\t    // if list1 happen to be NULL\n\t\t// we will simply return list2.\n        if(list1 == NULL)\n            return list2;\n\t\t\n\t\t// if list2 happen to be NULL\n\t\t// we will simply return list1.\n        if(list2 == NULL)\n            return list1;\n        \n        ListNode * ptr = list1;\n        if(list1 -> val > list2 -> val)\n        {\n            ptr = list2;\n            list2 = list2 -> next;\n        }\n        else\n        {\n            list1 = list1 -> next;\n        }\n        ListNode *curr = ptr;\n        \n\t\t// till one of the list doesn't reaches NULL\n        while(list1 &&  list2)\n        {\n            if(list1 -> val < list2 -> val){\n                curr->next = list1;\n                list1 = list1 -> next;\n            }\n            else{\n                curr->next = list2;\n                list2 = list2 -> next;\n            }\n            curr = curr -> next;\n                \n        }\n\t\t\n\t\t// adding remaining elements of bigger list.\n        if(!list1)\n            curr -> next = list2;\n        else\n            curr -> next = list1;\n            \n        return ptr;\n       \n    }\n};",
        views: "303018",
        upvotes: "2.2K",
        author_id: "989",
        problem_id: 22,
      },
      {
        title: "【Video】Using dummy pointer and recursion solution as a bonus",
        body: "Intuition\nUsing dummpy pointer\nSolution Video\n\n⭐️⭐️ Don't forget to subscribe to my channel! ⭐️⭐️\n■ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\nSubscribers: 4,540\nThank you for your support!\n\nApproach\nJust compare two values from list 1 and list 2, then take the small value and create a new list.\nBut problem is that we can't return \"the head of the merged linked list\". So my strategy is to use dummy pointer which is always pointing to head node as a next node.\nI visualized the solution in the video. Please check it out!\n\nComplexity\n\n\nTime complexity: O(m+n)O(m + n)O(m+n)\nm is length of list1 and n is length of list2\n\n\nSpace complexity: O(1)O(1)O(1)\n\n\n\nPythonJavaScriptJavaC++class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode()\n        cur = dummy\n\n        while list1 and list2:\n            if list1.val > list2.val:\n                cur.next = list2\n                list2 = list2.next\n            else:\n                cur.next = list1\n                list1 = list1.next\n            \n            cur = cur.next\n        \n        if list1:\n            cur.next = list1\n        else:\n            cur.next = list2\n        \n        return dummy.next\nStep by Step Algorithm\n\n\nInitialize variables:\n\nWe create a dummy node to serve as the starting point of the merged list.\nWe initialize a pointer cur to keep track of the current node in the merged list, initially pointing to the dummy node.\n\ndummy = ListNode()\ncur = dummy\n\n\nMerge the lists:\n\nWe iterate through both lists until either list1 or list2 becomes None.\nAt each iteration, we compare the values of the current nodes of list1 and list2.\nIf the value of the current node in list1 is greater than that of list2, we append the current node of list2 to the merged list and move list2 pointer to the next node.\nOtherwise, we append the current node of list1 to the merged list and move list1 pointer to the next node.\n\nwhile list1 and list2:\n    if list1.val > list2.val:\n        cur.next = list2\n        list2 = list2.next\n    else:\n        cur.next = list1\n        list1 = list1.next\n    \n    cur = cur.next\n\n\nAppend remaining nodes:\n\nAfter the loop, if there are remaining nodes in either list1 or list2, we append them to the end of the merged list.\n\nif list1:\n    cur.next = list1\nelse:\n    cur.next = list2\n\n\nReturn the merged list:\n\nWe return the next node after the dummy node, which is the head of the merged list.\n\nreturn dummy.next\n\n\nThis algorithm effectively merges two sorted lists into one sorted list by splicing together their nodes.\n\nBonus\nThese are bonus codes with recursion.\nPythonJavaScriptJavaC++class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        if not list1 or not list2:\n            return list1 if list1 else list2\n\n        if list1.val > list2.val:\n            list1, list2 = list2, list1\n\n        list1.next = self.mergeTwoLists(list1.next, list2)\n        return list1\n\nThank you for reading my post. Please upvote it and don't forget to subscribe to my channel!\n⭐️ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n⭐️ Twitter\nhttps://twitter.com/CodingNinjaAZ\n⭐️ My previous video #15 - 3sum\n",
        views: "3304",
        upvotes: "29",
        author_id: "671",
        problem_id: 22,
      },
      {
        title: "Simple Solution",
        body: "Intuition\nmove pointer on first list and other pointer on  second list at the same time\nApproach\nI create new node , it point to null\nFirst, I go through two lists by two pointers , compare thier elements and add them as sorted elements and until I reach the end of one of them.\nsecondly , i check if there non empty list ,i will add its elements in ans list\nComplexity\n\nTime complexity:\nconsider n=list1.size(),m=list.size()\ntime complexity is o(max(n,m)))\nSpace complexity: o(min(n,m)+1+abs(n-m)))\n\nCode\nListNode* head=NULL;\nvoid insert_back(int value)\n{\nListNode* new_node;\nnew_node=new ListNode;\nnew_node->val=value;\nif(head==nullptr)\n{\nhead=new_node;\nnew_node->next=nullptr;\n}\nelse {\nListNode* temp = head;\nwhile (temp->next != nullptr) {\ntemp = temp->next;\n}\ntemp->next = new_node;\nnew_node->next=nullptr;\n}\n}\nclass Solution {\npublic:\nListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n    head=NULL;\n    while(list1!=NULL&&list2!=NULL)\n    {\n        int n1=list1->val,n2=list2->val;\n        if(n1<=n2)\n        {\n            insert_back(list1->val);\n            list1=list1->next;\n        }\n        else\n        {\n            insert_back(list2->val);\n            list2=list2->next;\n        }\n       \n    }\n        if(list2!=NULL)\n        {\n            while(list2!=NULL)\n            {\n                insert_back(list2->val);\n                list2=list2->next;\n            }\n        }\n        else if(list1!=NULL)\n        {\n            while(list1!=NULL)\n            {\n                insert_back(list1->val);\n                list1=list1->next;\n            }\n        }\n     return head;\n}\n};",
        views: "124",
        upvotes: "2",
        author_id: "699",
        problem_id: 22,
      },
      {
        title: "✔️ [Python3] MERGING, Explained",
        body: "UPVOTE if you like (🌸◠‿◠), If you have any question, feel free to ask.\nFor simplicity, we create a dummy node to which we attach nodes from lists. We iterate over lists using two-pointers and build up a resulting list so that values are monotonically increased.\nTime: O(n)\nSpace: O(1)\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        cur = dummy = ListNode()\n        while list1 and list2:               \n            if list1.val < list2.val:\n                cur.next = list1\n                list1, cur = list1.next, list1\n            else:\n                cur.next = list2\n                list2, cur = list2.next, list2\n                \n        if list1 or list2:\n            cur.next = list1 if list1 else list2\n            \n        return dummy.next\nUPVOTE if you like (🌸◠‿◠), If you have any question, feel free to ask.",
        views: "305895",
        upvotes: "1.2K",
        author_id: "996",
        problem_id: 22,
      },
    ],
  },
  {
    title: "22. Generate Parentheses",
    description:
      'Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\n \nExample 1:\nInput: n = 3\nOutput: ["((()))","(()())","(())()","()(())","()()()"]\nExample 2:\nInput: n = 1\nOutput: ["()"]\n\n \nConstraints:\n\n\n\t1 <= n <= 8\n\n',
    difficulty: "Medium",
    acceptance: "46.08",
    frequency: "8.21",
    topics: [
      [
        "Hash Table",
        "Simulation",
        "Biconnected Component",
        "Combinatorics",
        "Trie",
        "Concurrency",
        "Sorting",
        "Database",
        "Interactive",
        "Design",
      ],
    ],
    languages: [
      [
        "Racket",
        "Erlang",
        "Elixir",
        "Scala",
        "Rust",
        "C++",
        "Ruby",
        "Go",
        "Python",
        "PHP",
      ],
    ],
    comments: [
      {
        author_id: "268",
        problem_id: 23,
        body: "Когда я столкнулся с этой задачей впервые, я думал, что это невозможно. Теперь я знаю иначе!",
        comment_reply_id: null,
      },
      {
        author_id: "419",
        problem_id: 23,
        body: "Иногда простые решения лучше всех! Не всегда нужно усложнять.",
        comment_reply_id: null,
      },
      {
        author_id: "268",
        problem_id: 23,
        body: "Не могу поверить, что я наконец-то разобрался с этой задачей. Спасибо, сообщество!",
        comment_reply_id: null,
      },
      {
        author_id: "680",
        problem_id: 23,
        body: "Кто-нибудь еще решал эту задачу? Хотелось бы услышать ваши мысли!",
        comment_reply_id: null,
      },
      {
        author_id: "349",
        problem_id: 23,
        body: "Эта задача показала мне, насколько важно быть терпеливым в программировании.",
        comment_reply_id: null,
      },
      {
        author_id: "513",
        problem_id: 23,
        body: "Как я мог не догадаться о таком подходе? Спасибо за отличное объяснение!",
        comment_reply_id: null,
      },
      {
        author_id: "709",
        problem_id: 23,
        body: "Чувствую, что становлюсь лучше с каждой решенной задачей!",
        comment_reply_id: null,
      },
      {
        author_id: "657",
        problem_id: 23,
        body: "Эта задача мне не давала покоя, но теперь я горд собой!",
        comment_reply_id: null,
      },
      {
        author_id: "763",
        problem_id: 23,
        body: "Эта задача заставила меня использовать все свои ресурсы!",
        comment_reply_id: null,
      },
      {
        author_id: "7",
        problem_id: 23,
        body: "Наконец-то, я разобрался с этой задачей! Спасибо за все подсказки.",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title:
          "Python, Java w/ Explanation | Faster than 96% w/ Proof | Easy to Understand",
        body: "\nThe idea is to add ')' only after valid '('\nWe use two integer variables left & right to see how many '(' & ')' are in the current string\nIf left < n then we can add '(' to the current string\nIf right < left then we can add ')' to the current string\n\nPython Code:\ndef generateParenthesis(self, n: int) -> List[str]:\n\tdef dfs(left, right, s):\n\t\tif len(s) == n * 2:\n\t\t\tres.append(s)\n\t\t\treturn \n\n\t\tif left < n:\n\t\t\tdfs(left + 1, right, s + '(')\n\n\t\tif right < left:\n\t\t\tdfs(left, right + 1, s + ')')\n\n\tres = []\n\tdfs(0, 0, '')\n\treturn res\nFor n = 2, the recursion tree will be something like this,\n\t\t\t\t\t\t\t\t   \t(0, 0, '')\n\t\t\t\t\t\t\t\t \t    |\t\n\t\t\t\t\t\t\t\t\t(1, 0, '(')  \n\t\t\t\t\t\t\t\t   /           \\\n\t\t\t\t\t\t\t(2, 0, '((')      (1, 1, '()')\n\t\t\t\t\t\t\t   /                 \\\n\t\t\t\t\t\t(2, 1, '(()')           (2, 1, '()(')\n\t\t\t\t\t\t   /                       \\\n\t\t\t\t\t(2, 2, '(())')                (2, 2, '()()')\n\t\t\t\t\t\t      |\t                             |\n\t\t\t\t\tres.append('(())')             res.append('()()')\n   \nJava Code:\nclass Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> res = new ArrayList<String>();\n        recurse(res, 0, 0, \"\", n);\n        return res;\n    }\n    \n    public void recurse(List<String> res, int left, int right, String s, int n) {\n        if (s.length() == n * 2) {\n            res.add(s);\n            return;\n        }\n        \n        if (left < n) {\n            recurse(res, left + 1, right, s + \"(\", n);\n        }\n        \n        if (right < left) {\n            recurse(res, left, right + 1, s + \")\", n);\n        }\n    }\n\t// See above tree diagram with parameters (left, right, s) for better understanding\n}\n\n",
        views: "135653",
        upvotes: "1.6K",
        author_id: "414",
        problem_id: 23,
      },
      {
        title:
          "Simple Solution with Diagrams in Video - JavaScript, C++, Java, Python",
        body: 'Video\nPlease upvote here so others save time too!\nLike the video on YouTube if you found it useful\nClick here to subscribe on YouTube:\nhttps://www.youtube.com/@mayowadan?sub_confirmation=1\n\nJavaScriptPythonC++Java/**\n * @param {number} n\n * @return {string[]}\n */\nvar generateParenthesis = function (n) {\n    let result = [];\n    let output = [];\n    backtrack(n, 0, 0, output, result);\n\n    return result;\n};\n\nfunction backtrack(\n    n,\n    leftCount,\n    rightCount,\n    output,\n    result\n) {\n    // Base case where count of left and right braces is\n    // "n"\n    if (leftCount >= n && rightCount >= n) {\n        // Join the array elements into a string without any\n        // separators.\n        let outputStr = output.join("");\n        result.push(outputStr);\n    }\n\n    // Case where we can still append left braces\n    if (leftCount < n) {\n        output.push("(");\n        backtrack(n, leftCount + 1, rightCount, output, result);\n        output.pop();\n    }\n\n    // Case where we append right braces if the current\n    // count of right braces is less than the count of\n    // left braces\n    if (rightCount < leftCount) {\n        output.push(")");\n        backtrack(n, leftCount, rightCount + 1, output, result);\n        output.pop();\n    }\n}',
        views: "617",
        upvotes: "9",
        author_id: "206",
        problem_id: 23,
      },
    ],
  },
  {
    title: "23. Merge k Sorted Lists",
    description:
      "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n\nMerge all the linked-lists into one sorted linked-list and return it.\n\n \nExample 1:\n\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6\n\n\nExample 2:\n\nInput: lists = []\nOutput: []\n\n\nExample 3:\n\nInput: lists = [[]]\nOutput: []\n\n\n \nConstraints:\n\n\n\tk == lists.length\n\t0 <= k <= 104\n\t0 <= lists[i].length <= 500\n\t-104 <= lists[i][j] <= 104\n\tlists[i] is sorted in ascending order.\n\tThe sum of lists[i].length will not exceed 104.\n\n",
    difficulty: "Hard",
    acceptance: "28.38",
    frequency: "88.77",
    topics: [
      [
        "Prefix Sum",
        "Depth-First Search",
        "Union Find",
        "Monotonic Queue",
        "Heap (Priority Queue)",
        "Binary Search Tree",
        "Dynamic Programming",
        "Strongly Connected Component",
        "Topological Sort",
        "Rolling Hash",
      ],
    ],
    languages: [
      [
        "JavaScript",
        "C#",
        "Rust",
        "Dart",
        "Python",
        "C",
        "Racket",
        "TypeScript",
        "Java",
        "Go",
      ],
    ],
    comments: [
      {
        author_id: "445",
        problem_id: 24,
        body: "Не могу поверить, что решил это за одну попытку! Сейчас немного в шоке.",
        comment_reply_id: null,
      },
      {
        author_id: "567",
        problem_id: 24,
        body: "Чувствую себя чемпионом после этой задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "633",
        problem_id: 24,
        body: "Сложно даже представить, сколько попыток ушло на решение этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "566",
        problem_id: 24,
        body: "Какие интересные подходы у других людей к этой задаче",
        comment_reply_id: null,
      },
      {
        author_id: "350",
        problem_id: 24,
        body: "Эта задача мне не давала покоя, но теперь я горд собой!",
        comment_reply_id: null,
      },
      {
        author_id: "352",
        problem_id: 24,
        body: "Самая сложная часть в этой задаче - это формулировка.",
        comment_reply_id: null,
      },
      {
        author_id: "629",
        problem_id: 24,
        body: "Не могу поверить, что решил это за одну попытку! Сейчас немного в шоке.",
        comment_reply_id: null,
      },
      {
        author_id: "45",
        problem_id: 24,
        body: "Эта задача показала мне, насколько важно быть терпеливым в программировании.",
        comment_reply_id: null,
      },
      {
        author_id: "377",
        problem_id: 24,
        body: "Иногда простые решения лучше всех! Не всегда нужно усложнять.",
        comment_reply_id: null,
      },
      {
        author_id: "227",
        problem_id: 24,
        body: "Это был настоящий вызов для моего ума, но я его преодолел!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "easy to understand heap solution",
        body: "Code\nvar mergeKLists = function(lists) {    \n  const minHeap = []\n  for (let head of lists) if (head) minHeap.push(head);\n  minHeap.sort((a, b) => a.val - b.val)\n  const tempHead = new ListNode();\n  let curr = tempHead;\n  while (minHeap.length) {\n    const {val, next} = minHeap.shift()\n    curr.next = new ListNode(val);\n    curr = curr.next;\n    if (next) {\n     minHeap.push(next); \n     minHeap.sort((a, b) => a.val - b.val)\n    }\n  }\n  return tempHead.next;\n};",
        views: "306",
        upvotes: "1",
        author_id: "71",
        problem_id: 24,
      },
      {
        title: "Merge k Sorted Linked Lists Using Priority Queue",
        body: "Intuition\nTo merge k sorted linked lists efficiently, we can utilize a priority queue (min-heap) to maintain the smallest node among all the heads of the linked lists. By repeatedly extracting the smallest node from the heap and appending it to the merged list, we can construct the final sorted list.\nApproach\n\nInitialize a priority queue (min-heap).\nAdd the heads of all lists to the heap.\nCreate a dummy node to build the merged list.\nMerge lists from the heap until it's empty:\n\n\nExtract the smallest node from the heap.\nAppend the extracted node to the merged list.\nMove to the next node in the list (if it exists) and insert it into the heap.\n\n\nReturn the next node of the dummy node as the head of the merged list.\n\nComplexity\n\n\nTime complexity:\nO(Nlogk), where N is the total number of nodes across all lists and k is the number of linked lists. Each insertion and extraction operation in the priority queue takes O(logk) time, and we perform a total of N such operations.\n\n\nSpace complexity:\nO(k) for the priority queue to store the heads of the linked lists, and O(1) for other variables. Thus, the overall space complexity is O(k).\n\n\nCode\n/**\n * Definition for a singly-linked list.\n * class ListNode {\n *     public $val = 0;\n *     public $next = null;\n *     function __construct($val = 0, $next = null) {\n *         $this->val = $val;\n *         $this->next = $next;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param ListNode[] $lists\n     * @return ListNode\n     */\n    function mergeKLists($lists) {\n        // Initialize a priority queue (min-heap)\n        $heap = new SplMinHeap();\n\n        // Add the heads of all lists to the heap\n        foreach ($lists as $list) {\n            if ($list !== null) {\n                $heap->insert($list);\n            }\n        }\n\n        // Create a dummy node to build the merged list\n        $dummy = new ListNode();\n        $curr = $dummy;\n\n        // Merge lists from the heap until it's empty\n        while (!$heap->isEmpty()) {\n            // Extract the smallest node from the heap\n            $node = $heap->extract();\n\n            // Append the extracted node to the merged list\n            $curr->next = $node;\n            $curr = $curr->next;\n\n            // Move to the next node in the list\n            if ($node->next !== null) {\n                $heap->insert($node->next);\n            }\n        }\n\n        return $dummy->next;\n    }\n}",
        views: "225",
        upvotes: "2",
        author_id: "371",
        problem_id: 24,
      },
      {
        title: "100% faster🔥 | C++✅ Java ✅ Python ✅",
        body: "Code\nPlease Upvote And Comment ....!🙏🙏🙏\nJAVAPythonC++class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) {\n            return null;\n        }\n        return mergeKListsHelper(lists, 0, lists.length - 1);\n    }\n    \n    private ListNode mergeKListsHelper(ListNode[] lists, int start, int end) {\n        if (start == end) {\n            return lists[start];\n        }\n        if (start + 1 == end) {\n            return merge(lists[start], lists[end]);\n        }\n        int mid = start + (end - start) / 2;\n        ListNode left = mergeKListsHelper(lists, start, mid);\n        ListNode right = mergeKListsHelper(lists, mid + 1, end);\n        return merge(left, right);\n    }\n    \n    private ListNode merge(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        \n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                curr.next = l1;\n                l1 = l1.next;\n            } else {\n                curr.next = l2;\n                l2 = l2.next;\n            }\n            curr = curr.next;\n        }\n        \n        curr.next = (l1 != null) ? l1 : l2;\n        \n        return dummy.next;\n    }\n}\n\n\n",
        views: "62396",
        upvotes: "232",
        author_id: "439",
        problem_id: 24,
      },
      {
        title: "EASY SOLUTION.",
        body: "\nCode\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\npublic class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n\n        for(ListNode head : lists) {\n            while(head != null) {\n                pq.add(head.val);\n                map.put(head.val, map.getOrDefault(head.val, 0) + 1);\n                head = head.next;\n            }\n        }\n        \n        ListNode dummy = new ListNode(-1);\n        ListNode current = dummy;\n        while(!pq.isEmpty()) {\n            int val = pq.poll();\n            ListNode newNode = new ListNode(val);\n            current.next = newNode;\n            current = current.next;\n        \n            Integer count = map.get(val);\n            if (count != null && count > 0) {\n                map.put(val, count - 1);\n            } else {\n                map.remove(val); \n            }\n\n            \n        }\n        \n        return dummy.next; \n    }\n}",
        views: "1216",
        upvotes: "1",
        author_id: "320",
        problem_id: 24,
      },
    ],
  },
  {
    title: "24. Swap Nodes in Pairs",
    description:
      "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n\n \nExample 1:\n\nInput: head = [1,2,3,4]\nOutput: [2,1,4,3]\n\n\nExample 2:\n\nInput: head = []\nOutput: []\n\n\nExample 3:\n\nInput: head = [1]\nOutput: [1]\n\n\n \nConstraints:\n\n\n\tThe number of nodes in the list is in the range [0, 100].\n\t0 <= Node.val <= 100\n\n",
    difficulty: "Medium",
    acceptance: "68.15",
    frequency: "161.38",
    topics: [
      [
        "Reservoir Sampling",
        "Collapse",
        "Shell",
        "Iterator",
        "Game Theory",
        "Shortest Path",
        "Geometry",
        "Combinatorics",
        "Array",
        "String Matching",
      ],
    ],
    languages: [
      [
        "Swift",
        "Elixir",
        "Rust",
        "TypeScript",
        "Go",
        "C#",
        "PHP",
        "Python",
        "Java",
        "Ruby",
      ],
    ],
    comments: [
      {
        author_id: "65",
        problem_id: 25,
        body: "Кто бы мог подумать, что решение окажется настолько простым!",
        comment_reply_id: null,
      },
      {
        author_id: "412",
        problem_id: 25,
        body: "Благодаря этой задаче я узнал о новой функции языка программирования.",
        comment_reply_id: null,
      },
      {
        author_id: "986",
        problem_id: 25,
        body: "Не могу поверить, что я наконец-то разобрался с этой задачей. Спасибо, сообщество!",
        comment_reply_id: null,
      },
      {
        author_id: "39",
        problem_id: 25,
        body: "Я не знал, что это возможно, пока не попробовал! Это было удивительно!",
        comment_reply_id: null,
      },
      {
        author_id: "68",
        problem_id: 25,
        body: "Чувствую себя чемпионом после этой задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "55",
        problem_id: 25,
        body: "Это моя новая любимая задача! Хочу попробовать еще раз!",
        comment_reply_id: null,
      },
      {
        author_id: "625",
        problem_id: 25,
        body: "Сложно поверить, что я только что решил это! Спасибо всем за поддержку.",
        comment_reply_id: null,
      },
      {
        author_id: "244",
        problem_id: 25,
        body: "Не могу поверить, что я наконец-то разобрался с этой задачей. Спасибо, сообщество!",
        comment_reply_id: null,
      },
      {
        author_id: "309",
        problem_id: 25,
        body: "Подсказки были такими полезными! Они действительно помогли мне решить эту задачу.",
        comment_reply_id: null,
      },
      {
        author_id: "177",
        problem_id: 25,
        body: "Теперь я чувствую, что могу решить что угодно!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title:
          "🚀SWAPPING NODES (Not just the values) || Visual Explanation || Well Explained || C++",
        body: "As mentioned in the question we have to exchange the nodes itself (and not just their values), and this solution follows this constraint.\nI will be placing a dummy node before the head node so that the code we write can also be applicable to the head node also, and we don't have to specifically write different conditions for the head node.\nExample:\nGiven Linked List\n\nFinal Linked List\n\nLet's now understand the approach\n\nAs mentioned earlier, we will place a dummyNode before the head node.\n\n\n\nNow, let the head be our currNode. That means the node with value 1 is the currNode, and we have to swap it with the node with value 2. So for this, we will also have to keep track of the node previous to the currNode, let it be prevNode, as it's next pointer value will have to change after we swap the currNode and the node next to currNode.\n\n\n\nNow the very first thing to do is change the next pointer of prevNode to point to currNode->next. Why?? Because in the answer we want the node with value 2 after the dummyNode. Right? So we will have to connect dummyNode (prevNode) to the node with value  2 (currNode->next). This means\n\nprevNode->next = currNode->next\n\n\nNow, in our finl answer node with value 1 should be at the place of node with value 2. So the next pointer of node with value 1 should point to whatever the node with value 2 is pointing to originally. That means we will have to change currNode->next to the next of next of prevNode, as currently prevNode is dummyNode, prevNode->next is node with value 2 and prevNode->next->next = next of node with value 2. This means\n\ncurrNode->next = prevNode->next->next\n\n\nNow, as in the answer the node with value 2 should point to node with value 1. That means\n\nprevNode->next->next = currNode\n\n\nAfter this iteration, nodes 1 and 2 will get swapped and our linked list will look like this.\n\n\n\nNow for the next iteration, we have to swap nodes with values 3 and 4. For that the prevNode should point to node with value 1 and the currNode should point to node with value 3. This means\n\nprevNode = currNode\ncurrNode = currNode->next\n\n\n\nWe should stop this procedure when either there is no nodes left to swap or there is only one node left which cannot be swapped with any node.\n\n\nAt the end, as we can see that our head of the list has been misplaced in the procedure of swapping, so we can return dummyNode->next to return the swapped linked list.\n\n\nCode\nListNode* swapPairs(ListNode* head) {\n        if(!head || !head->next) return head; //If there are less than 2 nodes in the given nodes, then no need to do anything just return the list as it is.\n\t\t\n        ListNode* dummyNode = new ListNode();\n        \n        ListNode* prevNode=dummyNode;\n        ListNode* currNode=head;\n        \n        while(currNode && currNode->next){\n            prevNode->next = currNode->next;\n            currNode->next = prevNode->next->next;\n            prevNode->next->next = currNode;\n            \n            prevNode = currNode;\n            currNode = currNode->next;\n        }\n        \n        return dummyNode->next;\n    }\n\nComplexity:\nTC = O(n)\nSC = O(1)\nPlz upvote if you liked the post",
        views: "63462",
        upvotes: "1K",
        author_id: "570",
        problem_id: 25,
      },
      {
        title: "Easy C++ solution || Beats 100% || Recursive approach",
        body: "Code\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* solve(ListNode* head){\n        //base case\n        if(head == NULL || head->next == NULL){\n            return head;\n        }\n\n        //ek case solve kardo\n        ListNode* prev = NULL;\n        ListNode* curr = head;\n        ListNode* forward = curr->next;\n\n        int count = 0;\n        while(count < 2) {\n            forward = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = forward;\n            count++;\n        }\n\n        if(forward != NULL){\n            ListNode* recKaAns = solve(forward);\n            head->next = recKaAns;\n        }\n\n        return prev;\n    }\n\n\n    ListNode* swapPairs(ListNode* head) {\n        return solve(head);\n    }\n};",
        views: "1355",
        upvotes: "1",
        author_id: "349",
        problem_id: 25,
      },
      {
        title: "Simple Solution using Recursion | Beats 100%",
        body: "Code\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rec(ListNode* head){\n        if(head==NULL) return NULL;\n        if(head->next==NULL) return head;\n        if(head->next->next==NULL){\n            ListNode* temp=head->next;\n            head->next->next=head;\n            head->next=NULL;\n            return temp;\n        }\n        ListNode* n=head->next;\n        head->next=rec(head->next->next);\n        n->next=head;\n        return n;\n    }\n    ListNode* swapPairs(ListNode* head) {\n        if(head==NULL || head->next==NULL) return head;\n        return rec(head);\n    }\n};",
        views: "898",
        upvotes: "1",
        author_id: "675",
        problem_id: 25,
      },
      {
        title:
          "Easy Recursive Solution in Time Complexity :O(n) and Space Complexity :O(1)",
        body: "Intuition\nWe will solve the problem for the first pair and then rest will be solved recursively...\nComplexity\n\n\nTime complexity:\nO(n)\n\n\nSpace complexity:\nO(1)\n\n\nCode\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == NULL || head->next == NULL) return head;\n\n        ListNode * temp = head->next->next;\n        ListNode * newHead = head->next;\n\n        head->next->next = head;\n        head->next =  swapPairs(temp);\n\n        return newHead;\n    }\n};",
        views: "560",
        upvotes: "1",
        author_id: "619",
        problem_id: 25,
      },
    ],
  },
  {
    title: "25. Reverse Nodes in k-Group",
    description:
      "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\n\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n\n \nExample 1:\n\nInput: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n\n\nExample 2:\n\nInput: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\n\n\n \nConstraints:\n\n\n\tThe number of nodes in the list is n.\n\t1 <= k <= n <= 5000\n\t0 <= Node.val <= 1000\n\n\n \nFollow-up: Can you solve the problem in O(1) extra memory space?\n",
    difficulty: "Hard",
    acceptance: "37.65",
    frequency: "130.15",
    topics: [
      [
        "Number Theory",
        "Segment Tree",
        "Line Sweep",
        "Tree",
        "Shell",
        "Two Pointers",
        "Recursion",
        "Design",
        "Monotonic Queue",
        "Enumeration",
      ],
    ],
    languages: [
      [
        "C#",
        "Scala",
        "Kotlin",
        "Java",
        "Python",
        "JavaScript",
        "Elixir",
        "Go",
        "TypeScript",
        "C++",
      ],
    ],
    comments: [
      {
        author_id: "733",
        problem_id: 26,
        body: "У кого-нибудь есть идеи, как можно оптимизировать мое решение? Пока я не совсем доволен своим подходом.",
        comment_reply_id: null,
      },
      {
        author_id: "945",
        problem_id: 26,
        body: "Эта задача мне не давала покоя, но теперь я горд собой!",
        comment_reply_id: null,
      },
      {
        author_id: "509",
        problem_id: 26,
        body: "Кто-нибудь еще решал эту задачу? Хотелось бы услышать ваши мысли!",
        comment_reply_id: null,
      },
      {
        author_id: "809",
        problem_id: 26,
        body: "Эта задача заставила меня использовать все свои ресурсы!",
        comment_reply_id: null,
      },
      {
        author_id: "209",
        problem_id: 26,
        body: "Я так рад, что решил эту задачу! Это действительно научило меня чему-то новому.",
        comment_reply_id: null,
      },
      {
        author_id: "879",
        problem_id: 26,
        body: "Не могу поверить, что решил это за одну попытку! Сейчас немного в шоке.",
        comment_reply_id: null,
      },
      {
        author_id: "109",
        problem_id: 26,
        body: "Не могу поверить, что решил это за одну попытку! Сейчас немного в шоке.",
        comment_reply_id: null,
      },
      {
        author_id: "413",
        problem_id: 26,
        body: "Всегда думал, что эта задача невозможна. Но вот я, сделал это!",
        comment_reply_id: null,
      },
      {
        author_id: "975",
        problem_id: 26,
        body: "Эта задача мне не давала покоя, но теперь я горд собой!",
        comment_reply_id: null,
      },
      {
        author_id: "113",
        problem_id: 26,
        body: "Не могу поверить, что я решил это без помощи Google!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "Golang, Iterative approach, O(n), O(1)",
        body: "Intuition\nI could solve it without any hints, but before I learned fake-head pattern and simple reverse in some other problems\nApproach\n\nI iterate through the list and count nodes in current group\nIf counter is bigger then group length (k) it means than current group is ended and we can reverse it\nAt first we need to set prev and next for the whole group, then set group head and cut tail\nthen just reverse the group, but before don't foreget to link it with next and prev nodes for this group\n\nComplexity\n\n\nTime complexity:\nO(n)\n\n\nSpace complexity:\nO(1)\n\n\nCode\n/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */\nfunc reverseKGroup(head *ListNode, k int) *ListNode {\n    headCopy := head\n    \n    // line is the group for reverse\n    headInLine := head\n    tailInLine := head\n    \n    fakeHeadToReturn := &ListNode{\n        Val: -1,\n        Next: head,\n    }\n\n    prevForLine := fakeHeadToReturn\n    nextForLine := head\n    \n    count := 1\n    isFirstLine := true\n    for headCopy != nil {\n        tailInLine = headCopy\n        headCopy = headCopy.Next\n        count++\n        if count > k {\n            // cut line of nodes from first node to last, for last set next to nil\n            headInLine = prevForLine.Next\n            nextForLine = tailInLine.Next\n            tailInLine.Next = nil\n\n            // set next as prev for first node in line\n            tPrev := nextForLine\n            // move last node in line to first place for prev node\n            prevForLine.Next = tailInLine\n            // set first node in line as prev for future lines \n            prevForLine = headInLine\n            \n            // everything set up, just reverse cut line\n            for headInLine != nil {\n                temp := headInLine.Next\n                headInLine.Next = tPrev\n                tPrev = headInLine   \n                headInLine = temp\n            }\n            \n            if isFirstLine {\n                fakeHeadToReturn.Next = tPrev\n                isFirstLine = false\n            }            \n            count = 1\n        }\n    }\n\n    return fakeHeadToReturn.Next\n}",
        views: "1424",
        upvotes: "2",
        author_id: "357",
        problem_id: 26,
      },
      {
        title: "Solution✅",
        body: "Code\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\nstruct ListNode* revList(struct ListNode* top, struct ListNode** last)\n{\n    struct ListNode* next = NULL;\n    struct ListNode* prev = NULL;\n    struct ListNode* curr = top;\n    *last = top;\n    while(curr != NULL)\n    {\n        next = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = next;\n    }\n\n    return prev;\n}\n\nstruct ListNode* reverseKGroup(struct ListNode* head, int k) {\n    int len = 0;\n    struct ListNode* curr = head;\n    struct ListNode* start = NULL;\n    struct ListNode* next = NULL;\n    struct ListNode* finalList = NULL;\n    struct ListNode* tempList = NULL;\n    struct ListNode* last = NULL;\n    struct ListNode* prev = NULL;\n    struct ListNode* trav = head;\n    if(curr == NULL || curr->next == NULL) return curr;         // Base Case\n    while(trav != NULL)\n    {\n        len++;\n        trav = trav->next;\n    }\n\n    while (curr != NULL)\n    {\n        start = curr;\n        if(len < k)\n        {\n            last->next = curr;\n            return finalList;\n        }\n        for (int i = 0; i < k - 1 && curr->next != NULL; i++) curr = curr->next;\n        next = curr->next;\n        curr->next = NULL;\n        prev = last;\n        tempList = revList(start, &last);\n        if(finalList == NULL) finalList = tempList;\n        else prev->next = tempList;\n        len-=k;\n        curr = next;\n    }\n    return finalList;\n}",
        views: "116",
        upvotes: "1",
        author_id: "386",
        problem_id: 26,
      },
      {
        title: "It cant be easier than this one, I promise",
        body: 'Intuition\n\nHEY GUYS PLEASE UPVOTE , I PUT IN A LOT A EFFORT ON THE POSTSS. ALSO GUYS REMEMBER WE GOTTA GOAL TO CONQUER AND WE ARE NOT GOING TO STOP TILL THE GOAL IS ACHIEVED ,=. BE THE BEST VERSION OF YOURSELF BE AGGRESSIVE IN YOUR APPROACH WORK TREMENDUOSLY HARD , BEAT EVERYONE WITH YOUR HARDWORK , CUZ I AM UNSTOPPABLE AND YOU CANT BEAT ME . NO REASON IS GOOD ENOUGH TO STOP . I CANT LOOSE .\nApproach\n\nPythonclass Solution(object):\n    def reverseKGroup(self, head, k):\n        """\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        """\n        def reverseLinkedList(head, k):\n            prev = None\n            curr = head\n            while k > 0 and curr:\n                next_node = curr.next\n                curr.next = prev\n                prev = curr\n                curr = next_node\n                k -= 1\n            return prev\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev_group_end = dummy\n        while True:\n            # Check if there are at least k nodes left\n            start = prev_group_end.next\n            end = prev_group_end\n            for _ in range(k):\n                if end.next:\n                    end = end.next\n                else:\n                    return dummy.next  # No more nodes to reverse\n            \n            # Save the next group\'s start\n            next_group_start = end.next\n            \n            # Reverse the current group\n            end.next = None  # Disconnect the end of the current group\n            prev_group_end.next = reverseLinkedList(start, k)\n            \n            # Reconnect the reversed group\n            start.next = next_group_start\n            \n            # Update prev_group_end for the next iteration\n            prev_group_end = start\n        \n        return dummy.next\n\nSteps:\n\n\nInitialization:\n\nListNode temp = head: Creates a pointer temp that starts from the head of the linked list (head).\nListNode ans = head: Creates another pointer ans that also starts from the head. This pointer will eventually point to the head of the reversed linked list.\n\n\n\nIterating Through Groups:\n\nwhile (temp != null): The loop iterates as long as temp doesn\'t reach the end of the linked list.\n\nArrayList<Integer> al = new ArrayList<>(): Creates a new ArrayList al to temporarily store the values of the nodes in the current group (up to k nodes).\nListNode headA = temp: Creates another pointer headA that also points to the current node (temp). This pointer will be used to traverse the nodes within the current group during reversal.\nwhile (temp != null && al.size() != k): This inner loop iterates until either the end of the list is reached (temp == null) or the current group reaches its size limit (al.size() != k).\n\nal.add(temp.val): Adds the value of the current node (temp.val) to the ArrayList al.\ntemp = temp.next: Moves temp to the next node in the list.\n\n\n\n\n\n\n\nReversing the Group (if k nodes found):\n\nif (al.size() == k): Checks if the current group has exactly k nodes.\n\nfor (int i = al.size() - 1; i >= 0; i--): This loop iterates in reverse order from the last element (i = al.size() - 1) to the first element (i >= 0) of the ArrayList al.\n\nheadA.val = al.get(i): Updates the value of the current node pointed to by headA with the value retrieved from the ArrayList at the corresponding index i. This effectively reverses the order of the nodes within the group.\nheadA = headA.next: Moves headA to the next node in the group for the next iteration of the reversal loop.\n\n\n\n\n\n\n\nMoving to the Next Group:\n\nSince the loop continues iterating as long as temp isn\'t null, it automatically moves to the next group of nodes after processing the current group (if it has k nodes).\n\n\n\nReturning the Result:\n\nreturn head: The function returns the original head pointer, which now points to the head of the reversed linked list with groups of k nodes reversed.\n\n\n\nComplexity\n\nTime complexity:\n\n\nO(n)\n\nSpace complexity:\n\n\nO(n)\nCode\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ListNode temp=head;\n        ListNode ans=head;\n        while(temp!=null){\n            ArrayList<Integer> al=new ArrayList<>();\n            ListNode headA=temp;\n            while(temp!=null && al.size()!=k){\n                al.add(temp.val);\n                temp=temp.next;\n            }\n            if(al.size()==k){\n                for(int i=al.size()-1;i>=0;i--){\n                    headA.val=al.get(i);\n                    headA=headA.next;\n                }\n            }\n        }\n        return head;\n    }\n}',
        views: "589",
        upvotes: "5",
        author_id: "94",
        problem_id: 26,
      },
      {
        title: "Java Easy Solution by using ArrayList and reverse() function.",
        body: "Intuition\n\nApproach\n\nComplexity\n\nTime complexity:\n\n\n\nSpace complexity:\n\n\nCode\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public int length(ListNode cur) {\n        int len = 0;\n        while(cur != null) {\n            len++;\n            cur = cur.next;\n        }\n        return len;\n    }\n\n    public ListNode reverse(ListNode head) {\n        ListNode prev = null;\n        ListNode cur = head;\n        ListNode temp = head;\n        while (temp != null) {\n            temp = temp.next;\n            cur.next = prev;\n            prev = cur;\n            cur = temp;\n        }\n        return prev;\n    }\n\n    public ListNode findNext(ListNode head) {\n        while(head.next != null) {\n            head = head.next;\n        }\n        return head;\n    }\n    \n    public ListNode reverseKGroup(ListNode head, int k) {\n        if(length(head) < k)\n            return head;\n        ArrayList<ListNode> arrayList = new ArrayList<>();\n        int len = length(head);\n        ListNode temp = head;\n        while (len >= k) {\n            ListNode cur = temp;\n            int i = 1;\n            while(i < k) {\n                cur = cur.next;\n                i++;\n            }\n            ListNode tempVal = cur.next;\n            cur.next = null;\n            arrayList.add(temp);\n            temp = tempVal;\n            len -= i;\n        }\n        if(temp != null)\n            arrayList.add(temp);\n\n        ListNode ans = null;\n        ListNode cur = null;\n        for(ListNode node : arrayList) {\n            if(length(node) == k) {\n                if(cur == null) {\n                    cur = reverse(node);\n                    ans = cur;\n                } else {\n                    cur = findNext(cur);\n                    cur.next = reverse(node);\n                }\n            } else {\n                cur = findNext(cur);\n                cur.next = node;\n            }\n        }\n        return ans;\n    }\n}",
        views: "69",
        upvotes: "1",
        author_id: "314",
        problem_id: 26,
      },
    ],
  },
  {
    title: "26. Remove Duplicates from Sorted Array",
    description:
      "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\n\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\n\n\n\tChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.\n\tReturn k.\n\n\nCustom Judge:\n\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\n\nIf all assertions pass, then your solution will be accepted.\n\n \nExample 1:\n\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\nExample 2:\n\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 3 * 104\n\t-100 <= nums[i] <= 100\n\tnums is sorted in non-decreasing order.\n\n",
    difficulty: "Easy",
    acceptance: "8.69",
    frequency: "112.08",
    topics: [
      [
        "Tree",
        "Two Pointers",
        "Data Stream",
        "Shell",
        "Merge Sort",
        "Counting Sort",
        "Breadth-First Search",
        "Radix Sort",
        "Line Sweep",
        "Dynamic Programming",
      ],
    ],
    languages: [
      [
        "Rust",
        "Scala",
        "Java",
        "Elixir",
        "Dart",
        "C",
        "Racket",
        "TypeScript",
        "Go",
        "Kotlin",
      ],
    ],
    comments: [
      {
        author_id: "17",
        problem_id: 27,
        body: "Не могу поверить, что я решил это без помощи Google!",
        comment_reply_id: null,
      },
      {
        author_id: "126",
        problem_id: 27,
        body: "Не могу поверить, что я решил это без помощи Google!",
        comment_reply_id: null,
      },
      {
        author_id: "261",
        problem_id: 27,
        body: "Эта задача преподнесла мне неожиданный поворот! Интересно, как многие это заметили.",
        comment_reply_id: null,
      },
      {
        author_id: "825",
        problem_id: 27,
        body: "Эта задача заставила меня использовать все свои ресурсы!",
        comment_reply_id: null,
      },
      {
        author_id: "41",
        problem_id: 27,
        body: "Сложно даже представить, сколько попыток ушло на решение этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "514",
        problem_id: 27,
        body: "Не могу поверить, что решил это за одну попытку! Сейчас немного в шоке.",
        comment_reply_id: null,
      },
      {
        author_id: "45",
        problem_id: 27,
        body: "Не могу поверить, что я наконец-то разобрался с этой задачей. Спасибо, сообщество!",
        comment_reply_id: null,
      },
      {
        author_id: "805",
        problem_id: 27,
        body: "Чувствую, что становлюсь лучше программистом с каждой решенной задачей.",
        comment_reply_id: null,
      },
      {
        author_id: "995",
        problem_id: 27,
        body: "Чувствую, что становлюсь лучше с каждой решенной задачей!",
        comment_reply_id: null,
      },
      {
        author_id: "952",
        problem_id: 27,
        body: "Это было круто! Какая следующая задача?",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title:
          "✅Best Method 🔥|| 100% || C++ || JAVA || PYTHON || Beginner Friendly🔥🔥🔥",
        body: "Intuition:\nThe Intuition is to use two pointers, i and j, to iterate through the array. The variable j is used to keep track of the current index where a unique element should be placed. The initial value of j is 1 since the first element in the array is always unique and doesn't need to be changed.\nExplanation:\nThe code starts iterating from i = 1 because we need to compare each element with its previous element to check for duplicates.\nThe main logic is inside the for loop:\n\nIf the current element nums[i] is not equal to the previous element nums[i - 1], it means we have encountered a new unique element.\nIn that case, we update nums[j] with the value of the unique element at nums[i], and then increment j by 1 to mark the next position for a new unique element.\nBy doing this, we effectively overwrite any duplicates in the array and only keep the unique elements.\n\nOnce the loop finishes, the value of j represents the length of the resulting array with duplicates removed.\nFinally, we return j as the desired result.\nCode\nC++JavaPython3class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int j = 1;\n        for(int i = 1; i < nums.size(); i++){\n            if(nums[i] != nums[i - 1]){\n                nums[j] = nums[i];\n                j++;\n            }\n        }\n        return j;\n    }\n};\n\nIf you are a beginner solve these problems which makes concepts clear for future coding:\n\nTwo Sum\nRoman to Integer\nPalindrome Number\nMaximum Subarray\nRemove Element\nContains Duplicate\nAdd Two Numbers\nMajority Element\nRemove Duplicates from Sorted Array\nPractice them in a row for better understanding and please Upvote the post for more questions.\n\nIf you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.",
        views: "326004",
        upvotes: "1.9K",
        author_id: "268",
        problem_id: 27,
      },
      {
        title: "Simplest 4 line sol. with proper explanation",
        body: "Intuition\nWe can think of using two pointers ‘i’ and ‘j’, we move ‘j’ till we don’t get a number arr[j] which is different from arr[i]. As we got a unique number we will increase the i pointer and update its value by arr[j].\n\nApproach\nTake a variable i as 0;\nUse a for loop by using a variable ‘j’ from 1 to length of the array.\nIf arr[j] != arr[i], increase ‘i’ and update arr[i] == arr[j].\nAfter completion of the loop return i+1, i.e size of the array of unique elements.\n\nComplexity\n\nTime complexity:O(n)\n\n\n\nSpace complexity:O(1)\n\n\nCode\nclass Solution {\n    public int removeDuplicates(int[] arr) {\n        int i=0;\n        for(int j=1;j<arr.length;j++){\n            if(arr[i]!=arr[j]){\n                i++;\n                arr[i]=arr[j];\n            }\n        }\n        return i+1;\n        \n    }\n}\n",
        views: "93880",
        upvotes: "537",
        author_id: "214",
        problem_id: 27,
      },
      {
        title: "better solution with java",
        body: "Intuition\n\nApproach\n\nComplexity\n\nTime complexity:\n\n\n\nSpace complexity:\n\n\nCode\nclass Solution {\n\n    public static int removeDuplicates(int[] nums) {\n        int k = 0;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] != nums[k]) {\n                nums[++k] = nums[i];\n            }\n        }\n        return ++k;\n    }\n}",
        views: "849",
        upvotes: "1",
        author_id: "44",
        problem_id: 27,
      },
      {
        title: "Java Easy Solution with Explanation || 100% beats",
        body: "Intuition\n\nWe can utilize a two-pointer approach to solve this problem.\n\nPlacement Pointer: This pointer indicates the current position in the array where a unique number should be placed.\nSkipping Pointer: This pointer iterates through the array, comparing elements to identify duplicates.\n\n\nApproach\n\nInitialize i to 0, representing the first element of the array, and size to the length of the array.\nIterate j from 1 to size - 1 to traverse the array from the second element onwards.\nFor each j, if nums[i] is equal to nums[j], it means there is a duplicate, so we continue to the next iteration without incrementing i.\nIf nums[i] is not equal to nums[j], it means nums[j] is a new element. We move this element to the next position after i (i.e., nums[i + 1] = nums[j]) and then increment i to include this new element in the non-duplicate part of the array.\nAfter the loop completes, i points to the last index of the non-duplicate part of the array, so the length of the array with duplicates removed is i + 1.\n\nComplexity\n\nTime complexity: O(n)O(n)O(n)\n\n\n\nSpace complexity: O(1)O(1)O(1)\n\n\nCode\nclass Solution {\n    public int removeDuplicates(int[] nums) {  \n        int i = 0, size = nums.length;\n\n        for (int j = 1; j < size; j++) {\n            if (nums[i] == nums[j]) {\n                continue;\n            }\n\n            nums[i + 1] = nums[j];\n            i++;\n        }\n\n        return i+1;\n    }\n}\n",
        views: "425",
        upvotes: "5",
        author_id: "366",
        problem_id: 27,
      },
    ],
  },
  {
    title: "27. Remove Element",
    description:
      "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\n\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\n\n\n\tChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.\n\tReturn k.\n\n\nCustom Judge:\n\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\n\nIf all assertions pass, then your solution will be accepted.\n\n \nExample 1:\n\nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2,_,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\nExample 2:\n\nInput: nums = [0,1,2,2,3,0,4,2], val = 2\nOutput: 5, nums = [0,1,4,0,3,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n\n \nConstraints:\n\n\n\t0 <= nums.length <= 100\n\t0 <= nums[i] <= 50\n\t0 <= val <= 100\n\n",
    difficulty: "Easy",
    acceptance: "66.10",
    frequency: "1.34",
    topics: [
      [
        "Interactive",
        "Graph",
        "Database",
        "Union Find",
        "Matrix",
        "Sorting",
        "Recursion",
        "Prefix Sum",
        "String Matching",
        "Binary Search Tree",
      ],
    ],
    languages: [
      [
        "Dart",
        "C#",
        "Racket",
        "C++",
        "Python3",
        "Erlang",
        "Swift",
        "Kotlin",
        "Ruby",
        "Python",
      ],
    ],
    comments: [
      {
        author_id: "215",
        problem_id: 28,
        body: "Кто бы мог подумать, что решение окажется настолько простым!",
        comment_reply_id: null,
      },
      {
        author_id: "509",
        problem_id: 28,
        body: "Чувствую, что становлюсь лучше программистом с каждой решенной задачей.",
        comment_reply_id: null,
      },
      {
        author_id: "133",
        problem_id: 28,
        body: "Теперь я чувствую, что могу решить что угодно!",
        comment_reply_id: null,
      },
      {
        author_id: "550",
        problem_id: 28,
        body: "Не могу поверить, что решил это за одну попытку! Сейчас немного в шоке.",
        comment_reply_id: null,
      },
      {
        author_id: "578",
        problem_id: 28,
        body: "Кто-нибудь сталкивался с такой ошибкой раньше? Не могу понять, в чем проблема.",
        comment_reply_id: null,
      },
      {
        author_id: "542",
        problem_id: 28,
        body: "Чувствую себя чемпионом после этой задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "11",
        problem_id: 28,
        body: "Как я мог пропустить этот трюк? Благодарю за подсказку!",
        comment_reply_id: null,
      },
      {
        author_id: "202",
        problem_id: 28,
        body: "Было трудно, но я нашел путь к решению этой задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "763",
        problem_id: 28,
        body: "Когда я столкнулся с этой задачей впервые, я думал, что это невозможно. Теперь я знаю иначе!",
        comment_reply_id: null,
      },
      {
        author_id: "364",
        problem_id: 28,
        body: "Не могу поверить, что решил это за одну попытку! Сейчас немного в шоке.",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "Interview Question using Two-pointer Approach GO CHECK f 🔥",
        body: "Intuition\n\nGiven an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, we must do this by modifying the input array in-place with O(1) extra memory.\nThe order of elements can be changed. It doesn't matter what you leave beyond the new length.\nApproach\n\nWE HAVE USED TWO POINTER APPROACH:\nbelow is the detail explanation of each line code.\n1. public int removeElement(int[] nums, int val) :\nThis is the method declaration. It takes an integer array nums and an integer val as parameters and returns an integer representing the new length of the array after removing all occurrences of val.\n2. int i=0;:\nInitialize a variable i to keep track of the current position where non-val elements will be placed.\n3. for(int j=0;j<nums.length;j++){:\nIterate through the array using the variable j.\n4. if(nums[j]!=val){:\nCheck if the current element nums[j] is not equal to val.\n5. int temp=nums[i];:\nIf nums[j] is not equal to val, swap nums[i] with nums[j] to move the non-val element to the front of the array.  we have used a temporary variable temp to store the value of nums[i].\n6. nums[i]=nums[j];:\nAssign the value of nums[j] to nums[i].\n7. nums[j]=temp;:\nAssign the value of temp (which is nums[i]) to nums[j].\n8. i++;:\nIncrement i to move to the next position where a non-val element will be placed.\n\nAfter iterating through the entire array, i represents the new length of the array with all instances of val removed. Return i.\n\nDRY RUN:\n\nLet's say we have the following input array nums = [3, 2, 2, 3] and the value val = 3.\n\nHere's how the dry run procedure works step by step:\n\n\nInitialize two pointers, left and right, both pointing to the start of the array: left = 0 and right = 0.\n\n\nIterate through the array with the right pointer until the end of the array:\n\n\na. If nums[right] is equal to val, increment right pointer.\n\n\nb. If nums[right] is not equal to val, set nums[left] equal to nums[right], then increment both left and right pointers.\n\n\nRepeat step 2 until right reaches the end of the array.\n\n\nLet's go through the steps:\n\n\nInitial array: nums = [3, 2, 2, 3], val = 3, left = 0, right = 0.\n\n\nIteration 1: nums[right] is equal to 3, so we increment right.\n\n\nIteration 2: nums[right] is equal to 2, so we copy 2 to nums[left], increment both left and right.\n\n\nArray becomes: [2, 2, 2, 3].\n\n\nIteration 3: nums[right] is equal to 2, so we copy 2 to nums[left], increment both left and right.\n\n\nArray becomes: [2, 2, 2, 3].\n\n\nIteration 4: nums[right] is equal to 3, so we increment right.\n\n\nEnd of array. The loop stops.\n\n\nResulting array: [2, 2, 2, 3], and left points to index 2.\n\n\nThe length of the new array is left, which is 3.\n\n\nComplexity\n\nTime complexity:O(N)\n\n\nAs we have used Two Pointer Approach it's order of N\n\nSpace complexity:O(1)\n\n\nAs we haven't used any extra space we it's constant\nCode\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int i=0;\n        for(int j=0;j<nums.length;j++){\n            if(nums[j]!=val){\n                int temp=nums[i];\n                nums[i]=nums[j];\n                nums[j]=temp;\n                i++;\n            }\n\n        }\n        return i;\n    }\n}\n        \nPythonclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        i = 0\n        for j in range(len(nums)):\n            if nums[j] != val:\n                nums[i], nums[j] = nums[j], nums[i]\n                i += 1\n        return i\n",
        views: "1011",
        upvotes: "12",
        author_id: "600",
        problem_id: 28,
      },
      {
        title:
          "✅Best 100% || C++ || JAVA || PYTHON || Beginner Friendly🔥🔥🔥",
        body: "Intuition\n\nThe intuition behind this solution is to iterate through the array and keep track of two pointers: index and i. The index pointer represents the position where the next non-target element should be placed, while the i pointer iterates through the array elements. By overwriting the target elements with non-target elements, the solution effectively removes all occurrences of the target value from the array.\nApproach\n\n\nInitialize index to 0, which represents the current position for the next non-target element.\nIterate through each element of the input array using the i pointer.\nFor each element nums[i], check if it is equal to the target value.\n\nIf nums[i] is not equal to val, it means it is a non-target element.\nSet nums[index] to nums[i] to store the non-target element at the current index position.\nIncrement index by 1 to move to the next position for the next non-target element.\n\n\nContinue this process until all elements in the array have been processed.\nFinally, return the value of index, which represents the length of the modified array.\n\nComplexity\n\nTime complexity:\n\n\nO(n)O(n)O(n)\n\nSpace complexity:\n\n\nO(1)O(1)O(1)\nCode\nC++JavaPython3class Solution {\r\npublic:\r\n    int removeElement(vector<int>& nums, int val) {\r\n        int index = 0;\r\n        for(int i = 0; i< nums.size(); i++){\r\n            if(nums[i] != val){\r\n                nums[index] = nums[i];\r\n                index++;\r\n            }\r\n        }\r\n        return index;\r\n    }\r\n};\n\nIf you are a beginner solve these problems which makes concepts clear for future coding:\n\nTwo Sum\nRoman to Integer\nPalindrome Number\nMaximum Subarray\nRemove Element\nContains Duplicate\nAdd Two Numbers\nMajority Element\nRemove Duplicates from Sorted Array\nPractice them in a row for better understanding and please Upvote for more questions.\n\nIf you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.",
        views: "265456",
        upvotes: "1.6K",
        author_id: "849",
        problem_id: 28,
      },
      {
        title: "Without using pointer",
        body: "#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        nums.erase(remove(nums.begin(), nums.end(), val), nums.end());\n        return nums.size();\n    }\n};```",
        views: "955",
        upvotes: "1",
        author_id: "69",
        problem_id: 28,
      },
      {
        title: "✅ RUST 0ms ✅ BEATS 100% USERS 🔥",
        body: "Intuition\nBe better\nApproach\nCode better\nComplexity\n\n\nTime complexity:\nim a simple man 🦧\n\n\nSpace complexity:\nF(x)=∫−∞∞​(e2x2​2π\n)⋅(∑k=0⌊x⌋​k!xk​)dx∑n=0∞​(2n(−1)n​)⋅((2n+1)!x2n+1​)​+limn→∞​nn!\n​∑i=1n​(i21​)⋅(∏j=1i​(1+j1​))​  -> ill let yall do the math its pretty simple\n\n\nCode\nimpl Solution {\n    pub fn remove_element(nums: &mut Vec<i32>, val: i32) -> i32 {  \n       nums.retain(|&x| x != val);\n       nums.len() as i32\n    }\n}",
        views: "1615",
        upvotes: "1",
        author_id: "967",
        problem_id: 28,
      },
    ],
  },
  {
    title: "28. Find the Index of the First Occurrence in a String",
    description:
      'Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n\n \nExample 1:\n\nInput: haystack = "sadbutsad", needle = "sad"\nOutput: 0\nExplanation: "sad" occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.\n\n\nExample 2:\n\nInput: haystack = "leetcode", needle = "leeto"\nOutput: -1\nExplanation: "leeto" did not occur in "leetcode", so we return -1.\n\n\n \nConstraints:\n\n\n\t1 <= haystack.length, needle.length <= 104\n\thaystack and needle consist of only lowercase English characters.\n\n',
    difficulty: "Easy",
    acceptance: "43.15",
    frequency: "0.86",
    topics: [
      [
        "Array",
        "Iterator",
        "Memoization",
        "Collapse",
        "Geometry",
        "Concurrency",
        "Backtracking",
        "Data Stream",
        "Eulerian Circuit",
        "Rejection Sampling",
      ],
    ],
    languages: [
      [
        "C",
        "JavaScript",
        "Erlang",
        "Scala",
        "Python",
        "Ruby",
        "Kotlin",
        "Swift",
        "C#",
        "Racket",
      ],
    ],
    comments: [
      {
        author_id: "7",
        problem_id: 29,
        body: "Наконец-то, я разобрался с этой задачей! Спасибо за все подсказки.",
        comment_reply_id: null,
      },
      {
        author_id: "701",
        problem_id: 29,
        body: "Это было как головоломка, но я нашел свой путь к решению!",
        comment_reply_id: null,
      },
      {
        author_id: "943",
        problem_id: 29,
        body: "Идея для этого решения пришла ко мне во сне! Удивительно, как мозг работает иногда.",
        comment_reply_id: null,
      },
      {
        author_id: "141",
        problem_id: 29,
        body: "Эта задача заставила меня использовать все свои ресурсы!",
        comment_reply_id: null,
      },
      {
        author_id: "414",
        problem_id: 29,
        body: "Какие интересные подходы у других людей к этой задаче",
        comment_reply_id: null,
      },
      {
        author_id: "204",
        problem_id: 29,
        body: "Эта задача заставила меня подумать вне коробки. Очень интересное решение!",
        comment_reply_id: null,
      },
      {
        author_id: "130",
        problem_id: 29,
        body: "Сколько времени я потратил на решение этой задачи? Не считаясь!",
        comment_reply_id: null,
      },
      {
        author_id: "74",
        problem_id: 29,
        body: "Не могу поверить, что я решил это без помощи Google!",
        comment_reply_id: null,
      },
      {
        author_id: "930",
        problem_id: 29,
        body: "Чувствую себя чемпионом после этой задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "258",
        problem_id: 29,
        body: "Сложно даже представить, сколько попыток ушло на решение этой задачи.",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "[VIDEO] Visualization of O(n) KMP Algorithm",
        body: "\nThe KMP algorithm improves the brute force algorithm from O(m*n) to O(m+n) and consists of two parts.  The first part is the preprocessing step, where we find the length of \"the longest proper prefix that is also a suffix\" for every prefix in needle.\nThe second part is the main algorithm, where we compare needle and haystack letter-by-letter.  If two characters match, we move both pointers up and see how far we can keep going.  If they don't match, then we use the array created in the preprocessing step to determine how far to move up needle to compare the next characters.  For a detailed explanation, please see the video - it's very difficult to explain without visuals.  But the idea is that when traversing needle and hitting a mismatch, we know that any proper prefixes that are also a suffix will overlap, so we can skip those characters.\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        lps = [0] * len(needle)\n\n        # Preprocessing\n        pre = 0\n        for i in range(1, len(needle)):\n            while pre > 0 and needle[i] != needle[pre]:\n                pre = lps[pre-1]\n            if needle[pre] == needle[i]:\n                pre += 1\n                lps[i] = pre\n\n        # Main algorithm\n        n = 0 #needle index\n        for h in range(len(haystack)):\n            while n > 0 and needle[n] != haystack[h]:\n                n = lps[n-1]\n            if needle[n] == haystack[h]:\n                n += 1\n            if n == len(needle):\n                return h - n + 1\n\n        return -1",
        views: "191",
        upvotes: "6",
        author_id: "352",
        problem_id: 29,
      },
      {
        title: "✅ Java | Easy | With Explanation",
        body: "If we observe a bit the number of substrings of size needle length is length of haystack minus length of needle+1 so using two pointer we just used a for loop till (length of haystack-length of needle) and then checked if the character in needle is equal to character of haystack. If its equal we just kept on incrementing j. If the j is equal to needle length then we found our first substring that is equal to needle and we return the index of first character of that substring. If we dont find the substring in the haystack then we simply return -1.\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        int haylength=haystack.length();\n        int needlelength=needle.length();\n        if(haylength<needlelength)\n            return -1;\n        for(int i=0;i<=haystack.length()-needle.length();i++){\n            int j=0;\n            while(j<needle.length() && haystack.charAt(i+j)==needle.charAt(j))\n                j++;\n            if(j==needle.length()){\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n",
        views: "102795",
        upvotes: "546",
        author_id: "27",
        problem_id: 29,
      },
      {
        title:
          "Beats 100% With this easy Solution in Java || Python || C++ || C# 🔥🔥😊",
        body: "\nIntuition\n\nThe function is trying to find the index of the first occurrence of the needle string within the haystack string. If the needle is not found in the haystack, it returns -1.\nApproach\n\n\n\nUse a loop to iterate through the haystack string. The loop starts at index i = 0 and goes up to i = haystack.length() - needle.length(). This is done to ensure that there are enough characters left in the haystack for the needle to fit.\n\n\nWithin the loop, check substrings of length equal to the length of the needle starting from the current index i up to i + needle.length(). If any of these substrings matches the needle, return the current index i.\n\n\nIf the loop completes without finding a match, return -1.\n\n\nComplexity\n\nTime complexity: O(n * m)\n\n\n\nSpace complexity: O(1)\n\n\nCode\nJavaPythonC++C#class Solution {\n    public int strStr(String haystack, String needle) {\n        for(int i = 0, j = needle.length(); j<=haystack.length(); i++,j++){\n            if(haystack.substring(i,j).equals(needle)){\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n",
        views: "24091",
        upvotes: "101",
        author_id: "193",
        problem_id: 29,
      },
      {
        title: "Easy Solution with explaination",
        body: 'Intuition\nOne pointer for both strings\nApproach\n\nSimply start with taking two pointers on both strings at 0 index and put some conidition so that count gets equal to length of second string.\n"mississippi" Be careful of this case as above approach fails here. Take example as "isso" is required but we have not maintanied any condition what if breaks in between and required string is between that.\nThink! Don\'t Give up, You\'re very close\nHere we iterates through each character in the haystack and checks if it matches the first character of the needle. If it does, it proceeds to check subsequent characters in both strings. If a mismatch occurs, it employs a sliding window technique to backtrack efficiently, but it may still require redundant comparisons, resulting in a time complexity of O(n * m) in the worst case.\nAfter solving this study about Knuth-Morris-Pratt (KMP) algorithm or Boyer-Moore algorithm for linear solution.\n\nComplexity\n\n\nTime complexity:\nO(n * m)\n\n\nSpace complexity:\nO(1)\n\n\nCode\nclass Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        int i=0,j=0;\n        int len1 = haystack.length();\n        int len2 = needle.length();\n        int count = 0;\n        int store;\n        while(i<len1){\n            cout<<"i = "<<i<<endl;\n            char ch1 = haystack[i];\n            char ch2 = needle[j];\n            \n            if(ch1 == ch2){\n                i++;\n                j++;\n                count++;\n                if(count == 1){\n                    store = i;\n                    cout<<"in";\n                }\n                if(count == len2){\n                    return i-len2;\n                }\n            }\n            else if(count>0){\n                i = store;\n                count = 0;\n                cout<<"in";\n                j=0;\n            }\n            else{\n                cout<<"inelse";\n                i++;\n                j=0;\n                count=0;\n            }\n        }\n        return -1;\n    }\n};',
        views: "277",
        upvotes: "1",
        author_id: "401",
        problem_id: 29,
      },
    ],
  },
  {
    title: "29. Divide Two Integers",
    description:
      "Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n\nThe integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\n\nReturn the quotient after dividing dividend by divisor.\n\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231.\n\n \nExample 1:\n\nInput: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. which is truncated to 3.\n\n\nExample 2:\n\nInput: dividend = 7, divisor = -3\nOutput: -2\nExplanation: 7/-3 = -2.33333.. which is truncated to -2.\n\n\n \nConstraints:\n\n\n\t-231 <= dividend, divisor <= 231 - 1\n\tdivisor != 0\n\n",
    difficulty: "Medium",
    acceptance: "60.28",
    frequency: "151.02",
    topics: [
      [
        "Depth-First Search",
        "Iterator",
        "Simulation",
        "Monotonic Stack",
        "Greedy",
        "Binary Search Tree",
        "Concurrency",
        "Shell",
        "Topological Sort",
        "Randomized",
      ],
    ],
    languages: [
      [
        "Rust",
        "Swift",
        "Java",
        "Scala",
        "Dart",
        "C",
        "Racket",
        "C#",
        "JavaScript",
        "Python3",
      ],
    ],
    comments: [
      {
        author_id: "775",
        problem_id: 30,
        body: "Теперь я чувствую, что могу решить что угодно!",
        comment_reply_id: null,
      },
      {
        author_id: "29",
        problem_id: 30,
        body: "Иногда простые решения лучше всех! Не всегда нужно усложнять.",
        comment_reply_id: null,
      },
      {
        author_id: "259",
        problem_id: 30,
        body: "Вот почему я люблю программирование - за такие интересные задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "943",
        problem_id: 30,
        body: "Мой мозг сейчас в кипении от этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "428",
        problem_id: 30,
        body: "Я не знал, что это возможно, пока не попробовал! Это было удивительно!",
        comment_reply_id: null,
      },
      {
        author_id: "10",
        problem_id: 30,
        body: "У кого-нибудь есть идеи, как можно оптимизировать мое решение? Пока я не совсем доволен своим подходом.",
        comment_reply_id: null,
      },
      {
        author_id: "177",
        problem_id: 30,
        body: "У кого-нибудь есть идеи, как можно оптимизировать мое решение? Пока я не совсем доволен своим подходом.",
        comment_reply_id: null,
      },
      {
        author_id: "856",
        problem_id: 30,
        body: "Как я мог не догадаться о таком подходе? Спасибо за отличное объяснение!",
        comment_reply_id: null,
      },
      {
        author_id: "457",
        problem_id: 30,
        body: "У кого-нибудь есть идеи, как можно оптимизировать мое решение? Пока я не совсем доволен своим подходом.",
        comment_reply_id: null,
      },
      {
        author_id: "193",
        problem_id: 30,
        body: "Как я мог не догадаться о таком подходе? Спасибо за отличное объяснение!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title:
          "Complete Thinking Process | Intuitive Explanation | All rules followed | C++ code",
        body: "Explanation:\n\tdividend = (quotient) * divisor + remainder\nWe have to find the quotient in this equation and we are given divisor and dividend.\nAny number can be represented in binary form. Same goes for quotient :\nLet us have an example: 58/5:\n58 = (11) * 5 + 3\nRepresenting the quotient in binary form:  (11)10 = (1011)2:\n\t58 = (2^3 + 2^1 + 2^0) * 5 + 3                // --- (I)\n\t58 = [(2^3 * 5) + (2^1 * 5) + (2^0 * 5)] + 3  // --- (II)\nSince we dont know the quotient and remainder the equation we know is:\n58 = (q) * 5 + rem\nWe get a hint at what we would like to do here. We will first multiply 5 with maximum power of 2 such that the resulting number is still smaller than the dividend (read further if you don't understand why). Since multiplication operator is not allowed, we would use bitwise left shift to achieve this multiplication: each time we shift 5 by 1, we multiply it by 2:\n\t5 << 0 = 5               // less than dividend\n\t5 << 1 = 5*2 = 10        // less than dividend\n\t5 << 2 = 5*2*2 = 20      // less than dividend\n\t5 << 3 = 5*2*2*2 = 40    // less than dividend\n\t5 << 4 = 5*2*2*2*2 = 80  // (stop and consider the previous value as the result is greater than dividend\nWe observe that:\n58 = (2^3 * 5) + (something * 5) + rem      // --- (III)\nYou can see we are getting close to the equation we initialy wanted (eqa II).\nSince 5 is multiplied with 23, we add 23 to our answer.\nFurther operating on equation III:\n\t58 - (2^3 * 5)  =  (something * 5) + rem\n\t58 - (8 * 5) = something * 5 + rem\n\t58 - 40 = something * 5 + rem\n\t18 = something * 5 + rem\nWhat we effectively have done is, subtracted the result we got from our first step from dividend (58 - 40).\nWe arived at the same question again but with a smaller dividend this time.\ndividend = 18, divisor = 5\nTherefore let us repeat the process:\n\t5 << 0 = 5           // less than dividend\n\t5 << 1 = 5*2 = 10    // less than dividend\n\t5 << 2 = 5*2*2 = 20  // (stop and consider the previous value as the result is greater than dividend\nWe add  21 to our answer.\nLooking back:\n\t18  =  (2^1 * 5) + (something * 5) + rem\n\t58 - (2^3 * 5) = (2^1 * 5) + (something * 5) + rem\n\t58 =  (2^3 * 5) + (2^1 * 5) + (something * 5) + rem\nYou can notice we are gradually advancing towards equ II:\nOur new dividend is now:\n\t18 - (2^1 * 5)  =  (something * 5) + rem\n\t18 - (2 * 5) = something * 5 + rem\n\t18 - 10 = something * 5 + rem\n\t8 = something * 5 + rem\ndividend = 8, divisor = 5\nRepeating the process:\n\t5 << 0 = 5           // less than dividend\n\t5 << 1 = 5*2 = 10    // (stop and consider the previous value as the result is greater than dividend\nWe add  20 to our answer.\nNew dividend:\n\t8 = (2^0 * 5) + (something * 5) + rem\n\t8 - 5 = something * 5 + rem\n\t3 = something * 5 + rem\ndividend = 3, divisor = 5\nAt this step, we stop iterating as our dividend is less than the divisor (we have also found our remainder = 3, as 5 should be multiplied with 0 and what remains is the remainder).\nLooking back again for the last time:\n\t3 = 0*5 + rem\n\t8 = (2^0 * 5) + 3\n\t18  =  (2^0 * 5) + (2^1 * 5) + 3\n\t58 = (2^3 * 5) + (2^1 * 5) + (2^0 * 5) + 3\nIn the process, we have finally reached the equation we wanted to, and have got the answer as:\nquotient = (2^3 + 2^1 + 2^0)\nCode:\nSince we are not allowed to have any numerical data type bigger than 32 bit integer, we will use the last bit reserved for sign to avoid overflow by using the unsinged int in c++:\n\tint divide(int dividend, int divisor) {\n        if(dividend == divisor)\n            return 1;\n        bool isPositive = (dividend<0 == divisor<0);    // if both are of same sign, answer is positive\n        unsigned int a = abs(dividend);\n        unsigned int b = abs(divisor);\n        unsigned int ans = 0;\n        while(a >= b){  // while dividend is greater than or equal to divisor\n            short q = 0;\n            while(a > (b<<(q+1)))\n                q++;\n            ans += (1<<q);  // add the power of 2 found to the answer\n            a = a - (b<<q);  // reduce the dividend by divisor * power of 2 found\n        }\n        if(ans == (1<<31) and isPositive)   // if ans cannot be stored in signed int\n            return INT_MAX;\n        return isPositive ? ans : -ans;\n    }\nPlease upvote if you find this helpful, or if you think someone else might find it useful :)",
        views: "70387",
        upvotes: "1.2K",
        author_id: "786",
        problem_id: 30,
      },
      {
        title:
          "Best C++ solution  6ms ||Without using 'long int *  /  % operator|| Within Signed Integer Enviroment",
        body: "Approach\nMy Approach is same as how we divide two integer by INDIAN method of dividing integer\nFOR EX.\nINDAN METHOD___\n321)45667(142\nCode\nclass Solution {\npublic:\n  string remainder(string &s1,int num, int divisor)\n{\n  if(num<divisor)\n  {\n  s1.push_back('0');\n  return to_string(num);\n  }\n  int diff=num;\n  if(num>=divisor)\n  {\n    int count=0;\n      while(diff>=divisor)\n      {\n          count++;diff=diff-divisor;\n      }\n      s1.insert(s1.size(),to_string(count));\n  }\n  return to_string(diff);\n}\nint divide(int dividend, int divisor) {\n   int sign=0;\n  if(divisor==INT_MIN){\n  if(dividend==INT_MIN){\n  return 1;\n  }\n  return 0;\n  }\n  if(dividend<0||divisor<0)\n  {\n    if(dividend<0&&divisor<0)\n    {}\n    else\n    sign=1;\n  }\n  int check=0;\n  if(dividend==INT_MIN)\n  {\n    check=1;\n    dividend=abs(dividend+1);}\n  else\n  dividend=abs(dividend);\n  divisor=abs(divisor);\n  if(divisor==1)\n  {\n    if(sign==0)\n    return dividend;\n    else if(sign==1&&check==1)\n    return -dividend-1;\n    else\n      return -dividend;\n  }\n  if(dividend<divisor)\n  {\n    return 0;\n  }\n   string s=to_string(dividend);\n  string s1=\"\";\n  int size=to_string(divisor).size();\n  string remain=s.substr(0,size-1);\n  int i=size-1;\n  while(i<s.size())\n    {\n      string s2=remain+s.substr(i,1);\n      remain=remainder(s1,stoi(s2),divisor);\n      i++;\n    }\n  if(check==1)\n  {\n    if(stoi(remain)+1==divisor)\n    {\n      if(sign==1)\n        {\n          return -stoi(s1)-1;\n        }\n        return stoi(s1)+1;\n    }\n  }\n    if(sign==1)\n  {\n    return -stoi(s1);\n  }\n  return stoi(s1);\n}\n};",
        views: "719",
        upvotes: "3",
        author_id: "109",
        problem_id: 30,
      },
      {
        title: "C++ bit manipulations",
        body: "The key observation is that the quotient of a division is just the number of times that we can subtract the divisor from the dividend without making it negative.\nSuppose dividend = 15 and divisor = 3, 15 - 3 > 0. We now try to subtract more by shifting 3 to the left by 1 bit (6). Since 15 - 6 > 0, shift 6 again to 12. Now 15 - 12 > 0, shift 12 again to 24, which is larger than 15. So we can at most subtract 12 from 15. Since 12 is obtained by shifting 3 to left twice, it is 1 << 2 = 4 times of 3. We add 4 to an answer variable (initialized to be 0). The above process is like 15 = 3 * 4 + 3. We now get part of the quotient (4), with a remaining dividend 3.\nThen we repeat the above process by subtracting divisor = 3 from the remaining dividend = 3 and obtain 0. We are done. In this case, no shift happens. We simply add 1 << 0 = 1 to the answer variable.\nThis is the full algorithm to perform division using bit manipulations. The sign also needs to be taken into consideration. And we still need to handle one overflow case: dividend = INT_MIN and divisor = -1.\nclass Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        if (dividend == INT_MIN && divisor == -1) {\n            return INT_MAX;\n        }\n        long dvd = labs(dividend), dvs = labs(divisor), ans = 0;\n        int sign = dividend > 0 ^ divisor > 0 ? -1 : 1;\n        while (dvd >= dvs) {\n            long temp = dvs, m = 1;\n            while (temp << 1 <= dvd) {\n                temp <<= 1;\n                m <<= 1;\n            }\n            dvd -= temp;\n            ans += m;\n        }\n        return sign * ans;\n    }\n};",
        views: "201643",
        upvotes: "1.3K",
        author_id: "669",
        problem_id: 30,
      },
      {
        title: "EASY JAVA O(logN) SOLUTION || BIT MANIPULATION",
        body: "Approach:\nThis solution implements integer division without using division, multiplication, or modulo operators. It simulates division by shifting the divisor leftward (multiplication) and subtracting it from the dividend until the dividend becomes smaller than the divisor.\nExplanation with Example:\nConsider the following example:\ndividend = 10, divisor = 3\n1. Initialization:\n\nInitialize variables n (quotient), c (current quotient value), and sign (sign of the result).\nCheck if the divisor is 1. If so, return the dividend itself, as dividing any number by 1 results in the number itself.\nDetermine the sign of the result based on the signs of the dividend and divisor.\n\n2. Calculation:\n\nCalculate the absolute values of the dividend and divisor: dd = |10| = 10 and dr = |3| = 3.\nIterate from the 30th bit (leftmost bit) to the 0th bit of the divisor.\n\nFor each bit position i, check if c * (dr << i) is less than or equal to dd.\nIf it is, add 1 << i to the current quotient value c and subtract (dr << i) from the dividend dd.\n\n\nAfter the iteration, c represents the quotient value.\n\n3. Final Result:\n\nMultiply the quotient value c by the sign to account for the sign of the result.\nReturn the final result.\n\nExample Calculation:\n\nIteration 1 (i = 30):\n\nCheck if c * (dr << 30) <= dd: No\n\n\nIteration 2 (i = 29):\n\nCheck if c * (dr << 29) <= dd: No\n...\n\n\nIteration 4 (i = 27):\n\nCheck if c * (dr << 27) <= dd: Yes\nAdd 1 << 27 (134217728) to c\nSubtract (dr << 27) (1610612736) from dd\n\n\nAfter the iteration, c is updated to 134217728, representing the quotient.\n\nTime Complexity:\n\nThe time complexity of this solution is O(log(dividend)) because the loop iterates at most 31 times (for 32-bit integers), performing bitwise operations.\n\nSpace Complexity:\n\nThe space complexity is O(1) as the function uses only a constant amount of extra space.\n\nclass Solution {\n    public int divide(int dividend, int divisor) {\n        int n = 0;\n        long c = 0;\n        long sign = 1;\n        if (divisor == 1) return dividend;\n        if ((dividend < 0 && divisor >= 0) || (dividend >= 0 && divisor < 0)) sign = -1;\n        long dd = Math.abs((long) dividend);\n        long dr = Math.abs((long) divisor);\n        for (int i = 30; i >= 0; i--) {\n            if (dd >= (dr << i)) {\n                c += (1 << i);\n                dd -= (dr << i);\n            }\n        }\n        return (int) (c * sign);\n    }\n}\n",
        views: "670",
        upvotes: "3",
        author_id: "475",
        problem_id: 30,
      },
    ],
  },
  {
    title: "30. Substring with Concatenation of All Words",
    description:
      'You are given a string s and an array of strings words. All the strings of words are of the same length.\n\nA concatenated string is a string that exactly contains all the strings of any permutation of words concatenated.\n\n\n\tFor example, if words = ["ab","cd","ef"], then "abcdef", "abefcd", "cdabef", "cdefab", "efabcd", and "efcdab" are all concatenated strings. "acdbef" is not a concatenated string because it is not the concatenation of any permutation of words.\n\n\nReturn an array of the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n\n \nExample 1:\n\n\nInput: s = "barfoothefoobarman", words = ["foo","bar"]\n\nOutput: [0,9]\n\nExplanation:\n\nThe substring starting at 0 is "barfoo". It is the concatenation of ["bar","foo"] which is a permutation of words.\nThe substring starting at 9 is "foobar". It is the concatenation of ["foo","bar"] which is a permutation of words.\n\n\nExample 2:\n\n\nInput: s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]\n\nOutput: []\n\nExplanation:\n\nThere is no concatenated substring.\n\n\nExample 3:\n\n\nInput: s = "barfoofoobarthefoobarman", words = ["bar","foo","the"]\n\nOutput: [6,9,12]\n\nExplanation:\n\nThe substring starting at 6 is "foobarthe". It is the concatenation of ["foo","bar","the"].\nThe substring starting at 9 is "barthefoo". It is the concatenation of ["bar","the","foo"].\nThe substring starting at 12 is "thefoobar". It is the concatenation of ["the","foo","bar"].\n\n\n \nConstraints:\n\n\n\t1 <= s.length <= 104\n\t1 <= words.length <= 5000\n\t1 <= words[i].length <= 30\n\ts and words[i] consist of lowercase English letters.\n\n',
    difficulty: "Hard",
    acceptance: "46.79",
    frequency: "98.90",
    topics: [
      [
        "String",
        "Memoization",
        "Rejection Sampling",
        "Collapse",
        "Bitmask",
        "Enumeration",
        "Monotonic Queue",
        "Stack",
        "Sorting",
        "Binary Indexed Tree",
      ],
    ],
    languages: [
      [
        "Swift",
        "Elixir",
        "Python3",
        "PHP",
        "Scala",
        "C#",
        "Java",
        "JavaScript",
        "Python",
        "Kotlin",
      ],
    ],
    comments: [
      {
        author_id: "834",
        problem_id: 31,
        body: "Это было круто! Какая следующая задача?",
        comment_reply_id: null,
      },
      {
        author_id: "355",
        problem_id: 31,
        body: "Мой мозг сейчас в кипении от этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "793",
        problem_id: 31,
        body: "Я просто в восторге от того, как эффективно работает мое решение!",
        comment_reply_id: null,
      },
      {
        author_id: "157",
        problem_id: 31,
        body: "Всегда думал, что эта задача невозможна. Но вот я, сделал это!",
        comment_reply_id: null,
      },
      {
        author_id: "938",
        problem_id: 31,
        body: "Эта задача была настоящим испытанием ума! Сложность на высшем уровне.",
        comment_reply_id: null,
      },
      {
        author_id: "605",
        problem_id: 31,
        body: "Эта задача вынудила меня глубже погрузиться в язык программирования.",
        comment_reply_id: null,
      },
      {
        author_id: "485",
        problem_id: 31,
        body: "Сложно даже представить, сколько попыток ушло на решение этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "997",
        problem_id: 31,
        body: "Мой мозг сейчас в кипении от этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "283",
        problem_id: 31,
        body: "Не могу поверить, что я наконец-то разобрался с этой задачей. Спасибо, сообщество!",
        comment_reply_id: null,
      },
      {
        author_id: "240",
        problem_id: 31,
        body: "Какие интересные подходы у других людей к этой задаче",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "C++ optimal solution. Clean code, commented and explained",
        body: 'Intuition\nUsing hash sets or maps here seems like a good idea. We could have a set of words, copy it on each search attempt, and as long as we keep finding current words in it, we remove them from the set.\nAnother idea is to leverage the fact that all strings in words come equally sized, so the word length stays constant.\nApproach\nIn my approach, we are going to use hash maps because it\'s a bit easier. We will have a reference map, where it\'s noted which word and how many times it should be repeated.\nThe next step is to iterate through s as many times as the length of each string in words with different word offset. Let me illustrate this with an example.\nImagine we have a string "abbarfoofoobarthe" and words are ["foo", "bar", "the"]. The length of eache word is 3, so we need 3 iterations. They symbolize the splits we make in the string s:\n\nabb arf oof oob art he\na bba rfo ofo oba rth e\nab bar foo foo bar the\nThis way, in the inner cycle, we can iterate with bigger steps and use a sliding window.\n\nThe last step is to use a sliding window. Here is how it\'s going to work:\n\nWe define a hash map to keep track of how many times we have seen each word.\nWe define a sliding window size to keep track of how many words from the words array we have managed to use in our sliding window so far.\nWe assume that the sliding window is valid; as soon as we find any condition that makes it invalid, we deal with it.\nOn each iteration, we take a slice of s from the current index and check if this word exists in the reference map; if it does not, we clear our window and move on.\nIf the candidate word exists in the reference map, we increment the number of occurrences of this word in our seen map.\nIf we check this amount against the reference, and if it\'s bigger, we need to shrink our window from the left until the condition is satisfied.\nNaturally, the sliding window will grow to the right, so when its size reaches the size of the words array, we have found the correct position, and we record the left side of the window to the result array.\n\nComplexity\n\nTime complexity: O(n×length)O(n \\times length)O(n×length) where n is the size of s and length is the length of each word in words.\nSpace complexity: O(m×length)O(m \\times length)O(m×length) where m is the size of words and length is the length of each word in words.\n\nSolution with Comments\nclass Solution {\n    // This is the reference map.\n    std::unordered_map<std::string, unsigned int> map;\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        std::vector<int> result;\n\n        // Length of each word in words.\n        unsigned int length = words[0].size();\n\n        // Initializing the reference map.\n        map.clear();\n        for (const std::string& word : words)\n            map[word]++;\n\n        // Iterate for each offset\n        // As many times as the number of characters in each word.\n        for (unsigned int offset = 0; offset < length; ++offset) {\n            // Sliding window size.\n            unsigned int size = 0;\n            // Sliding window memory.\n            std::unordered_map<std::string, unsigned int> seen;\n\n            // Iterate over the string, with the step equals to length.\n            for (unsigned int i = offset; i + length <= s.size(); i += length) {\n                // This is the word we\'re going to check.\n                std::string sub = s.substr(i, length);\n\n                // If the word is absent in the reference map,\n                // we clear the sliding window and move on.\n                auto itr = map.find(sub);\n                if (itr == map.end()) {\n                    seen.clear();\n                    size = 0;\n                    continue;\n                }\n\n                // Increase the number of occurrences\n                // of the word in seen map.\n                ++seen[sub];\n                ++size;\n\n                // To make sure the sliding window is valid,\n                // we need to check only the recent occurrence\n                // against the reference,\n                // because previous occurrences\n                // were checked on previous iterations.\n                while (seen[sub] > itr->second) {\n                    // If the occurrences amount exceeds\n                    // the reference amount,\n                    // we shrink the window from the left until\n                    // the window becomes valid again.\n\n                    // A word at the beginning of the current sliding window.\n                    std::string first = s.substr(i - (size - 1) * length, length);\n\n                    // Remove the occurrence from the window,\n                    // shrinking it from the left.\n                    --seen[first];\n                    --size;\n                }\n                \n                // If we used all words from the words array,\n                // we have found the correct spot\n                // and we need to calculate the beginning\n                // index of the current sliding window.\n                if (size == words.size())\n                    result.push_back(i - (size - 1) * length);\n            }\n        }\n\n        return result;\n    }\n};\nSolution without Comments\nclass Solution {\n    std::unordered_map<std::string, unsigned int> map;\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        std::vector<int> result;\n        unsigned int length = words[0].size();\n\n        map.clear();\n        for (const std::string& word : words)\n            map[word]++;\n\n        for (unsigned int offset = 0; offset < length; ++offset) {\n            unsigned int size = 0;\n            std::unordered_map<std::string, unsigned int> seen;\n            for (unsigned int i = offset; i + length <= s.size(); i += length) {\n                std::string sub = s.substr(i, length);\n\n                auto itr = map.find(sub);\n                if (itr == map.end()) {\n                    seen.clear();\n                    size = 0;\n                    continue;\n                }\n\n                ++seen[sub];\n                ++size;\n                while (seen[sub] > itr->second) {\n                    std::string first = s.substr(i - (size - 1) * length, length);\n                    --seen[first];\n                    --size;\n                }\n                \n                if (size == words.size())\n                    result.push_back(i - (size - 1) * length);\n            }\n        }\n\n        return result;\n    }\n};',
        views: "1719",
        upvotes: "11",
        author_id: "402",
        problem_id: 31,
      },
      {
        title:
          "[C++] Unordered_map & Sliding Window | Simple & easy to understand",
        body: "Approach :  We are using Hashing & Sliding Window Technique to solve the above problem.\nLet’s see the steps :\n\nDeclare a map wordCount which stores all words count\nSelect a window of size wordsWindow (total number of characters produced if all the words are concatenated).\nCheck if that window is possible to build using our wordCount map.\nIf True, add the starting index to our result vector\nIncreasing the window by 1 & check until we are able to select wordsWindow size window.\n\nclass Solution {\npublic:\n    \n    bool checkSubstring(unordered_map<string, int> wordCount, string s, int wordLen) {\n        for(int j=0; j<s.size(); j+=wordLen) {\n            string w = s.substr(j, wordLen);\n            if(wordCount.find(w) != wordCount.end()) {\n                if(--wordCount[w] == -1) {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> res;\n        int wordLen = words[0].size();\n        int sLen = s.size();\n        int wordsWindow = words.size() * wordLen;\n        \n        unordered_map<string, int> wordCount;\n        for(int i=0; i<words.size(); i++) {\n            wordCount[words[i]]++;\n        }\n        \n        int i = 0;\n        while(i + wordsWindow <= sLen) {\n            if(checkSubstring(wordCount, s.substr(i, wordsWindow), wordLen)) {\n                res.push_back(i);\n            }\n            i++;\n        }\n        return res;\n    }\n};",
        views: "27006",
        upvotes: "116",
        author_id: "870",
        problem_id: 31,
      },
      {
        title:
          "Clear solution! Easy to understand with diagrams ! O(n x w) approach",
        body: 'Let\'s just take one example for reference:\nInput:\ns = "wordbestgoodwordword", words = ["word","good","best","word"]\nlet w be the length of each word in words array.\nlet m be the length of words array.\nlet n be the lenth of s string.\nNow let\'s define a subproblem(i) as whether index i is present in our answer or not ? (let\'s take i = 0 for example)\nNow, index i will be present in our answer if substring of s ( i,  i+(m x w) ), if broken to w length pieces, contains all the words in the words array in any order.\n\nSo, in a standard brute force approach how can we just solve subproblem(i) ???\nCreate a hashmap storing what all is present in words array.\nStart from index i consumng w length m sub-strings, storing in another hashmap to keep track of what is observed.\nif two hash-maps match at the end, subproblem(i) tells i should be present in our answer.\nQuick time complexity check for solving a single subproblem(i) is O(w x m)\nThis is very easy, and I hope everyone reached till here.\nNow, we can finally solve subproblem(i) like above for each possible i the s string, ie i can range from 0 to n-1,\nQuick time complexity check for solving a single subproblem(i) is O(n x (w x m)). Now this is cubic complexity and we do not want this.\nNow, always remember whenever we want to optimise an approach, we want to re-use already done computations.\nCan we re-use previously done computations in this problem ???\nLet us assume we solved the sub-problem(i), where can be re-use it:\nNow, while solving the sub-problem(i), we generate a hash-map of observed words. Can we reuse this hash-map for other sub-problems ??\n\nNow let\'s see how the sub-problem(i+1) looks ?\n\nNow the hash-map created in sub-problem(i) cannot be used in sub-problem(i+1) because w length words have completely changed now.\nBut, the hash-map created in sub-problem(i), can be re-used (after removing w length word starting with i) for sub-problem(i+w) because intermediate 3 words of length w remain same.\n\nSo, computations made in subproblem(i) can be re-used in sub-problem(i+w).\nSimilarly, computations made in subproblem(i+w) can be re-used in sub-problem(i+2 x w)\n i  ---> i+w ---> i+2w ----> i+3w ----> i+4w  (These all can re-use their computations)\n \nQuick, time complexity check:\nsolving for sub-problems i, i+w, i+2xw,..... sequentially would require O(n) time complexity.\nfor solving sub-problem(i), it took us O(m x w).\nfor next sub-problem(i+w), it took us just O(w), removing initial w character, adding latter w character.\nso, to solve all problems, we effectively consume all array elements atmost O(1)\nSo, total time complexity for this is O(n)\nSimilarly, we can solve many such subproblems together, using computations of previous sub-problems\nThese all go together re-using previous computations: (this alone is a standard sliding window problem)\n        i  ---> i+w ---> i+2w ----> i+3w ----> i+4w \n\t\t\nThese all go together re-using previous computations: (this alone is a standard sliding window problem)\n        (i+1)  ---> (i+1)+w ---> (i+1)+2w ----> (i+1)+3w ----> (i+1)+4w \nThese all go together re-using previous computations: (this alone is a standard sliding window problem)\n        (i+2)  ---> (i+2)+w ---> (i+2)+2w ----> (i+2)+3w ----> (i+2)+4w \n\t\t\nThese all go together re-using previous computations: (this alone is a standard sliding window problem)\n        (i+3)  ---> (i+3)+w ---> (i+3)+2w ----> (i+3)+3w ----> (i+3)+4w \n\t\t\nNow, we realise all the subproblems are solved: because i+4 was solved in first iteration as w here is 4.\nSo, we need to do w such iterations above and each iteration take O(n) time. So, total time complexity is O(n x w).\nSo, this problem effectively is a combination of w sliding window problems.',
        views: "8576",
        upvotes: "139",
        author_id: "794",
        problem_id: 31,
      },
      {
        title: "Easy Two-Map Solution (C++/Java)",
        body: "I think the following code is self-explanatory enough. We use an unordered_map<string, int> counts to record the expected times of each word and another unordered_map<string, int> seen to record the times we have seen. Then we check for every possible position of i. Once we meet an unexpected word or the times of some word is larger than its expected times, we stop the check. If we finish the check successfully, push i to the result indexes.\n\n\nC++\nclass Solution {\npublic:\nvector findSubstring(string s, vector& words) {\nunordered_map<string, int> counts;\nfor (string word : words)\ncounts[word]++;\nint n = s.length(), num = words.size(), len = words[0].length();\nvector indexes;\nfor (int i = 0; i < n - num * len + 1; i++) {\nunordered_map<string, int> seen;\nint j = 0;\nfor (; j < num; j++) {\nstring word = s.substr(i + j * len, len);\nif (counts.find(word) != counts.end()) {\nseen[word]++;\nif (seen[word] > counts[word])\nbreak;\n}\nelse break;\n}\nif (j == num) indexes.push_back(i);\n}\nreturn indexes;\n}\n};\n\n\nJava\n\n\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        final Map<String, Integer> counts = new HashMap<>();\n        for (final String word : words) {\n            counts.put(word, counts.getOrDefault(word, 0) + 1);\n        }\n        final List<Integer> indexes = new ArrayList<>();\n        final int n = s.length(), num = words.length, len = words[0].length();\n        for (int i = 0; i < n - num * len + 1; i++) {\n            final Map<String, Integer> seen = new HashMap<>();\n            int j = 0;\n            while (j < num) {\n                final String word = s.substring(i + j * len, i + (j + 1) * len);\n                if (counts.containsKey(word)) {\n                    seen.put(word, seen.getOrDefault(word, 0) + 1);\n                    if (seen.get(word) > counts.getOrDefault(word, 0)) {\n                        break;\n                    }\n                } else {\n                    break;\n                }\n                j++;\n            }\n            if (j == num) {\n                indexes.add(i);\n            }\n        }\n        return indexes;\n    }\n}",
        views: "108510",
        upvotes: "446",
        author_id: "1",
        problem_id: 31,
      },
    ],
  },
  {
    title: "31. Next Permutation",
    description:
      "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\n\n\tFor example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n\n\tFor example, the next permutation of arr = [1,2,3] is [1,3,2].\n\tSimilarly, the next permutation of arr = [2,3,1] is [3,1,2].\n\tWhile the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n\n\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place and use only constant extra memory.\n\n \nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\n\nExample 2:\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\n\nExample 3:\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 100\n\t0 <= nums[i] <= 100\n\n",
    difficulty: "Medium",
    acceptance: "35.21",
    frequency: "200.22",
    topics: [
      [
        "Binary Search",
        "Shell",
        "Queue",
        "Bit Manipulation",
        "Recursion",
        "String",
        "Bucket Sort",
        "Game Theory",
        "Union Find",
        "Depth-First Search",
      ],
    ],
    languages: [
      [
        "PHP",
        "C++",
        "Python3",
        "TypeScript",
        "Go",
        "Racket",
        "Elixir",
        "Python",
        "Swift",
        "C#",
      ],
    ],
    comments: [
      {
        author_id: "394",
        problem_id: 32,
        body: "Это было как головоломка, но я нашел свой путь к решению!",
        comment_reply_id: null,
      },
      {
        author_id: "483",
        problem_id: 32,
        body: "У кого-нибудь есть идеи, как можно оптимизировать мое решение? Пока я не совсем доволен своим подходом.",
        comment_reply_id: null,
      },
      {
        author_id: "551",
        problem_id: 32,
        body: "Сложно даже представить, сколько попыток ушло на решение этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "418",
        problem_id: 32,
        body: "Это моя новая любимая задача! Хочу попробовать еще раз!",
        comment_reply_id: null,
      },
      {
        author_id: "310",
        problem_id: 32,
        body: "Эта задача была настоящим испытанием ума! Сложность на высшем уровне.",
        comment_reply_id: null,
      },
      {
        author_id: "348",
        problem_id: 32,
        body: "Не могу поверить, что я решил это без помощи Google!",
        comment_reply_id: null,
      },
      {
        author_id: "748",
        problem_id: 32,
        body: "Подсказки были такими полезными! Они действительно помогли мне решить эту задачу.",
        comment_reply_id: null,
      },
      {
        author_id: "783",
        problem_id: 32,
        body: "Благодаря этой задаче я узнал о новой функции языка программирования.",
        comment_reply_id: null,
      },
      {
        author_id: "856",
        problem_id: 32,
        body: "Эта задача показала мне, насколько важно быть терпеливым в программировании.",
        comment_reply_id: null,
      },
      {
        author_id: "112",
        problem_id: 32,
        body: "Благодаря этой задаче я узнал о новой функции языка программирования.",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "Beats 100% || full explanation|| In steps",
        body: "Approach\nThe steps are the following:\n\nFind the break-point, i: Break-point means the first index i from the back of the given array where arr[i] becomes smaller than arr[i+1].\nFor example, if the given array is {2,1,5,4,3,0,0}, the break-point will be index 1(0-based indexing). Here from the back of the array, index 1 is the first index where arr[1] i.e. 1 is smaller than arr[i+1] i.e. 5.\nTo find the break-point, using a loop we will traverse the array backward and store the index i where arr[i] is less than the value at index (i+1) i.e. arr[i+1].\nIf such a break-point does not exist i.e. if the array is sorted in decreasing order, the given permutation is the last one in the sorted order of all possible permutations. So, the next permutation must be the first i.e. the permutation in increasing order.\nSo, in this case, we will reverse the whole array and will return it as our answer.\nIf a break-point exists:\nFind the smallest number i.e. > arr[i] and in the right half of index i(i.e. from index i+1 to n-1) and swap it with arr[i].\nReverse the entire right half(i.e. from index i+1 to n-1) of index i. And finally, return the array.\n\n\n\nCode\nclass Solution {\n    public void nextPermutation(int[] nums) {\n        int ind1=-1;\n        int ind2=-1;\n        // step 1 find breaking point \n        for(int i=nums.length-2;i>=0;i--){\n            if(nums[i]<nums[i+1]){\n                ind1=i;\n                break;\n            }\n        }\n        // if there is no breaking  point \n        if(ind1==-1){\n            reverse(nums,0);\n        }\n        \n        else{\n            // step 2 find next greater element and swap with ind2\n            for(int i=nums.length-1;i>=0;i--){\n                if(nums[i]>nums[ind1]){\n                    ind2=i;\n                    break;\n                }\n            }\n\n            swap(nums,ind1,ind2);\n            // step 3 reverse the rest right half\n            reverse(nums,ind1+1);\n        }\n    }\n    void swap(int[] nums,int i,int j){\n        int temp=nums[i];\n        nums[i]=nums[j];\n        nums[j]=temp;\n    }\n    void reverse(int[] nums,int start){\n        int i=start;\n        int j=nums.length-1;\n        while(i<j){\n            swap(nums,i,j);\n            i++;\n            j--;\n        }\n    }\n}\n",
        views: "58734",
        upvotes: "620",
        author_id: "399",
        problem_id: 32,
      },
      {
        title: "Kotlin Solution",
        body: "Intuition\nTo find the next permutation of a given array of integers, we need to rearrange the elements such that the next permutation is lexicographically greater than the current one. This involves finding the rightmost element that is less than its next element, swapping it with the smallest element to its right that is larger than it, and then reversing the subarray to the right of the swapped element.\nApproach\nStart by initializing a variable pos to -1. This variable will keep track of the position where the next permutation begins.\nIterate from the second last element of the array to the first element. Find the first element nums[i] such that nums[i] < nums[i + 1]. Set pos to i and break out of the loop.\nIf pos is still -1 after the loop, it means the array is in descending order. In this case, reverse the entire array to get the smallest possible permutation.\nIf pos is not -1, find the smallest element to the right of nums[pos] that is greater than nums[pos]. Swap nums[pos] with this element.\nReverse the subarray to the right of nums[pos].\nComplexity\n\n\nTime complexity:\nO(n), where n is the number of elements in the array. The algorithm involves a single pass through the array to find the next permutation and perform the necessary swaps and reversals.\n\n\nSpace complexity:\nO(1), as the algorithm uses only constant extra space for variables.\n\n\nCode\nclass Solution {\n    fun nextPermutation(nums: IntArray) {\n        var pos = -1 // Initialize pos to -1\n        for (i in nums.size - 2 downTo 0) {\n            if (nums[i] < nums[i + 1]) {\n                pos = i\n                break\n            }\n        }\n        if (pos >= 0) {\n            var j = nums.size - 1\n            while (j >= 0 && nums[j] <= nums[pos]) {\n                j--\n            }\n            swap(nums, pos, j)\n        }\n        reverse(nums, pos + 1)\n    }\n\n    fun reverse(nums: IntArray, pos: Int) {\n        var i = pos\n        var j = nums.size - 1\n        while (i < j) {\n            swap(nums, i, j)\n            i++\n            j--\n        }\n    }\n\n    fun swap(nums: IntArray, pos: Int, j: Int) {\n        val tmp = nums[pos]\n        nums[pos] = nums[j]\n        nums[j] = tmp\n    }\n}\n",
        views: "44",
        upvotes: "1",
        author_id: "806",
        problem_id: 32,
      },
      {
        title: "Python Solution",
        body: 'Intuition\n\nAt first I had absolutely no clue what was going on in this problem. Like I got how it worked with 3 numbers but then when I did 4 numbers it didn\'t make sense at all. I just worked through an example with 5 numbers and used the leetcode engine to check my work when it finally clicked. The algorithm was to partition the array into two parts.\nThe second part would be the longest decreasing subarray ending in the last index. And you just want to reverse that second partition and swap the smallest element thats bigger than the element directly to the left of the partition with each other.\nApproach\n\nPretty much just implemented by intuition.\nComplexity\n\nTime complexity:\n\n\nO(n)\n\nSpace complexity:\n\n\nO(1)\nCode\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        if len(nums) == 1:\n            return\n        # init partition index to the last index\n        partition_ind = len(nums) - 1\n\n        # for loop until it either goes out of bounds or reaches a index where it is non decreasing\n            # the left index would be smaller than the right in which case break\n        for i in range(len(nums) - 2, -1, -1):\n            if nums[i] < nums[partition_ind]:\n                break\n            else:\n                partition_ind = i\n\n        self.reverseArrayPartially(nums, partition_ind, len(nums) - 1)\n        if partition_ind == 0:\n            return\n\n        target = nums[partition_ind - 1]\n\n        # can replace linear search for smallest num that is bigger than target, but unnecessary complex\n        # since there are only 100 length at max\n\n        for i in range(partition_ind, len(nums)):\n            if nums[i] > target:\n                nums[partition_ind - 1] = nums[i]\n                nums[i] = target\n                return\n\n    def reverseArrayPartially(self, nums: List[int], left: int, right: int):\n        if left < 0 or right >= len(nums):\n            print("Index out of bounds")\n            return []\n\n\n        while left < right:\n            temp = nums[left]\n            nums[left] = nums[right]\n            nums[right] = temp\n\n            left += 1\n            right -= 1\n',
        views: "155",
        upvotes: "1",
        author_id: "211",
        problem_id: 32,
      },
      {
        title: "Java Optimized solution",
        body: "Intuition\n\nApproach\n\nComplexity\n\nTime complexity: O(N)\n\n\n\nSpace complexity: O(1)\n\n\nCode\nclass Solution {\n    public void nextPermutation(int[] nums) {\n        int i = nums.length - 2;\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\n            i--;\n        }\n        if (i >= 0) {\n            int j = nums.length - 1;\n            while (nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i + 1);\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n\n    private void reverse(int[] nums, int start) {\n        int i = start, j = nums.length - 1;\n        while (i < j) {\n            swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }\n\n}",
        views: "116",
        upvotes: "1",
        author_id: "776",
        problem_id: 32,
      },
    ],
  },
  {
    title: "32. Longest Valid Parentheses",
    description:
      'Given a string containing just the characters \'(\' and \')\', return the length of the longest valid (well-formed) parentheses substring.\n\n \nExample 1:\n\nInput: s = "(()"\nOutput: 2\nExplanation: The longest valid parentheses substring is "()".\n\n\nExample 2:\n\nInput: s = ")()())"\nOutput: 4\nExplanation: The longest valid parentheses substring is "()()".\n\n\nExample 3:\n\nInput: s = ""\nOutput: 0\n\n\n \nConstraints:\n\n\n\t0 <= s.length <= 3 * 104\n\ts[i] is \'(\', or \')\'.\n\n',
    difficulty: "Hard",
    acceptance: "25.74",
    frequency: "100.39",
    topics: [
      [
        "Bitmask",
        "Queue",
        "Stack",
        "Linked List",
        "Counting",
        "Graph",
        "Number Theory",
        "Probability and Statistics",
        "Doubly-Linked List",
        "Binary Tree",
      ],
    ],
    languages: [
      [
        "TypeScript",
        "Racket",
        "Elixir",
        "C++",
        "Scala",
        "Ruby",
        "Kotlin",
        "PHP",
        "Dart",
        "Java",
      ],
    ],
    comments: [
      {
        author_id: "541",
        problem_id: 33,
        body: "Наконец-то, я разобрался с этой задачей! Спасибо за все подсказки.",
        comment_reply_id: null,
      },
      {
        author_id: "78",
        problem_id: 33,
        body: "Наконец-то, я разобрался с этой задачей! Спасибо за все подсказки.",
        comment_reply_id: null,
      },
      {
        author_id: "557",
        problem_id: 33,
        body: "Сложно поверить, что я только что решил это! Спасибо всем за поддержку.",
        comment_reply_id: null,
      },
      {
        author_id: "871",
        problem_id: 33,
        body: "Как я мог пропустить этот трюк? Благодарю за подсказку!",
        comment_reply_id: null,
      },
      {
        author_id: "30",
        problem_id: 33,
        body: "Чувствую, что становлюсь лучше с каждой решенной задачей!",
        comment_reply_id: null,
      },
      {
        author_id: "50",
        problem_id: 33,
        body: "Это моя новая любимая задача! Хочу попробовать еще раз!",
        comment_reply_id: null,
      },
      {
        author_id: "893",
        problem_id: 33,
        body: "Подсказки были такими полезными! Они действительно помогли мне решить эту задачу.",
        comment_reply_id: null,
      },
      {
        author_id: "196",
        problem_id: 33,
        body: "Теперь я чувствую, что могу решить что угодно!",
        comment_reply_id: null,
      },
      {
        author_id: "479",
        problem_id: 33,
        body: "Когда я столкнулся с этой задачей впервые, я думал, что это невозможно. Теперь я знаю иначе!",
        comment_reply_id: null,
      },
      {
        author_id: "106",
        problem_id: 33,
        body: "Мой мозг сейчас в кипении от этой задачи.",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "Easiest Solution || Using Stack || C++",
        body: "Code\nclass Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int n=s.length();\n        stack<int> st;\n        st.push(-1);\n        int maxLen=0;\n        for(int i=0;i<n;i++){\n            if(s[i]=='('){\n                st.push(i);\n            }\n            else{\n                st.pop();\n                if(st.empty()){\n                    st.push(i);\n                } else{\n                    int len=i-st.top();\n                    maxLen=max(len,maxLen);\n                }\n            }\n        }\n        return maxLen;\n    }\n};",
        views: "230",
        upvotes: "1",
        author_id: "785",
        problem_id: 33,
      },
      {
        title:
          "(JAVA)Effective ⭐️ Longest Valid Parentheses Algorithm: O(n) Time Complexity with Stack✅🔥🚀",
        body: "Intuition\nThe initial idea is to use a stack to keep track of the positions of opening parentheses in the string. This helps in identifying valid pairs of parentheses and finding the longest sequence of them.\nApproach\nAlgorithm.\ncreate a stack with -1 as left end point.\nIterate over all the characters of string from left to right.\nif current character is opening bracket push its index to stack.\nif current character is closing bracket.\n\npop from stack\nif stack is empty then push current index as new left end point\nelse we found a valid expression between current index and left end point which is top element of stack\n\nComplexity\n\n\nTime complexity:\nO(n) time complexity as we iterate over the string\n\n\nSpace complexity:\nO(n) space complexity because we used stack\n\n\nCode\nclass Solution {\n    public int longestValidParentheses(String s) {\n      Stack<Integer> stack = new Stack<>();\n      stack.push(-1);\n      int max=0;\n      for(int i=0;i<s.length();i++){\n        Character ch = s.charAt(i);\n        if(ch == '('){\n            stack.push(i);\n        }\n        else{\n            stack.pop();\n            if(stack.isEmpty()){\n                stack.push(i);\n            }\n            max = Math.max(max,i-stack.peek());\n        }\n      }\n    return max;\n    }\n}",
        views: "1079",
        upvotes: "10",
        author_id: "900",
        problem_id: 33,
      },
      {
        title: "My O(n) solution using a stack",
        body: "class Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int n = s.length(), longest = 0;\n        stack<int> st;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '(') st.push(i);\n            else {\n                if (!st.empty()) {\n                    if (s[st.top()] == '(') st.pop();\n                    else st.push(i);\n                }\n                else st.push(i);\n            }\n        }\n        if (st.empty()) longest = n;\n        else {\n            int a = n, b = 0;\n            while (!st.empty()) {\n                b = st.top(); st.pop();\n                longest = max(longest, a-b-1);\n                a = b;\n            }\n            longest = max(longest, a);\n        }\n        return longest;\n    }\n};\nThe workflow of the solution is as below.\n\nScan the string from beginning to end.\nIf current character is '(',\npush its index to the stack. If current character is ')' and the\ncharacter at the index of the top of stack is '(', we just find a\nmatching pair so pop from the stack. Otherwise, we push the index of\n')' to the stack.\nAfter the scan is done, the stack will only\ncontain the indices of characters which cannot be matched. Then\nlet's use the opposite side -  substring between adjacent indices\nshould be valid parentheses.\nIf the stack is empty, the whole input\nstring is valid. Otherwise, we can scan the stack to get longest\nvalid substring as described in step 3.\n",
        views: "146474",
        upvotes: "1K",
        author_id: "773",
        problem_id: 33,
      },
      {
        title:
          "🚀 ✅100% , Detailed explaination 🔥 with Pictures ✅ 🔥 🚀O(n) ,  in C++ , Java , Python , stack. 🔥",
        body: "Approach\n\nHere the approach is nothing but we are using a stack and when we encounter an opening brace then we push the index of it into the stack and whenever we touch a closing brace then we see the top of the stack if it's size is one then it means the closing braces have dominated the opening brace. We then edit the top value of the stack to the index of the closing brace.\n\n\n\nThis method is clearly depicted in the picture as shown below.\n\n\n\n\n\nhere answer is given as the line ans = max(ans , index - stk.top()) only when the size of stack is not 1 and there is a closing brace encountered.\n\n\n\nCode\nC++JavaPythonclass Solution {\npublic:\n    int longestValidParentheses(string s) {\n        stack<int>stk;\n        stk.push(-1);\n        int ans = 0;\n        for(int i = 0 ; i < s.size();  i++)\n        {\n            if(s[i] == '(')\n                stk.push(i);\n            else\n            {\n                if(stk.size() == 1)\n                    stk.top() = i;\n                else\n                {\n                    stk.pop();\n                    ans = max(ans , i - stk.top());\n                }\n            }\n        }\n        return ans;\n    }\n};\n\nComplexity\n\n\nTime complexity:Here the complexity would be O(n)O(n)O(n) as we are using only a single loop with a stack only so this runs in a linear complexity.\n\n\n\n\nSpace complexity:Here the space complexity would be O(n)O(n)O(n) as we are using just a stack that too store the elements in the worst case it goes to that complexity.\n\n\n\n\nIF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.\n",
        views: "12278",
        upvotes: "101",
        author_id: "103",
        problem_id: 33,
      },
    ],
  },
  {
    title: "33. Search in Rotated Sorted Array",
    description:
      "There is an integer array nums sorted in ascending order (with distinct values).\n\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\n\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\n \nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\nExample 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\nExample 3:\nInput: nums = [1], target = 0\nOutput: -1\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 5000\n\t-104 <= nums[i] <= 104\n\tAll values of nums are unique.\n\tnums is an ascending array that is possibly rotated.\n\t-104 <= target <= 104\n\n",
    difficulty: "Medium",
    acceptance: "10.80",
    frequency: "114.87",
    topics: [
      [
        "Ordered Set",
        "Rolling Hash",
        "Depth-First Search",
        "Iterator",
        "Two Pointers",
        "Counting Sort",
        "Trie",
        "Greedy",
        "String",
        "Linked List",
      ],
    ],
    languages: [
      [
        "Java",
        "JavaScript",
        "C#",
        "Python3",
        "Python",
        "Swift",
        "Dart",
        "Scala",
        "Racket",
        "TypeScript",
      ],
    ],
    comments: [
      {
        author_id: "145",
        problem_id: 34,
        body: "Эта задача мне не давала покоя, но теперь я горд собой!",
        comment_reply_id: null,
      },
      {
        author_id: "275",
        problem_id: 34,
        body: "Эта задача была настоящим испытанием ума! Сложность на высшем уровне.",
        comment_reply_id: null,
      },
      {
        author_id: "656",
        problem_id: 34,
        body: "Это моя новая любимая задача! Хочу попробовать еще раз!",
        comment_reply_id: null,
      },
      {
        author_id: "376",
        problem_id: 34,
        body: "Я не знал, что это возможно, пока не попробовал! Это было удивительно!",
        comment_reply_id: null,
      },
      {
        author_id: "197",
        problem_id: 34,
        body: "Сколько времени я потратил на решение этой задачи? Не считаясь!",
        comment_reply_id: null,
      },
      {
        author_id: "549",
        problem_id: 34,
        body: "Наконец-то, я разобрался с этой задачей! Спасибо за все подсказки.",
        comment_reply_id: null,
      },
      {
        author_id: "150",
        problem_id: 34,
        body: "Подсказки были такими полезными! Они действительно помогли мне решить эту задачу.",
        comment_reply_id: null,
      },
      {
        author_id: "9",
        problem_id: 34,
        body: "Кто-нибудь еще решал эту задачу? Хотелось бы услышать ваши мысли!",
        comment_reply_id: null,
      },
      {
        author_id: "102",
        problem_id: 34,
        body: "Какие интересные подходы у других людей к этой задаче",
        comment_reply_id: null,
      },
      {
        author_id: "167",
        problem_id: 34,
        body: "Самая сложная часть в этой задаче - это формулировка.",
        comment_reply_id: null,
      },
    ],
    solutions: [],
  },
  {
    title: "34. Find First and Last Position of Element in Sorted Array",
    description:
      "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n\nIf target is not found in the array, return [-1, -1].\n\nYou must write an algorithm with O(log n) runtime complexity.\n\n \nExample 1:\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\nExample 2:\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\nExample 3:\nInput: nums = [], target = 0\nOutput: [-1,-1]\n\n \nConstraints:\n\n\n\t0 <= nums.length <= 105\n\t-109 <= nums[i] <= 109\n\tnums is a non-decreasing array.\n\t-109 <= target <= 109\n\n",
    difficulty: "Medium",
    acceptance: "67.65",
    frequency: "18.06",
    topics: [
      [
        "Memoization",
        "Rejection Sampling",
        "Eulerian Circuit",
        "Queue",
        "Suffix Array",
        "Quickselect",
        "Linked List",
        "Iterator",
        "Game Theory",
        "Probability and Statistics",
      ],
    ],
    languages: [
      [
        "Kotlin",
        "Swift",
        "Ruby",
        "TypeScript",
        "C",
        "C#",
        "Erlang",
        "Racket",
        "Python3",
        "Dart",
      ],
    ],
    comments: [
      {
        author_id: "353",
        problem_id: 35,
        body: "Идея для этого решения пришла ко мне во сне! Удивительно, как мозг работает иногда.",
        comment_reply_id: null,
      },
      {
        author_id: "369",
        problem_id: 35,
        body: "Кто-нибудь еще решал эту задачу? Хотелось бы услышать ваши мысли!",
        comment_reply_id: null,
      },
      {
        author_id: "206",
        problem_id: 35,
        body: "Наконец-то я справился с этой задачей! Вперед к следующей!",
        comment_reply_id: null,
      },
      {
        author_id: "691",
        problem_id: 35,
        body: "Сложно поверить, что я только что решил это! Спасибо всем за поддержку.",
        comment_reply_id: null,
      },
      {
        author_id: "215",
        problem_id: 35,
        body: "Мой мозг сейчас в кипении от этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "162",
        problem_id: 35,
        body: "Теперь я чувствую, что могу решить что угодно!",
        comment_reply_id: null,
      },
      {
        author_id: "761",
        problem_id: 35,
        body: "Это было круто! Какая следующая задача?",
        comment_reply_id: null,
      },
      {
        author_id: "387",
        problem_id: 35,
        body: "Подсказки были такими полезными! Они действительно помогли мне решить эту задачу.",
        comment_reply_id: null,
      },
      {
        author_id: "943",
        problem_id: 35,
        body: "Иногда простые решения лучше всех! Не всегда нужно усложнять.",
        comment_reply_id: null,
      },
      {
        author_id: "686",
        problem_id: 35,
        body: "Идея для этого решения пришла ко мне во сне! Удивительно, как мозг работает иногда.",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "【Video】Binary Search Solution",
        body: "Intuition\nUsing Binary Search twice for left most value and right most value\n\nSolution Video\n\n■ Timeline of the video\n0:00 Read the question of Find First and Last Position of Element in Sorted Array\n1:16 Demonstrate solution with an example\n6:59 Coding\n9:56 Time Complexity and Space Complexity\n10:14 Step by step algorithm\nI created the video in 2022. I write my thought process in the post to support the video. You can understand the question visually with the video and behind the scene with the post.\n⭐️⭐️ Don't forget to subscribe to my channel! ⭐️⭐️\n■ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\nSubscribers: 4,213\nThank you for your support!\n\nApproach\nHow we think about a solution\nWe have a constraint of time complexity O(logn)O(log n)O(logn) and a description says \"Given an array of integers nums sorted in non-decreasing order\", so we can feel this question is solved by binary search.\nBut a challenging point of this question is that we might multiple targes in the input array, becuase we have to find the starting and ending position of a given target value.\n\n⭐️ Points\nWe might have multiple targets in the input array.\n\nThe start position and end position can be rephrased as the leftmost index and the rightmost index.\nSo, for the most part, we use typical binary search, but when we find a target, we need to do these.\n\n⭐️ Points\nEvery time we find one of targets, keep current index and execute one of these\n\nIf we try to find left most index, move right pointer to middle pointer - 1.\nIf we try to find right most index, move left pointer to middle pointer + 1.\n\nBecause we need to find a target again between left and middle pointer or right and middle pointer. If we don't find the new target in the new range, don't worry. The current index you have right now is the most left index or right index.\n\n\nHow we can find the most left index and right index at the same time?\n\nI think it's hard to find the most left index and right index at the same time, so simply we execute binary search twice for the most left index and right index, so that we can focus on one of them.\nLet's see a real algorithm!\nAlgorithm Overview:\n\nDefine a class Solution.\nImplement a method searchRange that takes a sorted list of integers nums and a target integer target. This method finds the range of the target value in the input list.\n\nDetailed Explanation:\n\n\nDefine a class named Solution.\n\n\nImplement a method searchRange within the Solution class that takes three parameters: nums (a sorted list of integers), target (an integer to search for), and is_searching_left (a boolean indicating whether to search for the leftmost or rightmost occurrence of the target).\na. Define a helper method binary_search that takes nums, target, and is_searching_left as arguments. This method performs binary search to find the target value and returns the index of either the leftmost or rightmost occurrence of the target value based on the is_searching_left parameter.\nb. Initialize left to 0, right to the length of nums minus 1, and idx to -1.\nc. Perform a binary search within the nums array using a while loop until left is less than or equal to right.\nd. Calculate the midpoint as (left + right) // 2.\ne. Compare the target value with the element at the midpoint of the array (nums[mid]):\n\nIf nums[mid] is greater than the target, update right to mid - 1.\nIf nums[mid] is less than the target, update left to mid + 1.\nIf nums[mid] is equal to the target, update idx to mid and adjust left or right accordingly based on is_searching_left.\n\nf. Return the index idx.\n\n\nCall binary_search twice within the searchRange method: once to find the leftmost occurrence of the target (left = binary_search(nums, target, True)) and once to find the rightmost occurrence of the target (right = binary_search(nums, target, False)).\n\n\nReturn a list containing the leftmost and rightmost indices of the target: [left, right].\n\n\nThis algorithm uses binary search to efficiently find the leftmost and rightmost occurrences of the target in the sorted array.\nComplexity\n\n\nTime complexity: O(logn)O(log n)O(logn)\nThe time complexity of the binary search algorithm is O(logn)O(log n)O(logn) where n is the length of the input array nums. The searchRange method calls binary_search twice, so the overall time complexity remains O(logn)O(log n)O(logn).\n\n\nSpace complexity: O(1)O(1)O(1)\nThe space complexity is O(1)O(1)O(1) because the algorithm uses a constant amount of extra space, regardless of the size of the input array. There are no data structures or recursive calls that consume additional space proportional to the input size.\n\n\nPythonJavaScriptJavaC++class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        \n        def binary_search(nums, target, is_searching_left):\n            left = 0\n            right = len(nums) - 1\n            idx = -1\n            \n            while left <= right:\n                mid = (left + right) // 2\n                \n                if nums[mid] > target:\n                    right = mid - 1\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    idx = mid\n                    if is_searching_left:\n                        right = mid - 1\n                    else:\n                        left = mid + 1\n            \n            return idx\n        \n        left = binary_search(nums, target, True)\n        right = binary_search(nums, target, False)\n        \n        return [left, right]\n            \n\nThank you for reading my post.\nPlease upvote it and don't forget to subscribe to my channel!\n⭐️ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n⭐️ Twitter\nhttps://twitter.com/CodingNinjaAZ\n⭐️ My previous post and video\n#121 Best Time to Buy and Sell Stock\npost\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/4944048/video-keep-minimum-price-solution/\nvideo\n",
        views: "173",
        upvotes: "5",
        author_id: "938",
        problem_id: 35,
      },
      {
        title:
          "Solution in O(logN) time complexity as well as solution in  O(N) time complexity || easiest approach",
        body: "Intuition\n\nuse lower_bound and upper_bound stl.\nApproach\n\napproach 1 : TC(O(N))\n1) initialize two variables start and end , initially -1.\n2) start interating from starting of vector , as soon as you find  the element , store that index in start variable and break;\n3) start iterating from end of vector, as soon as you find the element , store that index in end variable and break;\n4)now create a vector ans and push both atart and end variables in it. return the vector ans.\napproach 2: TC(O(log(n)))\n1) use lower_bound(target) to find the first occurence of target.\n2) similarly use upper_bound(target) to find first occurence of next higher element in vector.\n3) subtract nums.begin() from from the iterators to get the index.\n4) check if these index value are not out of range and return these values after pushing into a vector.\nComplexity\n\nTime complexity:\n\n\nO(N) || O(log(N))\n\nSpace complexity:\n\n\nO(1)\nCode\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        // solution in O(n) time complexity\n        // int start = -1;\n        // int end = -1;\n\n        // vector<int> ans;\n\n        // for(int i=0 ; i<nums.size() ; i++){\n        //     if(nums[i] == target){\n        //         start = i;\n        //         break;\n        //     } \n        // }\n\n        // for(int j=nums.size()-1; j>=0 ;j--){\n        //     if(nums[j] == target){\n        //         end = j;\n        //         break;\n        //     } \n        // }\n\n        // ans.push_back(start);\n        // ans.push_back(end);\n\n        // return ans;\n\n        // solution in O(logN) complexity\n        if(nums.size() == 0) return {-1,-1};\n        \n        auto start = lower_bound(nums.begin(),nums.end(),target); // 2\n        \n        auto end = upper_bound(nums.begin(),nums.end(),target);  // 2\n\n        // first occurence\n        int a = start - nums.begin();\n        int b = end - nums.begin() - 1;\n         vector<int> ans;\n        \n        if(a >= nums.size() || b >= nums.size() || nums[a] != target || nums[b] != target){\n            a = -1;\n            b = -1;\n        }\n        \n        \n\n       \n        ans.push_back(a);\n        ans.push_back(b);\n\n        return ans;\n\n    }\n};",
        views: "118",
        upvotes: "1",
        author_id: "16",
        problem_id: 35,
      },
      {
        title:
          "✅☑️ Best C++ 2 Solution || Binary Search || Linear Search || Brute Force->Optimize || One Stop Solu.",
        body: "Intuition\n\nWe can Solved this question using Two approach. (Here I have explained all the possible solutions of this problem).\n\nSolved using Linear Search (Brute Force Approach).\nSolved using Binary Search (Optimized Approach).\n\nApproach\n\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\nComplexity\n\nTime complexity:\n\n\nTime complexity is given in code comment.\n\nSpace complexity:\n\n\nSpace complexity is given in code comment.\nCode\n/*\n\n    Time Complexity : O(N), because in the worst case we traverse the <= N element. Where N is the size of the\n    Array(nums).\n                    \n    Space Complexity : O(1), the space complexity is constant.\n\n    Solved using Linear Search.\n\n*/\n\n\n/***************************************** Approach 1 First Code *****************************************/\n\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        int startingPosition = -1, endingPosition = -1;\n        int n = nums.size();\n        for(int i=0; i<n; i++){\n            if(nums[i] == target){\n                startingPosition = i;\n                break;\n            }\n        }\n        for(int i=n-1; i>=0; i--){\n            if(nums[i] == target){\n                endingPosition = i;\n                break;\n            }\n        }\n        return {startingPosition, endingPosition};\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\n    is logarithmic.\n\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\n    constant.\n\n    Solved using Binary Search.\n\n*/\n\n\n/***************************************** Approach 2 First Code *****************************************/\n\nclass Solution {\nprivate:\n    int lower_bound(vector<int>& nums, int low, int high, int target){\n        while(low <= high){\n            int mid = (low + high) >> 1;\n            if(nums[mid] < target){\n                low = mid + 1;\n            }\n            else{\n                high = mid - 1;\n            }\n        }\n        return low;\n    }\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        int low = 0, high = nums.size()-1;\n        int startingPosition = lower_bound(nums, low, high, target);\n        int endingPosition = lower_bound(nums, low, high, target + 1) - 1;\n        if(startingPosition < nums.size() && nums[startingPosition] == target){\n            return {startingPosition, endingPosition};\n        }\n        return {-1, -1};\n    }\n};\n\n\n\n\n\n\n/***************************************** Approach 2 Second Code *****************************************/\n\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        int startingPosition = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\n        int endingPosition = lower_bound(nums.begin(), nums.end(), target+1) - nums.begin() - 1;\n        if(startingPosition < nums.size() && nums[startingPosition] == target){\n            return {startingPosition, endingPosition};\n        }\n        return {-1, -1};\n    }\n};\n\nIF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.\n",
        views: "45493",
        upvotes: "335",
        author_id: "477",
        problem_id: 35,
      },
      {
        title:
          "💯Faster✅💯 Lesser✅4 Methods🔥Binary Search🔥Two Pointers🔥Modified Binary Search🔥Linear Search",
        body: "🚀 Hi, I'm Mohammed Raziullah Ansari, and I'm excited to share 4 ways to solve this question with detailed explanation of each approach:\nProblem Explaination:\nConsider a long list of numbers that are listed from smallest to largest, in that order. We refer to this list as an array. Additionally, we are looking for a particular number on this list.\nwe now need to know not only if that number is in the list but also when and where it first and last appears.\nHere's an example:\nArray: [1, 2, 2, 4, 4, 4, 7, 9, 10]\nNumber we are looking for: 4\nWe want to find:\nThe first position where the number 4 appears, which is the index 3 in this case.\nThe last position where the number 4 appears, which is the index 5 in this case.\n🔍 Methods To Solve This Problem:\nI'll be covering four different methods to solve this problem:\n\nLinear Search (Brute Force)\nBinary Search (Two Binary Searches)\nModified Binary Search (Optimized)\nTwo-Pointer Approach\n\n1.  Linear Search (Brute Force):\n\nInitialize two variables, first and last, to -1.\nIterate through the sorted array from left to right.\nWhen you encounter the target element for the first time, set first to the current index.\nContinue iterating to find the last occurrence of the target element and update last whenever you encounter it.\nReturn first and last\n\nComplexity\n\n\n⏱️ Time Complexity: O(n) - In the worst case, you may have to traverse the entire array.\n\n\n🚀 Space Complexity: O(1) - Constant extra space is used.\n\n\nCode\nPythonJavaC++Cclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        first, last = -1, -1\n        for i in range(len(nums)):\n            if nums[i] == target:\n                if first == -1:\n                    first = i\n                last = i\n        return [first, last]\n\n2. Binary Search (Two Binary Searches):\n\nPerform a binary search to find the first occurrence of the target element.\nPerform another binary search to find the last occurrence of the target element.\nReturn the results from the two binary searches.\n\nComplexity\n\n\n⏱️ Time Complexity: O(n) - Two binary searches are performed.\n\n\n🚀 Space Complexity: O(1) - Constant extra space is used.\n\n\nCode\nPythonJavaC++Cclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        def findFirst(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = left + (right - left) // 2\n                if nums[mid] == target:\n                    if mid == 0 or nums[mid - 1] != target:\n                        return mid\n                    else:\n                        right = mid - 1\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return -1\n        \n        def findLast(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = left + (right - left) // 2\n                if nums[mid] == target:\n                    if mid == len(nums) - 1 or nums[mid + 1] != target:\n                        return mid\n                    else:\n                        left = mid + 1\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return -1\n        \n        first = findFirst(nums, target)\n        last = findLast(nums, target)\n        return [first, last]\n\n3. Modified Binary Search (Optimized):\n\nInitialize two variables, first and last, to -1.\nPerform a binary search to find the target element.\nWhen you find the target element, update first to the current index and continue searching for the first occurrence in the left subarray.\nSimilarly, update last to the current index and continue searching for the last occurrence in the right subarray.\nContinue until the binary search terminates.\nReturn first and last.\n\nComplexity\n\n\n⏱️ Time Complexity: O(n) - One binary search with constant additional work.\n\n\n🚀 Space Complexity: O(1) - Constant extra space is used.\n\n\nCode\nPythonJavaC++Cclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        def findFirst(nums, target):\n            left, right = 0, len(nums) - 1\n            first = -1\n            while left <= right:\n                mid = left + (right - left) // 2\n                if nums[mid] == target:\n                    first = mid\n                    right = mid - 1\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return first\n        \n        def findLast(nums, target):\n            left, right = 0, len(nums) - 1\n            last = -1\n            while left <= right:\n                mid = left + (right - left) // 2\n                if nums[mid] == target:\n                    last = mid\n                    left = mid + 1\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return last\n        \n        first = findFirst(nums, target)\n        last = findLast(nums, target)\n        return [first, last]\n\n4.  Two-Pointer Approach:\n\nInitialize two pointers, left and right, to the beginning and end of the array, respectively.\nInitialize two variables, first and last, to -1.\nUse a while loop with the condition left <= right.\nCalculate the middle index as (left + right) / 2.\nIf the middle element is equal to the target, update first and last accordingly and adjust the pointers.\nIf the middle element is less than the target, update left.\nIf the middle element is greater than the target, update right.\nContinue the loop until left is less than or equal to right.\nReturn first and last.\n\nComplexity\n\n\n⏱️ Time Complexity: O(n) - One pass through the array using two pointers.\n\n\n🚀 Space Complexity: O(1) - Constant extra space is used.\n\n\nCode\nPythonJavaC++Cclass Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        left, right = 0, len(nums) - 1\n        first, last = -1, -1\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                first = mid\n                last = mid\n                while first > 0 and nums[first - 1] == target:\n                    first -= 1\n                while last < len(nums) - 1 and nums[last + 1] == target:\n                    last += 1\n                return [first, last]\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return [first, last]\n\n🏆Conclusion:\nThe most effective methods are Methods 3 and 4, which have constant space complexity and an O(n) time complexity.\n💡 I invite you to check out my profile for detailed explanations and code for each method. Happy coding and learning! 📚",
        views: "23493",
        upvotes: "131",
        author_id: "358",
        problem_id: 35,
      },
    ],
  },
  {
    title: "35. Search Insert Position",
    description:
      "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\n \nExample 1:\n\nInput: nums = [1,3,5,6], target = 5\nOutput: 2\n\n\nExample 2:\n\nInput: nums = [1,3,5,6], target = 2\nOutput: 1\n\n\nExample 3:\n\nInput: nums = [1,3,5,6], target = 7\nOutput: 4\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 104\n\t-104 <= nums[i] <= 104\n\tnums contains distinct values sorted in ascending order.\n\t-104 <= target <= 104\n\n",
    difficulty: "Easy",
    acceptance: "45.16",
    frequency: "35.99",
    topics: [
      [
        "Binary Search",
        "Counting",
        "Hash Function",
        "String",
        "Heap (Priority Queue)",
        "Bucket Sort",
        "Radix Sort",
        "Memoization",
        "Reservoir Sampling",
        "Database",
      ],
    ],
    languages: [
      [
        "Scala",
        "Elixir",
        "Kotlin",
        "C",
        "Go",
        "Rust",
        "C++",
        "Python3",
        "Erlang",
        "Java",
      ],
    ],
    comments: [
      {
        author_id: "86",
        problem_id: 36,
        body: "Как я мог не догадаться о таком подходе? Спасибо за отличное объяснение!",
        comment_reply_id: null,
      },
      {
        author_id: "20",
        problem_id: 36,
        body: "Когда я столкнулся с этой задачей впервые, я думал, что это невозможно. Теперь я знаю иначе!",
        comment_reply_id: null,
      },
      {
        author_id: "485",
        problem_id: 36,
        body: "Наконец-то я справился с этой задачей! Вперед к следующей!",
        comment_reply_id: null,
      },
      {
        author_id: "617",
        problem_id: 36,
        body: "Я так рад, что решил эту задачу! Это действительно научило меня чему-то новому.",
        comment_reply_id: null,
      },
      {
        author_id: "825",
        problem_id: 36,
        body: "Наконец-то, я разобрался с этой задачей! Спасибо за все подсказки.",
        comment_reply_id: null,
      },
      {
        author_id: "912",
        problem_id: 36,
        body: "Не могу поверить, что я наконец-то разобрался с этой задачей. Спасибо, сообщество!",
        comment_reply_id: null,
      },
      {
        author_id: "571",
        problem_id: 36,
        body: "Всегда думал, что эта задача невозможна. Но вот я, сделал это!",
        comment_reply_id: null,
      },
      {
        author_id: "415",
        problem_id: 36,
        body: "Чувствую, что становлюсь лучше программистом с каждой решенной задачей.",
        comment_reply_id: null,
      },
      {
        author_id: "783",
        problem_id: 36,
        body: "Теперь я чувствую, что могу решить что угодно!",
        comment_reply_id: null,
      },
      {
        author_id: "597",
        problem_id: 36,
        body: "Сложно поверить, что я только что решил это! Спасибо всем за поддержку.",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "[VIDEO] Visualization of Binary Search Solution",
        body: "\nIf we simply iterated over the entire array to find the target, the algorithm would run in O(n) time.  We can improve this by using binary search instead to find the element, which runs in O(log n) time (see the video for a review of binary search).\nNow, why does binary search run in O(log n) time?  Well, with each iteration, we eliminate around half of the array.  So now the question is: how many iterations does it take to converge on a single element?  In other words, how many times do we need to divide n by 2 until we reach 1?\nIf k is the number of times we need to divide n by 2 to reach 1, then the equation is:\nn / 2k = 1\nn = 2k   (multiply both sides by  2k)\nlog2n = k   (definition of logarithms)\nSo we know that it takes log2n steps in the worst case to find the element.   But in Big O notation, we drop the base, so this ends up running in O(log n) time.\nIf the target was not in the array, then we need to figure out what index the target would be at if it were inserted in sorted order.  For a detailed visualization, please see the video (it's difficult to describe here) but basically, at the end of the loop, the left pointer will have passed the right pointer (so l > r) and the target needs to be inserted between them.  Inserting at index r actually ends up inserting the target at 1 spot behind the correct spot, so inserting at index l is the correct answer.\nCode\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        l = 0\n        r = len(nums) - 1\n        while l <= r:\n            mid = (l + r) // 2\n            if nums[mid] < target:\n                l = mid + 1\n            elif nums[mid] > target:\n                r = mid - 1\n            else:\n                return mid\n        return l\n        ",
        views: "212",
        upvotes: "4",
        author_id: "550",
        problem_id: 36,
      },
      {
        title: "Ya It BEATS 100% || but why is this RUNNING??",
        body: "Intuition\n\nyou dont know about a internal binary search that java can perform.\nApproach\n\n\n\nLeveraging Binary Search:\n\nint ans = Arrays.binarySearch(nums, target): This line directly uses the Arrays.binarySearch() method. It performs a binary search on the sorted array nums to find the index of the target value (target).\n\n\n\nHandling Not Found Cases:\n\nif (ans < 0): Checks if the returned value (ans) from the binary search is negative.\n\nA negative value from binarySearch indicates the target element was not found in the array. The absolute value (-ans) represents the insertion point where the target should be inserted to maintain the sorted order. However, it might not be the exact index at the end of the array.\nreturn -ans - 1: To compensate for this, the code subtracts 1 from the negative absolute value (-ans) and returns it. This ensures the returned index represents the correct insertion position, either within the existing elements or at the end of the array.\n\n\n\n\n\nHandling Found Cases:\n\nIf ans is not negative (i.e., greater than or equal to 0), it means the binary search found the target element at the corresponding index in the array. The code simply returns this index (ans) directly.\n\n\n\nComplexity\n\nTime complexity:\n\n\nO(nlogn)\n\nSpace complexity:\n\n\nO(1)\nCode\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int ans=Arrays.binarySearch(nums,target);\n        if(ans<0){\n            return -ans-1;\n        }\n        return ans;\n    }\n}",
        views: "373",
        upvotes: "3",
        author_id: "333",
        problem_id: 36,
      },
      {
        title: "Easy and Simple C++ approach | Binary search :)",
        body: "Approach\n\nbinary seaerch approach is damn easy for this question and also easy to think of it.\nthe array is sorted so we just have to fugure out where should it be placed.\nso we just have to figure out the position at which the prevoius value is less that our element and next value is more than our element.\nThats how its figured out that it's a binary seach problem.\n\n\nComplexity\n\nTime complexity: O(log(n))\n\n\n\nSpace complexity: O(1)\n\n\nUpvote! It only takes 1 click :)\nCode\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int low=0;\n        int high=nums.size();\n        int mid;\n        if(target>nums[high-1]){\n            return high;\n        }\n        while(low<=high){\n              mid=(low+high)/2;\n            if(nums[mid]==target){  \n                return mid;\n            }\n          \n            if(target<nums[mid]){     \n            high=mid-1;    \n            }else{\n            low=mid+1;        \n            }\n          \n        }\n         return  low;   \n    }\n};\n",
        views: "52281",
        upvotes: "489",
        author_id: "551",
        problem_id: 36,
      },
      {
        title: "✅fastest JAVA solution",
        body: "Time complexity: O(logn)O(logn)O(logn)\nSpace Complexity: O(1)O(1)O(1)\nExplanation with examples & illustration\n\nJAVA CODE\nJAVAclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int start = 0;\n        int end = nums.length-1;\n\n        while (start <= end) {\n            int mid = start + (end-start)/2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] > target) end = mid-1;\n            else start = mid+1;\n        }\n\n        return start;\n    }\n}\n",
        views: "70593",
        upvotes: "500",
        author_id: "393",
        problem_id: 36,
      },
    ],
  },
  {
    title: "36. Valid Sudoku",
    description:
      'Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n\n\n\tEach row must contain the digits 1-9 without repetition.\n\tEach column must contain the digits 1-9 without repetition.\n\tEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\n\n\nNote:\n\n\n\tA Sudoku board (partially filled) could be valid but is not necessarily solvable.\n\tOnly the filled cells need to be validated according to the mentioned rules.\n\n\n \nExample 1:\n\nInput: board = \n[["5","3",".",".","7",".",".",".","."]\n,["6",".",".","1","9","5",".",".","."]\n,[".","9","8",".",".",".",".","6","."]\n,["8",".",".",".","6",".",".",".","3"]\n,["4",".",".","8",".","3",".",".","1"]\n,["7",".",".",".","2",".",".",".","6"]\n,[".","6",".",".",".",".","2","8","."]\n,[".",".",".","4","1","9",".",".","5"]\n,[".",".",".",".","8",".",".","7","9"]]\nOutput: true\n\n\nExample 2:\n\nInput: board = \n[["8","3",".",".","7",".",".",".","."]\n,["6",".",".","1","9","5",".",".","."]\n,[".","9","8",".",".",".",".","6","."]\n,["8",".",".",".","6",".",".",".","3"]\n,["4",".",".","8",".","3",".",".","1"]\n,["7",".",".",".","2",".",".",".","6"]\n,[".","6",".",".",".",".","2","8","."]\n,[".",".",".","4","1","9",".",".","5"]\n,[".",".",".",".","8",".",".","7","9"]]\nOutput: false\nExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8\'s in the top left 3x3 sub-box, it is invalid.\n\n\n \nConstraints:\n\n\n\tboard.length == 9\n\tboard[i].length == 9\n\tboard[i][j] is a digit 1-9 or \'.\'.\n\n',
    difficulty: "Medium",
    acceptance: "36.04",
    frequency: "128.66",
    topics: [
      [
        "Eulerian Circuit",
        "Trie",
        "Hash Table",
        "Iterator",
        "Rejection Sampling",
        "String Matching",
        "Geometry",
        "Two Pointers",
        "Binary Search Tree",
        "Randomized",
      ],
    ],
    languages: [
      [
        "Swift",
        "Go",
        "Kotlin",
        "Scala",
        "PHP",
        "Python3",
        "Rust",
        "Erlang",
        "TypeScript",
        "Dart",
      ],
    ],
    comments: [
      {
        author_id: "571",
        problem_id: 37,
        body: "Кто-нибудь сталкивался с такой ошибкой раньше? Не могу понять, в чем проблема.",
        comment_reply_id: null,
      },
      {
        author_id: "377",
        problem_id: 37,
        body: "Подсказки были такими полезными! Они действительно помогли мне решить эту задачу.",
        comment_reply_id: null,
      },
      {
        author_id: "810",
        problem_id: 37,
        body: "Подсказки были такими полезными! Они действительно помогли мне решить эту задачу.",
        comment_reply_id: null,
      },
      {
        author_id: "237",
        problem_id: 37,
        body: "Эта задача преподнесла мне неожиданный поворот! Интересно, как многие это заметили.",
        comment_reply_id: null,
      },
      {
        author_id: "56",
        problem_id: 37,
        body: "Когда я столкнулся с этой задачей впервые, я думал, что это невозможно. Теперь я знаю иначе!",
        comment_reply_id: null,
      },
      {
        author_id: "381",
        problem_id: 37,
        body: "Чувствую себя чемпионом после этой задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "498",
        problem_id: 37,
        body: "Иногда лучшее решение приходит в голову после нескольких неудачных попыток.",
        comment_reply_id: null,
      },
      {
        author_id: "642",
        problem_id: 37,
        body: "Это было как головоломка, но я нашел свой путь к решению!",
        comment_reply_id: null,
      },
      {
        author_id: "590",
        problem_id: 37,
        body: "Было трудно, но я нашел путь к решению этой задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "950",
        problem_id: 37,
        body: "Мой мозг сейчас в кипении от этой задачи.",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "Short+Simple Java using Strings",
        body: 'Collect the set of things we see, encoded as strings. For example:\n\n\'4\' in row 7 is encoded as "(4)7".\n\'4\' in column 7 is encoded as "7(4)".\n\'4\' in the top-right block is encoded as "0(4)2".\n\nScream false if we ever fail to add something because it was already added (i.e., seen before).\npublic boolean isValidSudoku(char[][] board) {\n    Set seen = new HashSet();\n    for (int i=0; i<9; ++i) {\n        for (int j=0; j<9; ++j) {\n            if (board[i][j] != \'.\') {\n                String b = "(" + board[i][j] + ")";\n                if (!seen.add(b + i) || !seen.add(j + b) || !seen.add(i/3 + b + j/3))\n                    return false;\n            }\n        }\n    }\n    return true;\n}\n\nEdit: Just occurred to me that we can also make it really clear and self-explaining. I\'m loving it.\npublic boolean isValidSudoku(char[][] board) {\n    Set seen = new HashSet();\n    for (int i=0; i<9; ++i) {\n        for (int j=0; j<9; ++j) {\n            char number = board[i][j];\n            if (number != \'.\')\n                if (!seen.add(number + " in row " + i) ||\n                    !seen.add(number + " in column " + j) ||\n                    !seen.add(number + " in block " + i/3 + "-" + j/3))\n                    return false;\n        }\n    }\n    return true;\n}',
        views: "204235",
        upvotes: "3.1K",
        author_id: "297",
        problem_id: 37,
      },
      {
        title:
          "Beats 96.78% || Short 7-line Python solution (with detailed explanation)",
        body: '1)It initializes an empty list called "res", which will be used to store all the valid elements in the board.\n2)It loops through each cell in the board using two nested "for" loops.\nFor each cell, it retrieves the value of the element in that cell and stores it in a variable called "element".\n3)If the element is not a dot (\'.\'), which means it\'s a valid number, the method adds three tuples to the "res" list:\n\nThe first tuple contains the row index (i) and the element itself.\nThe second tuple contains the element itself and the column index (j).\nThe third tuple contains the floor division of the row index by 3 (i // 3), the floor division of the column index by 3 (j // 3), and the element itself. This tuple represents the 3x3 sub-grid that the current cell belongs to.\n\n4)After processing all the cells, the method checks if the length of "res" is equal to the length of the set of "res".\nclass Solution(object):\n    def isValidSudoku(self, board):\n        res = []\n        for i in range(9):\n            for j in range(9):\n                element = board[i][j]\n                if element != \'.\':\n                    res += [(i, element), (element, j), (i // 3, j // 3, element)]\n        return len(res) == len(set(res))\n',
        views: "45724",
        upvotes: "265",
        author_id: "961",
        problem_id: 37,
      },
      {
        title: "The Ultimate Nested Loops",
        body: "Code\npublic class Solution {\n    public bool IsValidSudoku(char[][] board) {\n        return ((Rows(board)&&Cols(board))&&squares(board));\n    }\n    private bool Rows(char[][] board)\n    {\n    bool result = true;\n    \n    for (int i = 0; i < 9; i++)\n    {\n        for (int j = 0; j < 9; j++)\n        {\n            for (int k = j + 1; k < 9; k++)\n            {\n                if (board[i][j] != '.' && board[i][j] == board[i][k])\n                {\n                    result = false;\n                    return result;\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n    }\n    private bool Cols(char[][] board)\n    {\n        bool result = true;\n        for (int j = 0; j < 9; j++)\n        {\n            for (int i = 0; i < 9; i++)\n            {\n                for (int k = i + 1; k < 9; k++)\n                {\n                    if (board[i][j] != '.' && board[i][j] == board[k][j])\n                    {\n                        result = false;\n                        return result;\n                        break;\n                    }\n                }\n            }\n        }\n        return result;\n    }\nprivate bool squares(char[][] board)\n{\n    bool result = true;\n\n    for (int blockRow = 0; blockRow < 9; blockRow += 3)\n    {\n        for (int blockCol = 0; blockCol < 9; blockCol += 3)\n        {\n            for (int i = blockRow; i < blockRow + 3; i++)\n            {\n                for (int j = blockCol; j < blockCol + 3; j++)\n                {\n                    for (int k = i; k < blockRow + 3; k++)\n                    {\n                        for (int l = (k == i) ? j + 1 : blockCol; l < blockCol + 3; l++)\n                        {\n                            if (board[i][j] != '.' && board[i][j] == board[k][l])\n                            {\n                                result = false;\n                                return result;  // Terminate early once a duplicate is found\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}\n\n}",
        views: "715",
        upvotes: "0",
        author_id: "371",
        problem_id: 37,
      },
      {
        title: "My short solution by C++. O(n2)",
        body: "Three flags are used to check whether a number appear.\nused1: check each row\nused2: check each column\nused3: check each sub-boxes\nclass Solution\n{\npublic:\n    bool isValidSudoku(vector<vector<char> > &board)\n    {\n        int used1[9][9] = {0}, used2[9][9] = {0}, used3[9][9] = {0};\n        \n        for(int i = 0; i < board.size(); ++ i)\n            for(int j = 0; j < board[i].size(); ++ j)\n                if(board[i][j] != '.')\n                {\n                    int num = board[i][j] - '0' - 1, k = i / 3 * 3 + j / 3;\n                    if(used1[i][num] || used2[j][num] || used3[k][num])\n                        return false;\n                    used1[i][num] = used2[j][num] = used3[k][num] = 1;\n                }\n        \n        return true;\n    }\n};",
        views: "120471",
        upvotes: "1.1K",
        author_id: "158",
        problem_id: 37,
      },
    ],
  },
  {
    title: "37. Sudoku Solver",
    description:
      'Write a program to solve a Sudoku puzzle by filling the empty cells.\n\nA sudoku solution must satisfy all of the following rules:\n\n\n\tEach of the digits 1-9 must occur exactly once in each row.\n\tEach of the digits 1-9 must occur exactly once in each column.\n\tEach of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\n\n\nThe \'.\' character indicates empty cells.\n\n \nExample 1:\n\nInput: board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]\nOutput: [["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]\nExplanation: The input board is shown above and the only valid solution is shown below:\n\n\n\n\n \nConstraints:\n\n\n\tboard.length == 9\n\tboard[i].length == 9\n\tboard[i][j] is a digit or \'.\'.\n\tIt is guaranteed that the input board has only one solution.\n\n',
    difficulty: "Hard",
    acceptance: "38.04",
    frequency: "6.89",
    topics: [
      [
        "Matrix",
        "Iterator",
        "Shell",
        "Recursion",
        "Bit Manipulation",
        "Prefix Sum",
        "Merge Sort",
        "String Matching",
        "Biconnected Component",
        "Backtracking",
      ],
    ],
    languages: [
      [
        "Dart",
        "JavaScript",
        "Python3",
        "Elixir",
        "Python",
        "Kotlin",
        "C++",
        "Java",
        "Racket",
        "Erlang",
      ],
    ],
    comments: [
      {
        author_id: "527",
        problem_id: 38,
        body: "Чувствую, что становлюсь лучше с каждой решенной задачей!",
        comment_reply_id: null,
      },
      {
        author_id: "262",
        problem_id: 38,
        body: "Идея для этого решения пришла ко мне во сне! Удивительно, как мозг работает иногда.",
        comment_reply_id: null,
      },
      {
        author_id: "482",
        problem_id: 38,
        body: "Мой мозг сейчас в кипении от этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "209",
        problem_id: 38,
        body: "Это был настоящий вызов для моего ума, но я его преодолел!",
        comment_reply_id: null,
      },
      {
        author_id: "976",
        problem_id: 38,
        body: "Как я мог не догадаться о таком подходе? Спасибо за отличное объяснение!",
        comment_reply_id: null,
      },
      {
        author_id: "294",
        problem_id: 38,
        body: "Какие интересные подходы у других людей к этой задаче",
        comment_reply_id: null,
      },
      {
        author_id: "358",
        problem_id: 38,
        body: "Эта задача заставила меня использовать все свои ресурсы!",
        comment_reply_id: null,
      },
      {
        author_id: "928",
        problem_id: 38,
        body: "Эта задача вынудила меня глубже погрузиться в язык программирования.",
        comment_reply_id: null,
      },
      {
        author_id: "158",
        problem_id: 38,
        body: "Эта задача мне не давала покоя, но теперь я горд собой!",
        comment_reply_id: null,
      },
      {
        author_id: "809",
        problem_id: 38,
        body: "Не могу поверить, что я решил это без помощи Google!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "[C++] Best Solution - Backtracking - Clean - Easy for beginner",
        body: "Code\nclass Solution {\npublic:\n    bool row[9][10], col[9][10], sq[9][10];\n\n    bool isValid(int i, int j, int num) {\n        int k = (i / 3) * 3 + (j / 3);\n        return !row[i][num] && !col[j][num] && !sq[k][num];\n    }\n\n    void visit(int i, int j, int num) {\n        int k = (i / 3) * 3 + (j / 3);\n        row[i][num] = col[j][num] = sq[k][num] = true;\n    }\n\n    void unvisit(int i, int j, int num) {\n        int k = (i / 3) * 3 + (j / 3);\n        row[i][num] = col[j][num] = sq[k][num] = false;\n    }\n\n    bool Backtrack(vector<vector<char>>& board, int i, int j) {\n        if (i == 9) return true;\n        if (j == 9) return Backtrack(board, i + 1, 0);\n        if (board[i][j] != '.') return Backtrack(board, i, j + 1);\n\n        for (int num = 1; num <= 9; num++) {\n            if (isValid(i, j, num)) {\n                board[i][j] = num + '0';\n                visit(i, j, num);\n                if (Backtrack(board, i, j + 1)) return true;\n                board[i][j] = '.';\n                unvisit(i, j, num);\n            }\n        }\n        return false;\n    }\n\n    void solveSudoku(vector<vector<char>>& board) {\n        memset(row, false, sizeof(row));\n        memset(col, false, sizeof(col));\n        memset(sq, false, sizeof(sq));\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (board[i][j] != '.') {\n                    int num = board[i][j] - '0';\n                    visit(i, j, num);\n                }\n            }\n        }\n        Backtrack(board, 0, 0);\n    }\n};\n",
        views: "504",
        upvotes: "2",
        author_id: "217",
        problem_id: 38,
      },
      {
        title: "Beginner-friendly Solution Using C++ || Backtracking || Clear",
        body: "Code\nclass Solution {\npublic:\n    bool row[9][10], col[9][10], square[9][10];\n\n    bool dfs(int cell, vector<vector<char>>& board)\n    {\n        if (cell == 81) return true;\n\n        int i = cell / 9, j = cell % 9;\n\n        // This cell was written\n        if (board[i][j] != '.') {\n            return (dfs(cell + 1, board));\n        }\n\n        // was not writen\n        for (int k = 1; k <= 9; k++)\n        {\n            if (!row[i][k] && !col[j][k] && !square[(i / 3) * 3 + j / 3][k])\n            {\n                board[i][j] = '0' + k;\n                row[i][k] = col[j][k] = square[(i / 3) * 3 + j / 3][k] = true;\n                if (dfs(cell + 1, board)) return true;\n                board[i][j] = '.';\n                row[i][k] = col[j][k] = square[(i / 3) * 3 + j / 3][k] = false;\n            }\n        }\n\n        return false;\n    }\n\n    void solveSudoku(vector<vector<char>>& board) {\n        for (int i = 0; i < 9; i++)\n        {\n            for (int j = 0; j < 9; j++)\n            {\n                if (board[i][j] != '.')\n                {\n                    int k = board[i][j] - '0';\n                    row[i][k] = col[j][k] = square[(i / 3) * 3 + j / 3][k] = true;\n                }\n            }\n        }\n        dfs(0, board);\n    }\n};",
        views: "114",
        upvotes: "1",
        author_id: "850",
        problem_id: 38,
      },
      {
        title: "💯✅🔥Easy Java Solution|| 11ms || ≧◠‿◠≦✌",
        body: "Intuition\n\nThe provided code is a solution to the classic problem of solving a Sudoku puzzle. It uses a backtracking algorithm to fill in the empty cells of the board with valid numbers from 1 to 9. The algorithm checks if a number is valid by ensuring it does not already exist in the same row, column, or 3x3 block. If a number is valid, it is placed in the cell and the algorithm recursively tries to fill in the remaining empty cells. If a cell cannot be filled with any valid number, the algorithm backtracks by resetting the cell to its original state and trying a different number.\nApproach\n\nThe approach used in this code is a recursive backtracking algorithm. It iterates through each cell in the board, and if a cell is empty, it tries each number from 1 to 9. For each number, it checks if the number is valid by calling the isValid method. If the number is valid, it places the number in the cell and recursively calls the solve method to fill in the remaining empty cells. If the solve method returns true, indicating that the board is solved, the algorithm returns true. If the solve method returns false, indicating that the board cannot be solved with the current number, the algorithm backtracks by resetting the cell to its original state and trying a different number.\nComplexity\n\nTime complexity:O(9^(n-m)\n\n\n\nSpace complexity:O(n)\n\n\nCode\nclass Solution {\n    public void solveSudoku(char[][] board) {\n         if(board == null || board.length == 0) return;\n        solve(board);\n    }\n    public boolean solve(char[][] board){\n        for(int i=0; i<board.length; i++){\n            for(int j=0; j<board[0].length; j++){\n                if(board[i][j] == '.'){\n                    for(char c='1'; c<='9'; c++){ //try all number from 1 to 9\n                        if(isValid(board, i, j, c)){\n                            board[i][j] = c; //put c for this cell\n                            \n                            if(solve(board)) return true; //If it's the solution return true\n                            else board[i][j] = '.';  //Otherwise go back\n                        }  \n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    private boolean isValid(char [][] board, int row, int col, char c){\n        for(int i=0; i<9; i++){\n            if(board[i][col] != '.' && board[i][col] == c) return false; //check row\n            if(board[row][i] != '.' && board[row][i] == c) return false; //check column\n            if(board[3*(row/3) + i/3][3*(col/3) + i%3] != '.' && \n               board[3*(row/3) + i/3][3*(col/3) + i%3] == c) return false; //check 3*3block\n        }\n        return true; \n    }  \n    \n}\n",
        views: "205",
        upvotes: "3",
        author_id: "549",
        problem_id: 38,
      },
      {
        title: "Fastest Java (Recursion + Back-Tracking) Solution.",
        body: "Intuition\nThe Sudoku puzzle can be solved using a backtracking approach. We iterate through each cell in the Sudoku board, trying out possible numbers for each empty cell while ensuring that the chosen number doesn't violate Sudoku rules.\nApproach\n\nInitialize arrays to keep track of numbers already present in each row, column, and 3x3 cell.\nIterate through each cell in the Sudoku board.\nIf the cell is empty, try placing numbers from 1 to 9.\nCheck if the number is not already present in the same row, column, or cell.\nIf conditions are met, place the number and proceed to the next cell.\nIf a solution is not found, backtrack and try a different number.\nRepeat this process until a valid solution is found.\n\nComplexity\n\nTime complexity:\nO(9^m*n),In the worst case, we try 9 possibilities for each empty cell.\nSpace complexity:\nO(1) as we use constant space for the arrays.\n\nCode\nclass Solution {\n    public void solveSudoku(char[][] board) {\n        int[][] f=new int[9][10];\n        int[][] row=new int[9][10];\n        int[][] col=new int[9][10];\n        int cell=0;\n        for(int i=0;i<9;i++){\n            for(int j=0;j<9;j++){\n             cell=((i/3)*3)+j/3;\n             if(board[i][j]!='.'){\n             f[cell][(int)(board[i][j]-'0')]=1;\n             row[i][(int)(board[i][j]-'0')]=1;\n             col[j][(int)(board[i][j]-'0')]=1;\n            }}\n        }\n        get(f,board,0,0,row,col);\n        return;\n\n    }\n    static boolean get(int[][] f,char[][] board, int i, int j, int[][] row, int[][] col ){\n        if(i==9)return true;\n        if(board[i][j]!='.'){\n            if(j==8){\n                return get(f,board,i+1,0,row,col);\n            }else{\n                return get(f,board,i,j+1,row,col);\n            }\n        }else{\n            boolean t=false;\n            int cell=((i/3)*3) + j/3;\n            for(int k=1;k<=9;k++){\n                if(f[cell][k]==0 && row[i][k]==0 && col[j][k]==0){\n                    f[cell][k]=1;\n                    row[i][k]=1;\n                    col[j][k]=1;\n                    board[i][j]=(char) (k + '0');\n                    if(j==8){\n                        t=get(f,board,i+1,0,row,col);\n                    }else{\n                        t=get(f,board,i,j+1,row,col);\n                    }\n                    if(t)return true;\n                    f[cell][k]=0;\n                    row[i][k]=0;\n                    col[j][k]=0;\n                    board[i][j]='.';\n                }\n            }\n        }\n       return false;\n    }\n\n}",
        views: "99",
        upvotes: "2",
        author_id: "323",
        problem_id: 38,
      },
    ],
  },
  {
    title: "38. Count and Say",
    description:
      'The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\n\n\tcountAndSay(1) = "1"\n\tcountAndSay(n) is the run-length encoding of countAndSay(n - 1).\n\n\nRun-length encoding (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string "3322251" we replace "33" with "23", replace "222" with "32", replace "5" with "15" and replace "1" with "11". Thus the compressed string becomes "23321511".\n\nGiven a positive integer n, return the nth element of the count-and-say sequence.\n\n \nExample 1:\n\n\nInput: n = 4\n\nOutput: "1211"\n\nExplanation:\n\ncountAndSay(1) = "1"\ncountAndSay(2) = RLE of "1" = "11"\ncountAndSay(3) = RLE of "11" = "21"\ncountAndSay(4) = RLE of "21" = "1211"\n\n\n\nExample 2:\n\n\nInput: n = 1\n\nOutput: "1"\n\nExplanation:\n\nThis is the base case.\n\n\n \nConstraints:\n\n\n\t1 <= n <= 30\n\n\n \nFollow up: Could you solve it iteratively?',
    difficulty: "Medium",
    acceptance: "29.05",
    frequency: "79.35",
    topics: [
      [
        "Randomized",
        "Topological Sort",
        "Minimum Spanning Tree",
        "Prefix Sum",
        "Quickselect",
        "String",
        "Shell",
        "Counting",
        "Hash Function",
        "Reservoir Sampling",
      ],
    ],
    languages: [
      [
        "Python",
        "TypeScript",
        "Python3",
        "Rust",
        "Scala",
        "Kotlin",
        "PHP",
        "C",
        "C++",
        "Elixir",
      ],
    ],
    comments: [
      {
        author_id: "485",
        problem_id: 39,
        body: "Сколько времени я потратил на решение этой задачи? Не считаясь!",
        comment_reply_id: null,
      },
      {
        author_id: "781",
        problem_id: 39,
        body: "Мой мозг сейчас в кипении от этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "949",
        problem_id: 39,
        body: "Это моя новая любимая задача! Хочу попробовать еще раз!",
        comment_reply_id: null,
      },
      {
        author_id: "586",
        problem_id: 39,
        body: "Это было круто! Какая следующая задача?",
        comment_reply_id: null,
      },
      {
        author_id: "75",
        problem_id: 39,
        body: "Не могу поверить, что решил это за одну попытку! Сейчас немного в шоке.",
        comment_reply_id: null,
      },
      {
        author_id: "852",
        problem_id: 39,
        body: "Чувствую себя настоящим гений после того, как решил эту задачу!",
        comment_reply_id: null,
      },
      {
        author_id: "600",
        problem_id: 39,
        body: "Кто-нибудь сталкивался с такой ошибкой раньше? Не могу понять, в чем проблема.",
        comment_reply_id: null,
      },
      {
        author_id: "908",
        problem_id: 39,
        body: "Подсказки были такими полезными! Они действительно помогли мне решить эту задачу.",
        comment_reply_id: null,
      },
      {
        author_id: "537",
        problem_id: 39,
        body: "Мой мозг сейчас в кипении от этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "130",
        problem_id: 39,
        body: "Это был настоящий вызов для моего ума, но я его преодолел!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "It's a good question, let me explain it.",
        body: 'When I first read the question, I don\'t really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is "1". That\'s why the title of the question is "Count and Say". The last result is "1", just one "1", so this result is "11"\nNow we keep going, the last result is "11", so there are 2 "1" in the result, so this time the result is "21".\nFor this time, we know last result is "21", which means there are one "2" and one "1", the result is "1211"\n....\nNow we do a test, if the (n-1)th result is "12212333312111238"(I typed it randomly), what is the n th result? Let\'s count it. one "1", two "2", one "1" , one "2" , four"3" , one "1" , one "2", three"1", one "2", one"3" and one "8".Therefore, the result is "1122111243111231121318"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is "1". No explanation.\nclass Solution:\n\tdef countAndSay(self, n):\n\t\t"""\n\t\t:type n: int\n\t\t:rtype: str\n\t\t"""\n\t\tif n == 1:\n\t\t\treturn "1"\n\t\treturn self.count(self.countAndSay(n - 1))\n\t\t\n\tdef count(self , s):\n\t\tc = s[0]\n\t\tcount = 1\n\t\tres = ""\n\t\tfor char in s[1 : ]:\n\t\t\tif char == c:\n\t\t\t\tcount += 1\n\t\t\telse:\n\t\t\t\tres  = res + str(count) + c\n\t\t\t\tc = char\n\t\t\t\tcount = 1\n\t\tres = res + str(count) + c\n\t\treturn res\neasy question , but good, just need to understand it',
        views: "7597",
        upvotes: "103",
        author_id: "955",
        problem_id: 39,
      },
      {
        title: "Beats 85.93%of users with JavaScript",
        body: "Code\n var countAndSay = function(n) { \n    if(n==1) return '1';\n    let str = '1';\n    for(let i=1; i<n; i++) str = createContainers(str);\n     \n    return str; \n};\n\nfunction createContainers(str) {\n    let arr = [], ch = '';\n    for(let i=0; i<str.length; i++) {\n        if(str[i] == str[i+1]) ch += str[i];\n        else {\n            ch += str[i];\n            arr.push(ch);\n            ch = '';\n        }\n    }\n    return say(arr);\n}\nfunction say(numStrArr) {\n    let str = ''\n    for(let i in numStrArr) str += numStrArr[i].length + numStrArr[i][0];\n    \n    return str;\n}\n\nvar countAndSay = function(n) {\n    if(n==1) return '1';\n    let str = '1';\n    for(let i=1; i<n; i++) str = createContainers(str); \n    return str; \n};\n\nfunction createContainers(str) {\n    let frequency = 1, string = '';\n    for(let i=0; i<str.length; i++) {\n        if(str[i] != str[i+1]) {\n            string += frequency + str[i];\n            frequency = 1;\n        } else frequency++;\n    }\n    return string;\n}\n",
        views: "1407",
        upvotes: "1",
        author_id: "564",
        problem_id: 39,
      },
      {
        title: "Javascript Solution | Simple & easy",
        body: "Code\n/**\n * @param {number} n\n * @return {string}\n */\nvar countAndSay = function(n) {\n    let say = '1';\n  while (n > 1) {\n    let count = 0;\n    let next = '';\n    for (let i = 0; i <= say.length; i++) {\n      if (i === say.length || (i > 0 && say[i] !== say[i - 1])) {\n        next += count + say[i - 1];\n        count = 0;\n      }\n      count++;\n    }\n    say = next;\n    n--;\n  }\n  return say;\n};",
        views: "2065",
        upvotes: "1",
        author_id: "488",
        problem_id: 39,
      },
      {
        title: "JS very easy solution and very fast",
        body: "var countAndSay = function(n) {\n    if (n === 1) return '1';\n    \n    const current = countAndSay(n - 1);\n    let newOutput = '';\n    let currentNumber = current[0];\n    let count = 0;\n    for (let i = 0; i <= current.length; i++) {\n        if (current[i] === currentNumber) {\n            count++;\n        } else if (currentNumber) {\n            newOutput += `${count}${currentNumber}`;\n            \n            currentNumber = current[i];\n            count = 1;\n        }\n    }\n    \n    return newOutput;\n};",
        views: "1203",
        upvotes: "1",
        author_id: "372",
        problem_id: 39,
      },
    ],
  },
  {
    title: "39. Combination Sum",
    description:
      "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\n\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n\n \nExample 1:\n\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n\n\nExample 2:\n\nInput: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\n\n\nExample 3:\n\nInput: candidates = [2], target = 1\nOutput: []\n\n\n \nConstraints:\n\n\n\t1 <= candidates.length <= 30\n\t2 <= candidates[i] <= 40\n\tAll elements of candidates are distinct.\n\t1 <= target <= 40\n\n",
    difficulty: "Medium",
    acceptance: "70.19",
    frequency: "164.32",
    topics: [
      [
        "Concurrency",
        "Shell",
        "Database",
        "Binary Tree",
        "Suffix Array",
        "Interactive",
        "Rolling Hash",
        "Matrix",
        "Design",
        "Stack",
      ],
    ],
    languages: [
      [
        "C#",
        "Erlang",
        "C",
        "Ruby",
        "Python3",
        "PHP",
        "C++",
        "Python",
        "Elixir",
        "Java",
      ],
    ],
    comments: [
      {
        author_id: "525",
        problem_id: 40,
        body: "Не могу поверить, что я решил это без помощи Google!",
        comment_reply_id: null,
      },
      {
        author_id: "245",
        problem_id: 40,
        body: "Сложно поверить, что я только что решил это! Спасибо всем за поддержку.",
        comment_reply_id: null,
      },
      {
        author_id: "217",
        problem_id: 40,
        body: "Я так рад, что решил эту задачу! Это действительно научило меня чему-то новому.",
        comment_reply_id: null,
      },
      {
        author_id: "736",
        problem_id: 40,
        body: "Наконец-то, я разобрался с этой задачей! Спасибо за все подсказки.",
        comment_reply_id: null,
      },
      {
        author_id: "683",
        problem_id: 40,
        body: "Как я мог не догадаться о таком подходе? Спасибо за отличное объяснение!",
        comment_reply_id: null,
      },
      {
        author_id: "755",
        problem_id: 40,
        body: "Это моя новая любимая задача! Хочу попробовать еще раз!",
        comment_reply_id: null,
      },
      {
        author_id: "311",
        problem_id: 40,
        body: "Мой мозг сейчас в кипении от этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "341",
        problem_id: 40,
        body: "Когда я столкнулся с этой задачей впервые, я думал, что это невозможно. Теперь я знаю иначе!",
        comment_reply_id: null,
      },
      {
        author_id: "121",
        problem_id: 40,
        body: "Какие интересные подходы у других людей к этой задаче",
        comment_reply_id: null,
      },
      {
        author_id: "985",
        problem_id: 40,
        body: "Как приятно видеть, что мое решение работает!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title:
          "Video solution | 2 approaches with intuition explained in detail | C++ | Backtracking",
        body: 'Video\nHello every one i have created a video solution for this problem and solved this video by developing intutition for backtracking (its in hindi), i am pretty sure you will never have to look for solution for this video ever again after watching this, just make sure you have your concepts cleared from subset.\nHere i have used 2 approaches:\n\nwithout for loop\nwith for loop\n\nThis video is the part of my playlist "Master backtracking".\nVideo link: \nVideo link for subsets: \nPlaylist link: https://www.youtube.com/playlist?list=PLICVjZ3X1AcY5ai7at5OvS4ckXiMbWxCa\nCode\nclass Solution {\npublic:\nvoid comb(vector<int>& nums, vector<vector<int>>& res, vector<int>& temp, int idx,int target) {\n        // BC\n        if(target<0){\n            return;\n        }\n        if(target==0){\n            res.push_back(temp);\n            return;\n        }\n        int l=nums.size();\n        if(idx==l){\n            return;\n        }\n        temp.push_back(nums[idx]);\n        comb(nums, res, temp,idx,target-nums[idx]);\n        temp.pop_back();\n        comb(nums, res, temp,idx+1,target);\n        \n        return;\n    }\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n         vector<int> temp;\n        vector<vector<int>> res;\n        comb(candidates, res, temp, 0,target);\n        return res;\n    }\n};',
        views: "1348",
        upvotes: "10",
        author_id: "190",
        problem_id: 40,
      },
      {
        title: "Well commented solution",
        body: "Code\nclass Solution {\npublic:\n    // Function to find all unique combinations\n    // of candidates that sum up to the target\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        // Create a DP table where each index represents\n        // a target from 0 to 'target'\n        vector<vector<vector<int>>> dp(target + 1);\n        // Base case: there's one way to make the sum 0\n        // - with an empty combination\n        dp[0].push_back({});\n\n        // Iterate over all possible sums from 1 to 'target'\n        for (int i = 1; i <= target; i++) {\n            // Check each candidate to see if it can be used\n            // to form the current sum 'i'\n            for (int candidate : candidates) {\n                // Only consider this candidate if it is not\n                // greater than the sum 'i'\n                if (candidate <= i) {\n                    // Check all combinations that sum up to\n                    // 'i - candidate'\n                    for (auto& prev : dp[i - candidate]) {\n                        // Create a new combination by adding\n                        // the current candidate to it\n                        vector<int> temp(prev);\n                        temp.push_back(candidate);\n                        // Sort to handle uniqueness (avoid duplicates)\n                        sort(temp.begin(), temp.end());\n                        // If this new combination is not already in dp[i],\n                        // add it\n                        if (std::find(dp[i].begin(), dp[i].end(), temp) ==\n                            dp[i].end()) {\n                            dp[i].push_back(temp);\n                        }\n                    }\n                }\n            }\n        }\n        // Return all combinations that sum up to 'target'\n        return dp[target];\n    }\n};",
        views: "230",
        upvotes: "3",
        author_id: "639",
        problem_id: 40,
      },
      {
        title:
          "Iterative Solution with Diagrams in Video - C++, Java, Python, JS",
        body: 'Video\nPlease upvote here so others save time too!\nLike the video on YouTube if you found it useful\nClick here to subscribe on YouTube:\nhttps://www.youtube.com/@mayowadan?sub_confirmation=1\n\nJavaScriptPythonC++Java/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum = function (candidates, target) {\n    // Initialize dp\n    const dp = [[]];\n    for (let i = 1; i <= target; i++) {\n        dp[i] = [];\n    }\n    dp[0].push([]);\n\n    // For each value from 1 to target\n    for (let i = 1; i <= target; i++) {\n        // Iterate over candidates\n        for (let j = 0; j < candidates.length; j++) {\n            if (candidates[j] <= i) {\n                // Check previous results from dp\n                for (const prev of dp[i - candidates[j]]) {\n                    const temp = prev.concat(candidates[j]);\n\n                    temp.sort((a, b) => a - b);\n                    // If the new combination is not already in dp\n                    if (\n                        !dp[i].some(\n                            (combination) =>\n                                combination.join(",") === temp.join(",")\n                        )\n                    ) {\n                        dp[i].push(temp);\n                    }\n                }\n            }\n        }\n    }\n    // Return the combinations\n    return dp[target];\n}',
        views: "891",
        upvotes: "11",
        author_id: "646",
        problem_id: 40,
      },
      {
        title: "Clean code like me. Get Flowered.",
        body: "Intuition\n\nOverall Functionality:\n\nThe code leverages recursion to explore all choices of including or excluding numbers at each step.\nBacktracking ensures all valid combinations are considered without revisiting the same options.\nThe use of a separate temporary list al allows for efficient construction of combinations without affecting previous results.\n\nApproach\n\nCore Idea:\n\nIt recursively explores all possible ways to pick numbers from the candidates array such that their sum equals the target.\n\nSteps:\n\n\nInitializing Results:\n\nList<List<Integer>> ans = new ArrayList<>(): Creates an empty list ans to store the final results (all valid combinations).\n\n\n\nRecursive Function (findAns):\n\nvoid findAns(int[] nums, int target, int index, List<Integer> al): This recursive function is the core of the solution.\n\nnums: The original array of candidate numbers.\ntarget: The target sum to achieve.\nindex: Current index in the candidates array.\nal: A temporary list to store the current combination of numbers being constructed.\n\n\nif (target < 0): Base case 1 - checks if the current target becomes negative.\n\nIf the target becomes negative by adding a number, it means this path isn't valid (going over the target). The function returns (return;) to backtrack from this branch of recursion.\n\n\nif (index == nums.length): Base case 2 - checks if the end of the candidates array is reached.\n\nIf yes, it means we've tried all possible numbers from the array. But it also checks if the current target is zero.\n\nIf target is zero (target == 0), it means the previous selections in al exactly add up to the target. A copy of this valid combination is added to the ans list using ans.add(new ArrayList<>(al)) to avoid modifying the original al during backtracking.\n\n\nThe function then returns (return;) to backtrack from this branch of recursion.\n\n\nal.add(nums[index]): Includes the current element (nums[index]) from the candidates array in the temporary list al. This represents adding the number to the current combination.\nfindAns(nums, target - nums[index], index, al): Recursive call with adjusted target. This explores the possibility of including the current number (nums[index]). It reduces the target (target - nums[index]) by the value of the included number and keeps the same index and al to continue building the combination with the remaining target.\nal.remove(al.size() - 1): Backtracking step. Removes the element just added from al. This simulates the case of excluding the current number from the combination.\nfindAns(nums, target, index + 1, al): Recursive call with incremented index. This explores the possibility of excluding the current number. It moves to the next element (index + 1) in the candidates array and the modified al (without the last element) to build combinations that exclude the current number.\nreturn;: After the recursive calls for both including and excluding the current element, the function returns to continue backtracking up the recursion stack.\n\n\n\nReturning the Results:\n\nThe main combinationSum function calls findAns(candidates, target, 0, new ArrayList<>()) to start the recursion with an empty temporary list (al) and index 0 (index).\nAfter all recursive calls are done, the combinationSum function returns the ans list containing all possible valid combinations that add up to the target sum.\n\n\n\nComplexity\n\nTime complexity:\n\n\nO(2^n *k)\n\nSpace complexity:\n\n\nO(1)\nCode\nclass Solution {\n    List<List<Integer>> ans=new ArrayList<>();\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<Integer> al=new ArrayList<>();\n        findAns(candidates,target,0,al);\n        return ans;\n    }\n\n    public void findAns(int[] nums,int target,int index,List<Integer> al){\n        if(target<0){\n            return;\n        }\n        if(index==nums.length){\n            if(target==0){\n                ans.add(new ArrayList<>(al));\n            }\n            return ;\n        }\n        al.add(nums[index]);\n        findAns(nums,target-nums[index],index,al);\n        al.remove(al.size()-1);\n        findAns(nums,target,index+1,al);\n        return;\n    }\n    \n}",
        views: "74",
        upvotes: "2",
        author_id: "128",
        problem_id: 40,
      },
    ],
  },
  {
    title: "40. Combination Sum II",
    description:
      "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n\nEach number in candidates may only be used once in the combination.\n\nNote: The solution set must not contain duplicate combinations.\n\n \nExample 1:\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\n\nExample 2:\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n\n\n \nConstraints:\n\n\n\t1 <= candidates.length <= 100\n\t1 <= candidates[i] <= 50\n\t1 <= target <= 30\n\n",
    difficulty: "Medium",
    acceptance: "56.16",
    frequency: "48.28",
    topics: [
      [
        "Bucket Sort",
        "Merge Sort",
        "Hash Table",
        "Concurrency",
        "Backtracking",
        "Design",
        "Ordered Set",
        "Queue",
        "Divide and Conquer",
        "Binary Search",
      ],
    ],
    languages: [
      [
        "Racket",
        "Python3",
        "C#",
        "Kotlin",
        "C",
        "Ruby",
        "Python",
        "Rust",
        "Elixir",
        "Go",
      ],
    ],
    comments: [
      {
        author_id: "117",
        problem_id: 41,
        body: "Потратил на решение этой задачи весь день, но это было того стоило!",
        comment_reply_id: null,
      },
      {
        author_id: "627",
        problem_id: 41,
        body: "Эта задача была настоящим испытанием ума! Сложность на высшем уровне.",
        comment_reply_id: null,
      },
      {
        author_id: "195",
        problem_id: 41,
        body: "Благодаря этой задаче я узнал о новой функции языка программирования.",
        comment_reply_id: null,
      },
      {
        author_id: "602",
        problem_id: 41,
        body: "Как я мог пропустить этот трюк? Благодарю за подсказку!",
        comment_reply_id: null,
      },
      {
        author_id: "12",
        problem_id: 41,
        body: "Как я мог не догадаться о таком подходе? Спасибо за отличное объяснение!",
        comment_reply_id: null,
      },
      {
        author_id: "474",
        problem_id: 41,
        body: "Эта задача мне не давала покоя, но теперь я горд собой!",
        comment_reply_id: null,
      },
      {
        author_id: "25",
        problem_id: 41,
        body: "Это было круто! Какая следующая задача?",
        comment_reply_id: null,
      },
      {
        author_id: "603",
        problem_id: 41,
        body: "Эта задача преподнесла мне неожиданный поворот! Интересно, как многие это заметили.",
        comment_reply_id: null,
      },
      {
        author_id: "250",
        problem_id: 41,
        body: "Эта задача показала мне, насколько важно быть терпеливым в программировании.",
        comment_reply_id: null,
      },
      {
        author_id: "813",
        problem_id: 41,
        body: "Это было круто! Какая следующая задача?",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title:
          "Video solution | 2 approaches with intuition explained in detail | C++ | Backtracking",
        body: 'Video\nHello every one i have created a video solution for this problem and solved this video by developing intutition for backtracking (its in hindi), i am pretty sure you will never have to look for solution for this video ever again after watching this, just make sure you have your concepts cleared from subset and subset 2.\nHere i have used 2 approaches:\n\nwithout for loop\nwith for loop\n\nThis video is the part of my playlist "Master backtracking".\nVideo link: \nVideo link for subsets 2: \nPlaylist link: https://www.youtube.com/playlist?list=PLICVjZ3X1AcY5ai7at5OvS4ckXiMbWxCa\nCode\nclass Solution {\npublic:\nvoid comb(vector<int>& nums, vector<vector<int>>& res, vector<int>& temp, int idx,int target) {\n       // BC\n        if(target<0){\n            return;\n        }\n        if(target==0){\n            res.push_back(temp);\n            return;\n        }\n        int l=nums.size();\n        if(idx==l){\n            return;\n        }\n        // 1 2 2 3\n        temp.push_back(nums[idx]);\n        comb(nums, res, temp,idx+1,target-nums[idx]);\n        temp.pop_back();\n        while(idx<nums.size()-1 && nums[idx]==nums[idx+1]) idx++;\n        comb(nums, res, temp,idx+1,target);\n        \n        return;\n    }\n\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n          vector<int> temp;\n        vector<vector<int>> res;\n        sort(candidates.begin(),candidates.end());\n        comb(candidates, res, temp, 0,target);\n        return res;\n    }\n};',
        views: "662",
        upvotes: "11",
        author_id: "510",
        problem_id: 41,
      },
      {
        title: "CLEAN LIKE MY MIND. IN DEPTH SOLUTION JAVA",
        body: "Intuition\n\nEVERYONE , I REQUEST YOU TO UPVOTE. I SPEND A LOT OF TIME WRITING THIS SO GUYS AN UPVOTE WILLBE GREAT.\nOverall Benefit:\n-I used sorting as by sorting the input array and strategically handling the starting index in recursive calls, the code effectively avoids generating duplicate combinations even when the candidates array has duplicate elements.\nApproach\n\nSteps:\n\n\nSorting and Initialization:\n\nArrays.sort(candidates): Sorts the candidates array in ascending order. This is crucial for handling duplicates efficiently.\nSimilar to the previous code, it initializes ans (to store results), al (temporary combination list), and calls the recursive function findAns.\n\n\n\nRecursive Function (findAns):\n\nvoid findAns(int index, int[] candidates, int target, List<List<Integer>> ans, List<Integer> al): This function remains similar to the previous solution with some key modifications for duplicates.\n\nindex now represents the starting index for the current recursive call to avoid revisiting elements before index.\n\n\nif (target == 0): Base case - checks if the target is reached. If yes, a valid combination is found, and it's added to ans.\nfor (int i = index; i < candidates.length; i++): Iterates through the candidates array, but starting from the index provided in the function call. This ensures elements before index are not reconsidered in recursive calls to avoid duplicates.\n\nif (i > index && candidates[i] == candidates[i - 1]): This check is crucial for handling duplicates. It skips duplicate elements if the current element (candidates[i]) is the same as the previous one (candidates[i - 1]) and i is not the starting index (i > index). This ensures only the first occurrence of a duplicate is considered in each combination.\nif (candidates[i] > target): Similar to before, if the current element is greater than the remaining target, it means this path won't lead to a valid combination, so the loop breaks.\nal.add(candidates[i]): Includes the current element in the temporary list al.\nfindAns(i + 1, candidates, target - candidates[i], ans, al): Recursive call with an adjusted target and incremented index. It explores including the current element. Notice i + 1 is used as the starting index for the next call to prevent revisiting the current element.\nal.remove(al.size() - 1): Backtracking step - removes the element just added.\n\n\nSimilar to before, the function returns after the loop to continue backtracking.\n\n\n\nReturning the Results:\n\nThe main combinationSum2 function calls findAns(0, candidates, target, ans, new ArrayList<>()) to start the recursion with an empty list (al) and index 0 (index).\nAfter all recursive calls are done, the combinationSum2 function returns the ans list containing all unique valid combinations that add up to the target sum, considering duplicates.\n\n\n\nComplexity\n\nTime complexity:\n\n\nO(2^t*k)\n\nSpace complexity:\n\n\nO(nK)\nCode\nclass Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> ans=new ArrayList<>();\n        Arrays.sort(candidates);\n        List<Integer> al=new ArrayList<>();\n        findAns(0,candidates, target,ans,al);\n        return ans;\n    }\n\n    public void findAns(int index,int[] candidates, int target,List<List<Integer>> ans,List<Integer> al){\n        if(target==0){\n            ans.add(new ArrayList<>(al));\n            return;\n        }\n        for(int i=index;i<candidates.length;i++){\n            if(i>index && candidates[i]==candidates[i-1]){\n                continue;\n            }\n            if(candidates[i]>target){\n                break;\n            }\n            al.add(candidates[i]);\n            findAns(i+1,candidates, target-candidates[i],ans,al);\n            al.remove(al.size()-1);\n        }\n    }\n}",
        views: "22",
        upvotes: "2",
        author_id: "474",
        problem_id: 41,
      },
      {
        title:
          "Fastest!!! (Frequency + Backtracking) Solution with complete explanation.",
        body: "Intuition\nBackTracking + frequency Array should do the trick.\nApproach\n\n\nFrequency Counting: Initialise a frequency array for the counts of the elements in the original array.\n\n\nFinding Unique Candidates: After counting the frequency, we identify the unique candidates (those with frequency greater than 0) and store them in an array h. This step eliminates duplicates and reduces the size of the array needed for further processing and also (A Sorted Array !!!) which further helps in backtracking.\n\n\nRecursive Backtracking: The get function is where the actual combination generation happens. It's a recursive backtracking function that explores all possible combinations. Here's how it works:\n\n\na. Base Case: If k reaches n (the end of the unique candidates array), or if the current candidate is 0 or adding it to the sum exceeds the target, it returns, indicating the end of a branch in the recursion.\nb. Recursive Steps:\n\nIf adding the current candidate to the sum is less than the target, it tries to include it in the combination if its frequency is greater than 0. Then, it recursively explores combinations with this candidate included and excluded.\nIf the sum equals the target and the frequency of the current candidate is greater than 0, it adds the combination to the result list.\n\nComplexity\n\n\nTime complexity:O(Target)\n\n\nSpace complexity: O(max(candidate[i]))\n\n\nCode\nclass Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n    List<List<Integer>> ans=new ArrayList<>();\n        int[] f =new int[51];\n        int n=candidates.length;\n        int i=0;\n        int size=0;\n        for(int g:candidates){\n            f[g]++;\n            if(f[g]==1)size++;\n        }\n        int[] h=new int[size];\n        size=0;\n        for(int g=1;g<=50;g++){\n            if(f[g]>0)h[size++]=g;\n        }\n        get(ans,new ArrayList<>(),0,size,0,target,h,f,0);\n        return ans;\n    }\n    static void get(List<List<Integer>> ans, List<Integer> a, int k ,int n, int sum, int t, int[] arr,int[] f, int s){\n        if(k==n || arr[k]==0 || sum+arr[k]>t){\n            return;\n        }\n        if(sum+arr[k]<t){\n            if(f[arr[k]]>0){\n            a.add(arr[k]);\n            f[arr[k]]--;\n            get(ans,a,k,n,sum+arr[k],t,arr,f,s+1);\n            a.remove(s);\n            f[arr[k]]++;\n            }\n            get(ans,a,k+1,n,sum,t,arr,f,s);\n        }else if(f[arr[k]]>0){\n            a.add(arr[k]);\n            ans.add(new ArrayList<>(a));\n            a.remove(s);\n            return;\n        }\n    }\n\n}",
        views: "135",
        upvotes: "1",
        author_id: "1",
        problem_id: 41,
      },
      {
        title: "100 % Optimal Solution 🔥",
        body: "Intuition\nbacktracking and skipping duplicates\nApproach\n\nComplexity\n\nTime complexity:\n\n\n\nSpace complexity:\n\n\nCode\nclass Solution {\npublic:\n    void rec(int i,int prev, int tar, vector<int>& ans, vector<int>& c,\n             vector<vector<int>>& st) {\n\n        \n        if (i >= c.size()) {\n            if (tar == 0) {\n                st.push_back(ans);\n            }\n            return;\n        }\n\n        if (c[i] <= tar) {\n            prev=c[i];\n            ans.push_back(c[i]);\n            rec(i + 1,prev, tar - c[i], ans, c, st);\n            ans.pop_back();\n        }\n        int j=i;\n        while(j<c.size() && c[i]==c[j]){\n            j++;\n        }\n        rec(j,prev, tar, ans, c, st);\n        \n    }\n\n    vector<vector<int>> combinationSum2(vector<int>& c, int tar) {\n        int n = c.size();\n        vector<vector<int>> ans;\n        sort(c.begin(),c.end());\n\n        vector<vector<int>> st;\n        vector<int> v;\n\n        rec(0,-1, tar, v, c, st);\n\n        for (auto it : st) {\n            ans.push_back(it);\n        }\n\n        return ans;\n    }\n};\n",
        views: "3003",
        upvotes: "0",
        author_id: "134",
        problem_id: 41,
      },
    ],
  },
  {
    title: "41. First Missing Positive",
    description:
      "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.\n\nYou must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.\n\n \nExample 1:\n\nInput: nums = [1,2,0]\nOutput: 3\nExplanation: The numbers in the range [1,2] are all in the array.\n\n\nExample 2:\n\nInput: nums = [3,4,-1,1]\nOutput: 2\nExplanation: 1 is in the array but 2 is missing.\n\n\nExample 3:\n\nInput: nums = [7,8,9,11,12]\nOutput: 1\nExplanation: The smallest positive integer 1 is missing.\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 105\n\t-231 <= nums[i] <= 231 - 1\n\n",
    difficulty: "Hard",
    acceptance: "49.70",
    frequency: "17.31",
    topics: [
      [
        "Ordered Set",
        "Math",
        "Combinatorics",
        "Bitmask",
        "Merge Sort",
        "Database",
        "Divide and Conquer",
        "Quickselect",
        "Tree",
        "Linked List",
      ],
    ],
    languages: [
      [
        "Ruby",
        "Dart",
        "Python3",
        "C++",
        "Elixir",
        "C#",
        "JavaScript",
        "C",
        "Erlang",
        "Kotlin",
      ],
    ],
    comments: [
      {
        author_id: "278",
        problem_id: 42,
        body: "Чувствую, что становлюсь лучше с каждой решенной задачей!",
        comment_reply_id: null,
      },
      {
        author_id: "543",
        problem_id: 42,
        body: "Когда я столкнулся с этой задачей впервые, я думал, что это невозможно. Теперь я знаю иначе!",
        comment_reply_id: null,
      },
      {
        author_id: "914",
        problem_id: 42,
        body: "Это было круто! Какая следующая задача?",
        comment_reply_id: null,
      },
      {
        author_id: "921",
        problem_id: 42,
        body: "Я не знал, что это возможно, пока не попробовал! Это было удивительно!",
        comment_reply_id: null,
      },
      {
        author_id: "547",
        problem_id: 42,
        body: "Наконец-то, я разобрался с этой задачей! Спасибо за все подсказки.",
        comment_reply_id: null,
      },
      {
        author_id: "924",
        problem_id: 42,
        body: "Это было круто! Какая следующая задача?",
        comment_reply_id: null,
      },
      {
        author_id: "663",
        problem_id: 42,
        body: "Я не знал, что это возможно, пока не попробовал! Это было удивительно!",
        comment_reply_id: null,
      },
      {
        author_id: "466",
        problem_id: 42,
        body: "Сложно даже представить, сколько попыток ушло на решение этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "772",
        problem_id: 42,
        body: "Чувствую себя чемпионом после этой задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "764",
        problem_id: 42,
        body: "Я просто в восторге от того, как эффективно работает мое решение!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "Hard❌ |Easy✅ || Positioning Elements at correct index",
        body: "Master array manipulation and algorithmic problem-solving by finding the smallest missing positive integer efficiently in this challenge!\nIntuition\n\nThe problem requires finding the smallest positive integer that is not present in an unsorted integer array. To achieve this efficiently, we can utilize the fact that the answer lies within the range [1, n+1], where n is the size of the array. By rearranging the elements of the array, we can position each positive integer i at index i-1. Then, we iterate through the array to find the first index i where nums[i] != i+1, indicating the missing positive integer is i+1.\nApproach\n\n\nIterate through the array and place each positive integer i at index i-1 if possible. This ensures that the element nums[i] == i+1 if it exists in the array.\nIterate through the array again to find the first index i where nums[i] != i+1. Return i+1 as the smallest missing positive integer.\nIf all numbers from 1 to n are present in the array, return n+1 as the result.\n\nDry run\nlet's do a dry run of the given array [3, 4, -1, 1]\nIteration 1:\nCurrent array: [3, 4, -1, 1]\nFor element 3 (at index 0), swap it with the element at index 2 because 3 should be at index 2  swap(3,-1).\nUpdated array: [-1, 4, 3, 1]\nnow since -1 is out of range [1, n]\nwe will skip inner loop\nIteration 2:\nCurrent array: [-1, 4, 3, 1]\nFor element 4 (at index 1), swap it with the element at index 3 because 4 should be at index 3 swap(4,1).\nUpdated array: [-1, 1, 3, 4]\nnow 1 is in the range [1, n] , 1 is not at it correct index\nso swap(1,-1)\nUpdated array: [1, -1, 3, 4]\nIteration 3:\nnow 3 is present at correct index so skip this loop\nIteration 4:\nnow 4 is present at correct index so skip this loop\nFinal check:\nWe traverse the array again to find the smallest missing positive integer.\nThe first missing positive integer is 2 since it's not present in the array.\nSo, the smallest missing positive integer in the array [3, 4, -1, 1] is 2.\nComplexity\n\nTime complexity:O(n), where n is the size of the array. Both iterations through the array take linear time.\n\n\n\nSpace complexity: O(1). The algorithm uses only a constant amount of extra space, regardless of the size of the input array.\n\n\nCode\nc++Python3JavaJavaScriptclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int n= size(nums);\n       \n        for(int i=0;i<n;i++){\n            int x=nums[i]; // x = current element\n            \n        // x>=1 && x<=n : to check if x is in range[1, n]\n        // x != i+1 : skip if at index i correct element is present.\n        // nums[x-1]!=x: skip if at index x-1 correct element is present\n            while(x>=1 && x<=n && x!=i+1 && nums[x-1]!=x){\n                swap(nums[x-1],nums[i]);\n                x=nums[i];\n            }\n        }\n\n\n        for(int i=0;i<n;i++){\n            if(nums[i] == i+1)continue;\n                return i+1;       \n            \n        }\n        \n        return n+1;\n    }\n};\nIn complete code inner loop will not run more than n time. In each iteration of inner loop we are placing one element at it correct position. So if inner loop run n times all element will get positioned at correct index. After that inner loop will not run any more\nSo time complexity of first loop in worst case O(2*n)==O(n)\nMy Friends try these two 👹\nc++c++class Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        int n=size(nums);\n        bool onepresent=false;\n        // if one is missing return one \n        for(int i=0;i<n;i++){\n            if(nums[i]==1)onepresent=true;\n            if(nums[i]<=0 || nums[i]>n)nums[i]=1;\n        }\n        if(onepresent==false)return 1;\n        nums.push_back(1);\n        \n        // if x is present make element at nums[x] negative\n        for(int i=0;i<n;i++){\n            int ind=abs(nums[i]);\n            if(nums[ind]>0)nums[ind]=-1*nums[ind];\n        }\n         \n        // if a index is not negative that mean that element   was  not present in array    \n        for(int i=1;i<=n;i++){\n            if(nums[i]>0)return i;\n        }\n        return n+1;\n    }\n};\n",
        views: "36443",
        upvotes: "206",
        author_id: "525",
        problem_id: 42,
      },
      {
        title: "USING HASHTABLE,CYCLIC SORT BOTH WITH LINE BY LINE EXPLANATION",
        body: "Intuition\n\nTo find the smallest positive integer that is not present in the given array, we can use cyclic sort to rearrange the elements. Then, we iterate through the array to find the first missing positive integer.\nApproach\n\nPerform cyclic sort on the array by placing each element at its correct index if it's within the range [1, n]. After sorting, iterate through the array and return the first index where the value doesn't match its corresponding index plus one.\nComplexity\n\nTime complexity:\n\n\nWe perform two passes over the array: one for cyclic sorting and one for finding the missing positive integer.\nTime complexity: O(n)\n\nSpace complexity:\n\n\nWe perform sorting in-place without using extra space.\nSpace complexity: O(1)\nCode\nclass Solution {\n    public int firstMissingPositive(int[] nums) {\n        // HashSet<Integer>hs=new HashSet<>();\n        // for (int a:nums)\n        // {\n        //     // we know that zero is consider that non positive and \n        //     // non negative in programming\n        //     //We don't care about duplicates or non-positive integers\n        //     if (a>0)\n        //     {\n        //         hs.add(a);\n        //     }\n        // }\n        \n        // for (int i=1;i<=nums.length+1;i++)\n        // {\n        //     if (!hs.contains(i))\n        //     {\n        //         return i;\n        //     }\n        // }\n\n        // return -1;\n        // hashset approach takes tc O(n) also space O(n) worst case\n\n\n        // now by using cyclic sort\n        // sort elements by finding arr[i]!=arr[arr[i]-1]\n\n        int i=0;\n        /// for sorting using cyclic sort\n        while(i<nums.length)\n        {\n            if (nums[i]>0 && nums[i]<nums.length && nums[i]!=nums[nums[i]-1])          // it is good to make a separate function for swapping\n            {\n                int temp=nums[i];\n                nums[i]=nums[nums[i]-1];\n                nums[temp-1]=temp;\n            }\n            else\n            {\n                i++;\n            }\n        }\n\n        // finding missing positive number\n        // it means nums[0]=1,nums[1]=2, ....\n        for (int j=0;j<nums.length;j++)\n        {\n            if (nums[j]!=j+1)\n            {\n                return j+1;\n            }\n        }\n        return nums.length+1;\n\n\n    }\n}",
        views: "757",
        upvotes: "4",
        author_id: "631",
        problem_id: 42,
      },
      {
        title: "C# Solution for First Missing Positive Problem",
        body: "Intuition\n\n\nMove all non-positive integers to the end of the array, leaving only positive integers at the beginning.\nMark the presence of positive integers by negating the corresponding index.\nFind the first missing positive integer.\n\nApproach\n\n\nMove non-positive integers to the end: Iterate through the array, swapping non-positive integers with the first positive integer found after them.\nMark the presence of positive integers: Iterate through the positive integers, negating the index corresponding to the positive integer found.\nFind the first missing positive integer: Iterate through the positive integers, returning the first index that is not negated. If all indices are negated, return the length of the array plus one.\n\nComplexity\n\nTime complexity:\n\n\nThe algorithm iterates through the array three times, each time with O(n) complexity. Therefore, the overall time complexity is O(n).\n\nSpace complexity:\n\n\nThe algorithm uses only a constant amount of extra space, regardless of the size of the input array. Hence, the space complexity is O(1).\nCode\npublic class Solution {\n    public int FirstMissingPositive(int[] nums) {\n        int n = nums.Length;\n        \n        // Step 1: Move all non-positive integers to the end of the array\n        int nonPosIdx = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] <= 0) {\n                int temp = nums[i];\n                nums[i] = nums[nonPosIdx];\n                nums[nonPosIdx] = temp;\n                nonPosIdx++;\n            }\n        }\n        \n        // Step 2: Mark the presence of positive integers by negating the corresponding index\n        for (int i = nonPosIdx; i < n; i++) {\n            int num = Math.Abs(nums[i]);\n            if (num <= n - nonPosIdx && nums[num - 1 + nonPosIdx] > 0) {\n                nums[num - 1 + nonPosIdx] *= -1;\n            }\n        }\n        \n        // Step 3: Find the first missing positive integer\n        for (int i = nonPosIdx; i < n; i++) {\n            if (nums[i] > 0) {\n                return i - nonPosIdx + 1;\n            }\n        }\n        \n        return n - nonPosIdx + 1;\n    }\n}",
        views: "333",
        upvotes: "3",
        author_id: "973",
        problem_id: 42,
      },
      {
        title:
          "Easy & Simple Approach | | HashMap | | C++ | | Java | | Python3 | | Kotlin | | ✅✅✅🔥🔥🔥",
        body: "Intuition :\nThe code utilizes a hash table approach but leverages the array itself for constant space complexity. It iterates through the array, marking the presence of positive integers within a specific range. This allows for efficient identification of the first missing positive integer.\nApproach :\n\nHashing with the Array (Unordered Map):\n\nThe code doesn't explicitly use a hash table data structure. Instead, it creates an unordered map (mp) to keep track of encountered numbers.\n\n\nMarking Presence:\n\nIt iterates through the array, adding each element to the unordered map (mp).\n\n\nFinding the Missing Positive:\n\nIt iterates from 1 to the maximum element (maxi) in the array.\nFor each number (i), it checks if i exists in the unordered map (mp).\n\nIf i is not found, it signifies a missing positive integer, and i is returned.\n\n\n\n\nHandling All Positives Present:\n\nIf the loop completes without finding a missing positive, it implies all positive integers (up to maxi) are present. In this case, it returns maxi + 1.\n\n\n\nTime Complexity :\n\nThe code has three main iterations through the array:\n\nMarking encountered numbers in the unordered map (O(n))\nChecking for missing positives (O(n))\nHandling all positives present (O(n))\n\n\nTotal time complexity: O(n)\n\nSpace Complexity :\n\nThe code uses an unordered map (mp) to store encountered numbers.\nHowever, the size of the unordered map is limited by the array size . So the space complexity (O(n)).\n\nC++JavaPython3KotlinJavaScriptclass Solution {\npublic:\n    int firstMissingPositive(std::vector<int>& nums) {\n        int n = nums.size();\n        unordered_map<int,bool> mp;\n        // Finding the maximum element in nums\n        int maxi = *max_element(nums.begin(), nums.end());\n        // Populating the unordered_map with values from nums\n        for(auto &num : nums){\n            mp[num] = true;\n        }\n        // Checking for the first missing positive integer\n        for(int i=1; i<maxi; i++){\n            if(mp.find(i) == mp.end())\n                return i;\n        }\n        // If all integers from 1 to maxi are present, return maxi+1\n        return maxi < 0 ? 1 : maxi+1;\n    }\n};\n\nDry Run on Test Cases 1 and 2 :\nTest Case 1:\n\nInput: nums = [1, 2, 0]\nUnordered map (mp): mp = {1: true, 2: true}\nChecking for missing positives:\n\ni = 1 (present in mp)\ni = 2 (present in mp)\ni = 3 (not found in mp), so 3 is returned.\n\n\n\nTest Case 2:\n\nInput: nums = [3, 4, -1, 1]\nUnordered map (mp): mp = {1: true, 3: true, 4: true}\nChecking for missing positives:\n\ni = 1 (present in mp)\ni = 2 (not found in mp), so 2 is returned.\n\n\n",
        views: "6278",
        upvotes: "15",
        author_id: "12",
        problem_id: 42,
      },
    ],
  },
  {
    title: "42. Trapping Rain Water",
    description:
      "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n\n \nExample 1:\n\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\n\nExample 2:\n\nInput: height = [4,2,0,3,2,5]\nOutput: 9\n\n\n \nConstraints:\n\n\n\tn == height.length\n\t1 <= n <= 2 * 104\n\t0 <= height[i] <= 105\n\n",
    difficulty: "Hard",
    acceptance: "63.07",
    frequency: "73.14",
    topics: [
      [
        "Sliding Window",
        "Binary Search Tree",
        "Biconnected Component",
        "Sorting",
        "Simulation",
        "Binary Search",
        "Concurrency",
        "Design",
        "Prefix Sum",
        "Graph",
      ],
    ],
    languages: [
      [
        "Python3",
        "Scala",
        "Go",
        "Python",
        "Java",
        "Elixir",
        "C#",
        "Racket",
        "C++",
        "Swift",
      ],
    ],
    comments: [
      {
        author_id: "548",
        problem_id: 43,
        body: "Теперь я чувствую, что могу решить что угодно!",
        comment_reply_id: null,
      },
      {
        author_id: "182",
        problem_id: 43,
        body: "Я не знал, что это возможно, пока не попробовал! Это было удивительно!",
        comment_reply_id: null,
      },
      {
        author_id: "202",
        problem_id: 43,
        body: "Сколько времени я потратил на решение этой задачи? Не считаясь!",
        comment_reply_id: null,
      },
      {
        author_id: "188",
        problem_id: 43,
        body: "Эта задача вынудила меня глубже погрузиться в язык программирования.",
        comment_reply_id: null,
      },
      {
        author_id: "106",
        problem_id: 43,
        body: "У кого-нибудь есть идеи, как можно оптимизировать мое решение? Пока я не совсем доволен своим подходом.",
        comment_reply_id: null,
      },
      {
        author_id: "716",
        problem_id: 43,
        body: "Это было как головоломка, но я нашел свой путь к решению!",
        comment_reply_id: null,
      },
      {
        author_id: "718",
        problem_id: 43,
        body: "Это был настоящий вызов для моего ума, но я его преодолел!",
        comment_reply_id: null,
      },
      {
        author_id: "368",
        problem_id: 43,
        body: "Чувствую себя настоящим гений после того, как решил эту задачу!",
        comment_reply_id: null,
      },
      {
        author_id: "161",
        problem_id: 43,
        body: "Подсказки были такими полезными! Они действительно помогли мне решить эту задачу.",
        comment_reply_id: null,
      },
      {
        author_id: "673",
        problem_id: 43,
        body: "Всегда думал, что эта задача невозможна. Но вот я, сделал это!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title:
          "💯Faster✅💯 Lesser✅Detailed Explaination🎯No Two Pointer🧠Step-by-Step Explaination✅Python🐍Java🍵",
        body: "🚀 Hi, I'm Mohammed Raziullah Ansari, and I'm excited to share solution to this question with detailed explanation:\n🎯Problem Explaination:\n\nWe have an array height representing the heights of bars at different positions.\nThe goal is to calculate how much water can be trapped between these bars after a rainfall. Each bar has a certain height given by the elements of the height array.\n\n🧠Thinking Behind the Solution:\n\n\nThe goal is to calculate how much water can be trapped between the bars based on their heights.\n\n\nWater can only be trapped at a particular index if there are higher bars on both its left and right sides.\n\n\nSo, To efficiently determine the maximum elevation to the left and right of each bar, we'll use two arrays:\n\nleft[i]: This array will store the maximum height encountered from the start up to the current index i.\nright[i]: This array will store the maximum height encountered from the end up to the current index i.\n\n\n\nFilling left[] Array:\n\nInitialize left[0] with the height of the first bar.\nFor each subsequent index i, left[i] is computed as the maximum of left[i-1] and the current height height[i]. This ensures that left[i] always holds the maximum height encountered from the start up to i.\n\n\n\nFilling right[] Array:\n\nInitialize right[n-1] with the height of the last bar.\nFor each index i from n-2 down to 0, right[i] is computed as the maximum of right[i+1] and the current height height[i]. This ensures that right[i] always holds the maximum height encountered from i to the end.\n\n\n\nCalculating Trapped Water:\n\n\nOnce left[] and right[] arrays are populated, iterate through the bars.\n\n\nFor each bar at index i, calculate the trapped water above it and store it in trappedWaterusing:\ntrappedWater += (min(left[i], right[i]) - height[i])\nThis formula represents the maximum water that can be trapped above the bar at i, considering the minimum of the highest bars on its left and right minus its own height.\n\n\n\n\nFinal Answer:\n\ntrappedWater holds the value of trapped after after rain.\n\n\n\n✅Approach:\nTo implement the solution for trapping rainwater based on observations, follow these step-by-step instructions:\nStep 1: Initialize Variables and Arrays\nStart by initializing necessary variables and arrays for the solution.\nclass Solution {\n    public int trap(int[] height) {\n        int n = height.length;\n        int[] left = new int[n];  // Array to store maximum height to the left\n        int[] right = new int[n]; // Array to store maximum height to the right\n        int trappedWater = 0;      // Variable to store the total trapped water\nStep 2: Populate the left[] Array\nIterate over the height array from left to right and fill the left[] array with the maximum height encountered so far.\n        left[0] = height[0];  // Base case: leftmost bar has no left boundary\n        for (int i = 1; i < n; i++) {\n            left[i] = Math.max(left[i - 1], height[i]);\n        }\nStep 3: Populate the right[] Array\nIterate over the height array from right to left and fill the right[] array with the maximum height encountered so far.\n        right[n - 1] = height[n - 1];  // Base case: rightmost bar has no right boundary\n        for (int i = n - 2; i >= 0; i--) {\n            right[i] = Math.max(right[i + 1], height[i]);\n        }\nStep 4: Calculate Trapped Water\nIterate over each bar in the height array and compute the trapped water at that position using the left[] and right[] arrays.\n        for (int i = 0; i < n; i++) {\n            int minHeight = Math.min(left[i], right[i]);\n            trappedWater += minHeight - height[i];\n        }\nStep 5: Return the Result\nReturn the total amount of trapped water.\n        return trappedWater;\n    }\n}\nLet's walkthrough🚶🏻‍♂️ the implementation process with an example for better understanding🎯:\nLet's walk through the step-by-step process of calculating the trapped water using the provided height array [0,1,0,2,1,0,1,3,2,1,2,1] with the approach outlined earlier. We'll track the values of left, right, and trappedWater at each iteration:\nStep 0: Initialization\n\nheight = [0,1,0,2,1,0,1,3,2,1,2,1]\nn = 12 (length of height)\nleft[] and right[] arrays will be initialized later during execution.\n\nStep 1: Fill left[] Array\nleft[0] = height[0] = 0\nleft[1] = max(left[0], height[1]) = max(0, 1) = 1\nleft[2] = max(left[1], height[2]) = max(1, 0) = 1\nleft[3] = max(left[2], height[3]) = max(1, 2) = 2\nleft[4] = max(left[3], height[4]) = max(2, 1) = 2\nleft[5] = max(left[4], height[5]) = max(2, 0) = 2\nleft[6] = max(left[5], height[6]) = max(2, 1) = 2\nleft[7] = max(left[6], height[7]) = max(2, 3) = 3\nleft[8] = max(left[7], height[8]) = max(3, 2) = 3\nleft[9] = max(left[8], height[9]) = max(3, 1) = 3\nleft[10] = max(left[9], height[10]) = max(3, 2) = 3\nleft[11] = max(left[10], height[11]) = max(3, 1) = 3\n\nleft[] = [0,1,1,2,2,2,2,3,3,3,3,3]\n\nStep 2: Fill right[] Array\nright[11] = height[11] = 1\nright[10] = max(right[11], height[10]) = max(1, 2) = 2\nright[9] = max(right[10], height[9]) = max(2, 1) = 2\nright[8] = max(right[9], height[8]) = max(2, 2) = 2\nright[7] = max(right[8], height[7]) = max(2, 3) = 3\nright[6] = max(right[7], height[6]) = max(3, 1) = 3\nright[5] = max(right[6], height[5]) = max(3, 0) = 3\nright[4] = max(right[5], height[4]) = max(3, 1) = 3\nright[3] = max(right[4], height[3]) = max(3, 2) = 3\nright[2] = max(right[3], height[2]) = max(3, 0) = 3\nright[1] = max(right[2], height[1]) = max(3, 1) = 3\nright[0] = max(right[1], height[0]) = max(3, 0) = 3\n\nright[] = [3,3,3,3,3,3,3,3,2,2,2,1]\n\nStep 3: Calculate Trapped Water\ni = 0:\n    trappedWater += min(left[0], right[0]) - height[0] = min(0, 3) - 0 = 0 - 0 = 0\n    trappedWater = 0\n\ni = 1:\n    trappedWater += min(left[1], right[1]) - height[1] = min(1, 3) - 1 = 1 - 1 = 0\n    trappedWater = 0\n\ni = 2:\n    trappedWater += min(left[2], right[2]) - height[2] = min(1, 3) - 0 = 1 - 0 = 1\n    trappedWater = 1\n\ni = 3:\n    trappedWater += min(left[3], right[3]) - height[3] = min(2, 3) - 2 = 2 - 2 = 0\n    trappedWater = 1\n\ni = 4:\n    trappedWater += min(left[4], right[4]) - height[4] = min(2, 3) - 1 = 2 - 1 = 1\n    trappedWater = 2\n\ni = 5:\n    trappedWater += min(left[5], right[5]) - height[5] = min(2, 3) - 0 = 2 - 0 = 2\n    trappedWater = 4\n\ni = 6:\n    trappedWater += min(left[6], right[6]) - height[6] = min(2, 3) - 1 = 2 - 1 = 1\n    trappedWater = 5\n\ni = 7:\n    trappedWater += min(left[7], right[7]) - height[7] = min(3, 3) - 3 = 3 - 3 = 0\n    trappedWater = 5\n\ni = 8:\n    trappedWater += min(left[8], right[8]) - height[8] = min(3, 2) - 2 = 2 - 2 = 0\n    trappedWater = 5\n\ni = 9:\n    trappedWater += min(left[9], right[9]) - height[9] = min(3, 2) - 1 = 2 - 1 = 1\n    trappedWater = 6\n\ni = 10:\n    trappedWater += min(left[10], right[10]) - height[10] = min(3, 2) - 2 = 2 - 2 = 0\n    trappedWater = 6\n\ni = 11:\n    trappedWater += min(left[11], right[11]) - height[11] = min(3, 1) - 1 = 1 - 1 = 0\n    trappedWater = 6\nFinal Result\nThe total trapped water after rain for the given height array [0,1,0,2,1,0,1,3,2,1,2,1] is 6 units.\nCode:\nPythonJavaC++class Solution:\n    def trap(self, height: List[int]) -> int:\n        n = len(height)\n        if n == 0:\n            return 0\n        \n        left = [0] * n\n        right = [0] * n\n        \n        # Fill left array\n        left[0] = height[0]\n        for i in range(1, n):\n            left[i] = max(left[i - 1], height[i])\n        \n        # Fill right array\n        right[n - 1] = height[n - 1]\n        for i in range(n - 2, -1, -1):\n            right[i] = max(right[i + 1], height[i])\n        \n        # Calculate trapped water\n        trappedWater = 0\n        for i in range(n):\n            trappedWater += min(left[i], right[i]) - height[i]\n        \n        return trappedWater               ",
        views: "21447",
        upvotes: "137",
        author_id: "245",
        problem_id: 43,
      },
      {
        title: "【Video】Keep max height on the both side.",
        body: "Intuition\nKeep max height on the both side.\n\nSolution Video\n\n⭐️⭐️ Don't forget to subscribe to my channel! ⭐️⭐️\n■ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\nSubscribers: 4,819\nThank you for your support!\n\nApproach\nTo keep water, we have to have a bar on the left side and on the right side. Between them, we can keep water.\nLet's think about this example.\nInput: height = [2,1,0,1,3,2]\n\nI think we can easily imagine that we can keep water at 0 height(= index 2), because we have bars in the adjacent places(= index 1 and 3).\nBut how about 1 height at index 1. We can keep water there. I think left side is easy to imagine because we have a bar in adjacent place(= index 0). But how about right side? In the end, we can keep water because we have 3 height at index 4.\n\nQuestion\nHow can we judge if we can have water when there is some distance between water and a bar? In this case, water is at index 1 and the bar is at index 4.\n\nMy strategy is to keep max height of left and right. I'll show you how algorithm works.\nHow it works\n[2,1,0,1,3,2]\n L         R\n\nleft max = 2\nright max = 2\nwater = 0\nL is current left pointer.\nR is current right pointer.\nleft max is max height of left side we found so far. Initialized with the first number.\nright max is max height of right side we found so far. Initialized with the last number\nwater is return value.\nIf L is smaller than R, we continue. After that, check left max and right max and take smaller max height. I'll explain why later.\nIn this case, they are the same, so we can choose one of them. I'll take right.\nFirst of all, move R to the next.\n[2,1,0,1,3,2]\n L       R\n\nleft max = 2\nright max = 2\nwater = 0\nNext, update right max if current bar is taller than current right max.\ncurrent bar vs current max right\n= 3 vs 2\n= 3\n\n[2,1,0,1,3,2]\n L       R\n\nleft max = 2\nright max = 3\nwater = 0\nThen, count number of water. Formula is\nwater = current right max - current bar\n= 3 - 3\n= 0\nwater should be 0.\nNext, L < R, so we continue\nFirst of all, take smaller max height between left and right. I'll take left max.\nMove L to the next and update left max if needed. No udpate this time.\n[2,1,0,1,3,2]\n   L     R\n\nleft max = 2\nright max = 3\nwater = 0\nThen here is an important point. water should be\ncurrent left max - current bar\n2 - 1 = 1\n\nwater = 1\nAre you sure?\nYes, I'm sure.\n\n⭐️ Points\nWe take smaller max height between left(= 2 height) and right(= 3 height) and handle left side because left max is smaller than right max. That means we don't have to care about right side because we know that we have current tallest bar(= 3 height at index 4) on the right side, so at least we can keep water at 2 height(= left max)\n\nThat's the reason why we take smaller max height.\nWe can take 2 height as max height but there is bar at index 1. That's why\nleft max - current height\n= 2 - 1\n= 1 water\n[2,1,0,1,3,2]\n   L     R\n\nleft max = 2\nright max = 3\nwater = 1\nI'll speed up.\nL < R, so we continue.\nMove L to the next because left max is smaller than right max and update left max if needed. No update this time.\n[2,1,0,1,3,2]\n     L   R\n\nleft max = 2\nright max = 3\nwater = 1\nwater should be...\n2 - 0 = 2\ntotal water = 3\nNext, L < R, so we continue.\nMove L to the next because left max is smaller than right max and update left max if needed. No update this time.\n[2,1,0,1,3,2]\n       L R\n\nleft max = 2\nright max = 3\nwater = 3\nwater should be...\n2 - 1 = 1\ntotal water = 4\nNext, L < R, so we continue.\nMove L to the next because left max is smaller than right max and update left max if needed. we found 3 this time.\n[2,1,0,1,3,2]\n         L\n         R\nleft max = 3 (updated. 2 vs 3)\nright max = 3\nwater = 3\nwater should be...\n3 - 3 = 0\ntotal water = 4\nNow L == R. We stop iteration.\nreturn 4\n\n\n\nComplexity\n\nTime complexity: O(n)O(n)O(n)\n\n\n\nSpace complexity: O(1)O(1)O(1)\n\n\nPythonJavaScriptJavaC++class Solution:\n    def trap(self, height: List[int]) -> int:\n        left = 0\n        right = len(height) - 1\n        left_max = height[left]\n        right_max = height[right]\n        water = 0\n\n        while left < right:\n            if left_max < right_max:\n                left += 1\n                left_max = max(left_max, height[left])\n                water += left_max - height[left]\n            else:\n                right -= 1\n                right_max = max(right_max, height[right])\n                water += right_max - height[right]\n        \n        return water\nStep by Step Algorithm\n\nInitialize pointers and variables:\n\nInitialize two pointers left and right at the beginning and end of the height list respectively.\nInitialize variables left_max and right_max to store the maximum height encountered from the left and right sides respectively.\nInitialize a variable water to keep track of the total trapped water.\n\n\n\nleft = 0\nright = len(height) - 1\nleft_max = height[left]\nright_max = height[right]\nwater = 0\n\nLoop until pointers meet:\n\nContinue looping while left pointer is less than right pointer, indicating there are still bars to process.\n\n\n\nwhile left < right:\n\nCheck which side to move:\n\nCompare left_max and right_max heights.\nIf left_max is less than right_max, move the left pointer to the right and update left_max.\nOtherwise, move the right pointer to the left and update right_max.\n\n\n\nif left_max < right_max:\n    left += 1\n    left_max = max(left_max, height[left])\n    water += left_max - height[left]\nelse:\n    right -= 1\n    right_max = max(right_max, height[right])\n    water += right_max - height[right]\n\n\nCalculate trapped water:\n\nCalculate the water trapped at the current position based on the difference between the maximum height and the current height.\nAccumulate this water amount to the water variable.\n\n\n\nReturn total trapped water:\n\nAfter the loop ends, return the total trapped water accumulated in the water variable.\n\n\n\nreturn water\nThis algorithm efficiently iterates through the elevation map, moving pointers inward based on the comparison of maximum heights encountered so far from both sides, ultimately calculating the total trapped water between the bars.\n\nThank you for reading my post. Please upvote it and don't forget to subscribe to my channel!\n⭐️ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\n⭐️ Twitter\nhttps://twitter.com/CodingNinjaAZ\n⭐️ Related question #322 - Coin Change\n",
        views: "1046",
        upvotes: "31",
        author_id: "273",
        problem_id: 43,
      },
      {
        title: "Beats 100% 🔥🔥!! 2 Pointer Approach✅ with explanation.🔥🔥",
        body: "Question:\nBasically we are going to see whether we can trap the water or not.\nwithin the given area.\nApproach 1.(2 Pointer)\nA basic idea comes into peoples mind if two walls are there and we want want to fill water within that wall we just have to fill the water till min of two wall right if it exceeds the value ,it will overflow.\nSo, we can set 2 pointers left_max,right_max and check which side is greater,if one side is greater iterate on other side because at the min side the water will be filled at its limit. and iterate till pointer is lower than the other one.\nex.height = [0,1,0,2,1,0,1,3,2,1,2,1]\nleft_max=0,right_max=1,count=0\namount of water is calculate using subtractring wall length with min(right_max,left_max);\niterate left_side.\ncount=0,left_max=0,right_max=1\niterate left_side.\ncount=0,left_max=1,right_max=1\niterate left_side.\ncount=1,left_max=1,right_max=1\niterate left_side.\ncount=2,left_max=2,right_max=1\niterate right_side.\ncount=2,left_side=2,right_side=2\niterate left_side.\ncount=3,left_side=2,right_side=2\niterate left_side.\ncount=5,left_side=2,right_side=2\niterate left_side.\ncount=5,left_side=3,right_side=2\niterate right_side.\ncount=6,left_side=3,right_side=2\niterate right_side.\ncount=6,left_side=3,right_side=2\nso thats the amount of water is found.\nCode\nJavaC++Python3JavaScriptclass Solution {\n    public int trap(int[] height) {\n        int i=0,left_max=height[0],sum=0;\n        int j=height.length-1,right_max=height[j];\n        while (i<j)\n        {\n            if(left_max <= right_max)\n            {\n                sum+=(left_max-height[i]);\n                i++;\n                left_max=Math.max(left_max,height[i]);\n            }\n            else \n            {\n                sum+=(right_max-height[j]);\n                j--;\n                right_max=Math.max(right_max,height[j]);\n            }\n        }\n        return sum;\n        \n    }\n}\nif it was helpful !!Please Upvote!!\n",
        views: "15714",
        upvotes: "108",
        author_id: "272",
        problem_id: 43,
      },
      {
        title: "Easy Weesy 2 Approaches ( two pointer & DP) 😉❤ C++ 🚀",
        body: "Approach 1 :\nHere is step wise approach why and how we have gone through the steps:\n\n\nInitialization:\n\nWe initialize left and right pointers to the beginning and end of the array respectively because we want to traverse the array from both ends towards the center.\nleft_max and right_max are initialized to 0 because initially, we haven't encountered any height to compare against.\nans is initialized to 0 to accumulate the trapped water.\n\n\n\nIterative Process:\n\nWe use a while loop to iteratively move the pointers towards each other until they meet in the middle.\n\n\n\nComparison of Heights:\n\nWe compare the heights at positions pointed by left and right because we want to determine which side to move towards the center.\nThis comparison helps us decide whether to focus on the left or right side for trapping water.\n\n\n\nTrap Water (Left Pointer):\n\nIf the height at left is less than the height at right, it means there's a potential for trapping water towards the left.\nIf the height at left is greater than left_max, it indicates that the current height can hold water, so we update left_max.\nIf the height at left is not greater than left_max, it means the current height cannot hold water, so we accumulate the difference between left_max and the height at left into ans. This represents the trapped water.\nMoving the left pointer to the right ensures that we continue to explore the left side for trapping water.\n\n\n\nTrap Water (Right Pointer):\n\nIf the height at right is less than or equal to the height at left, it means there's a potential for trapping water towards the right.\nIf the height at right is greater than right_max, it indicates that the current height can hold water, so we update right_max.\nIf the height at right is not greater than right_max, it means the current height cannot hold water, so we accumulate the difference between right_max and the height at right into ans.\nMoving the right pointer to the left ensures that we continue to explore the right side for trapping water.\n\n\n\nReturn Answer:\n\nOnce the loop terminates, we return ans, which holds the total trapped water after iterating through the entire array.\n\n\n\n\nTWO POINTER APPROACH :\nC++class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n=height.size();\n        int left=0,right=n-1;\n        int left_max=0,right_max=0; \n        int ans=0;\n\n        while(left<right){\n            if(height[left]<height[right]){\n                if(height[left]>left_max) left_max=height[left];\n                else ans+= left_max-height[left];\n                left++;\n            }\n            else{\n                if(height[right]>right_max) right_max=height[right];\n                else ans+= right_max-height[right];\n                right--;\n            }\n        }\n\n        return ans;\n    }\n};\n\nApproach 2 :\nThis solution takes a slightly different approach using dynamic programming. Let's break down how it works:\n\n\nInitialization:\n\nInitialize variables:\n\nn: The size of the input vector height.\nleftMax: A vector to store the maximum height encountered from the left for each index.\nrightMax: A vector to store the maximum height encountered from the right for each index.\ntrappedWater: A variable to accumulate the trapped water.\n\n\n\n\n\nCalculate Left Max Heights:\n\nIterate through the input vector height from left to right.\nAt each index i, update leftMax[i] to store the maximum height encountered from the left up to index i.\n\n\n\nCalculate Right Max Heights:\n\nIterate through the input vector height from right to left.\nAt each index i, update rightMax[i] to store the maximum height encountered from the right starting from index i.\n\n\n\nCalculate Trapped Water:\n\nIterate through the input vector height.\nAt each index i, calculate the trapped water by taking the minimum of leftMax[i] and rightMax[i] (this represents the maximum height available on both sides) and subtracting the height at index i. This gives the height of the water that can be trapped at index i.\nAccumulate the trapped water in the variable trappedWater.\n\n\n\nReturn Trapped Water:\n\nAfter iterating through the entire vector, return the accumulated trappedWater.\n\n\n\nThis approach essentially precomputes the maximum heights from the left and right for each index using dynamic programming. Then, it calculates the trapped water at each index by finding the minimum of the maximum heights from both sides and subtracting the height at the current index. Finally, it accumulates the trapped water and returns the result.\n\nIF YOU ARE IN DOUBT HOW SUFFIX SUM & PREFIX SUM WORKS THEN SEE THIS BELOW:\nso here is how i m doing below -\nfirst we created 2 array for prefix sum and suffix.\n\n\nso here prefix sum or we taking leftMax, there at each index we will take the max element we found from moving left to right. and we keep input the max element till ith index to the ith position in prefix vector.\n\n\nsimilary with suffix or rightMax we moving from left to right . and putting the max element found from moving left to right in the ith index.\n\n\nthe we compare both prefix and suffix array. and will take the min element in ith index of both vector or array and subtract the actual height from main array. and the result we keep adding in our \"trappedWater\" variable.\n\nUSING DP :\nC++\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n\n    vector<int> leftMax(n, 0);\n    vector<int> rightMax(n, 0);\n    int trappedWater = 0;\n\n    leftMax[0] = height[0];\n    for (int i = 1; i < n; i++) {\n        leftMax[i] = max(leftMax[i - 1], height[i]);\n    }\n\n    rightMax[n - 1] = height[n - 1];\n    for (int i = n - 2; i >= 0; i--) {\n        rightMax[i] = max(rightMax[i + 1], height[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        trappedWater += min(leftMax[i], rightMax[i]) - height[i];\n    }\n\n    return trappedWater;\n\n    }\n};\nkeep supproting 😊⬆",
        views: "1215",
        upvotes: "10",
        author_id: "625",
        problem_id: 43,
      },
    ],
  },
  {
    title: "43. Multiply Strings",
    description:
      'Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n \nExample 1:\nInput: num1 = "2", num2 = "3"\nOutput: "6"\nExample 2:\nInput: num1 = "123", num2 = "456"\nOutput: "56088"\n\n \nConstraints:\n\n\n\t1 <= num1.length, num2.length <= 200\n\tnum1 and num2 consist of digits only.\n\tBoth num1 and num2 do not contain any leading zero, except the number 0 itself.\n\n',
    difficulty: "Medium",
    acceptance: "64.39",
    frequency: "29.61",
    topics: [
      [
        "Design",
        "Math",
        "Dynamic Programming",
        "Game Theory",
        "Sorting",
        "Backtracking",
        "Data Stream",
        "Randomized",
        "Probability and Statistics",
        "Tree",
      ],
    ],
    languages: [
      [
        "Racket",
        "Rust",
        "Java",
        "Elixir",
        "Go",
        "Erlang",
        "Ruby",
        "C++",
        "TypeScript",
        "C",
      ],
    ],
    comments: [
      {
        author_id: "590",
        problem_id: 44,
        body: "Это было как головоломка, но я нашел свой путь к решению!",
        comment_reply_id: null,
      },
      {
        author_id: "419",
        problem_id: 44,
        body: "Мой мозг сейчас в кипении от этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "888",
        problem_id: 44,
        body: "Эта задача преподнесла мне неожиданный поворот! Интересно, как многие это заметили.",
        comment_reply_id: null,
      },
      {
        author_id: "616",
        problem_id: 44,
        body: "Мой мозг сейчас в кипении от этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "989",
        problem_id: 44,
        body: "Это было круто! Какая следующая задача?",
        comment_reply_id: null,
      },
      {
        author_id: "927",
        problem_id: 44,
        body: "Эта задача преподнесла мне неожиданный поворот! Интересно, как многие это заметили.",
        comment_reply_id: null,
      },
      {
        author_id: "191",
        problem_id: 44,
        body: "Какие интересные подходы у других людей к этой задаче",
        comment_reply_id: null,
      },
      {
        author_id: "81",
        problem_id: 44,
        body: "Когда я столкнулся с этой задачей впервые, я думал, что это невозможно. Теперь я знаю иначе!",
        comment_reply_id: null,
      },
      {
        author_id: "453",
        problem_id: 44,
        body: "Это было как головоломка, но я нашел свой путь к решению!",
        comment_reply_id: null,
      },
      {
        author_id: "85",
        problem_id: 44,
        body: "Сложно даже представить, сколько попыток ушло на решение этой задачи.",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "Easiest JAVA Solution with Graph Explanation",
        body: "Remember how we do multiplication?\nStart from right to left, perform multiplication on every pair of digits, and add them together.  Let's draw the process! From the following draft, we can immediately conclude:\n `num1[i] * num2[j]` will be placed at indices `[i + j`, `i + j + 1]` \n\n\n\nHere is my solution. Hope it helps!\npublic String multiply(String num1, String num2) {\n    int m = num1.length(), n = num2.length();\n    int[] pos = new int[m + n];\n   \n    for(int i = m - 1; i >= 0; i--) {\n        for(int j = n - 1; j >= 0; j--) {\n            int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0'); \n            int p1 = i + j, p2 = i + j + 1;\n            int sum = mul + pos[p2];\n\n            pos[p1] += sum / 10;\n            pos[p2] = (sum) % 10;\n        }\n    }  \n    \n    StringBuilder sb = new StringBuilder();\n    for(int p : pos) if(!(sb.length() == 0 && p == 0)) sb.append(p);\n    return sb.length() == 0 ? \"0\" : sb.toString();\n}",
        views: "231448",
        upvotes: "2.5K",
        author_id: "819",
        problem_id: 44,
      },
      {
        title:
          "Shitty solution but worked...I am a new coder, I AM HERE TO LEARN!!!!!",
        body: 'Intuition\nSince we can\'t directly use the built-in Bigintger and converting between int and str, I believe the best approach is to utilize the ASCII table. To convert a string to an integer, we can use the formula ord("one digit number") - 48. Conversely, to convert an integer to a string, we can use chr("one digit number" + 48).\nApproach\nI began by reversing the two strings because, for instance, with "123", it should be interpreted as 1 * 10^2 + 2 * 10^1 + 3 * 10^0. Here, I\'m aligning their positions to the powers of 10, so 1 should be at position 2, 2 should be at position 1, and 3 should be at position 0. However, the current string represents the opposite. So, I reversed them.\nAfter using a for loop (yes, I know, for loops can be slow, but I couldn\'t find an alternative solution) on each string, we obtain two integers, 123 and 456. I then multiplied them. Since the result should be a string, I used chr to transform the integer back to a string. I implemented this using a while loop, iterating as long as the result is greater than 0. For each digit, I perform % 10, which gives the remainder when divided by 10. For example, with 56088, it becomes 8 first, the remainder of 56088. Then, I use chr for that digit (remainder), converting it from an int to a string. Next, I perform // 10, which gives the quotient without the decimal part. So, instead of 56088, we get 5608. I repeat this process until the "result" equals 5, and by // 10, we get 0, thus ending the loop. Finally, to obtain the result, we need to reverse the solution back using sol[::-1] because the process began with the decimal part, and we accumulated the result as 88065. If sol happens to be "", the result should be "0".\nWhat I want to learn, and if you can help me, is how to handle super big numbers. It\'s been mentioned that the length of num can be up to 200. In this case, the for loops might be too slow, and I\'m uncertain how to calculate the time and space complexity in such situations. I want to ensure my logic is sound. Thank you so much for assisting a new coder! I\'m off to lunch now. :))\nComplexity\n\n\nTime complexity:\nI don\'t know how to calculate Time complexity\n\n\nSpace complexity:\nI don\'t know how to calculate Space complexity\n\n\nCode\nclass Solution(object):\n    def multiply(self, num1, num2):\n        res1 = 0\n        res2 = 0\n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        for i in range(len(num1)):\n            res1 += (ord(num1[i]) - 48) * (10 ** i)\n        \n        for j in range(len(num2)):\n            res2 += (ord(num2[j]) - 48) * (10 ** j)\n        \n        result = res1 * res2 \n        \n        sol = ""\n        while result > 0:\n            digit = result % 10\n            sol += chr(digit + 48) \n            result //= 10\n        if not sol:\n            return "0"\n\n        return sol[::-1]',
        views: "173",
        upvotes: "3",
        author_id: "17",
        problem_id: 44,
      },
      {
        title: "C++ Simple, Easy and Short Solution, Brief Explanation",
        body: 'Idea:\nWe are using regular mathematical vertical multiplication.\nWe loop from the end of both numbers, multiply the digits one at a time and save the carry in the next cell for the next iteration.\nThe loop at the end constructs the result string - we skip 0s at the beginning and add the numbers.\nTime Complexity: O(mn)\nSpace Complexity: O(n+m)\nclass Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if (num1 == "0" || num2 == "0") return "0";\n        \n        vector<int> res(num1.size()+num2.size(), 0);\n        \n        for (int i = num1.size()-1; i >= 0; i--) {\n            for (int j = num2.size()-1; j >= 0; j--) {\n                res[i + j + 1] += (num1[i]-\'0\') * (num2[j]-\'0\');\n                res[i + j] += res[i + j + 1] / 10;\n                res[i + j + 1] %= 10;\n            }\n        }\n        \n        int i = 0;\n        string ans = "";\n        while (res[i] == 0) i++;\n        while (i < res.size()) ans += to_string(res[i++]);\n        \n        return ans;\n    }\n};\nLike it? please upvote!',
        views: "42965",
        upvotes: "378",
        author_id: "113",
        problem_id: 44,
      },
      {
        title: "C++ with example details",
        body: 'Intuition\n\nWhen looking at the problem, we see that using the big number library is not allowed. We immediately think of the rule of manually multiplying each digit and then adding the consecutive numbers together.\nApproach\n\nAccording to mathematics (in the case of not multiplying by 0):\n\nMaximum digit of result of The of multiplying an m-digit number by an n-digit number is m + n.\nMinimum digit of result of The of multiplying an m-digit number by an n-digit number is max (m, n). This case the min (m, n) must be 1.\nFrom 2 lines above we have length of result of multiplication: m + n <= length of result <= m + n - 1\nanswerDigit[i + j + 1] =  answerDigit[i + j + 1] + num1[i] * num2[j] if this result > 9 the carry number will add to the multipication of the next (left-hand side) digit. The addition answerDigit[i + j + 1] + num1[i] * num2[j] indicate that it will plus the previous carry if have\n\nSo I create the array which contains the each string number with maximun digit of multiplication (m + n) in order to to accommodate all the results.\nWhen finish the multipication. We consider to the digits "0" at the head. Frome idea 2 of mathematics above we just consider the first element of vector. Finally, We add the digit strings together to get the result.\nExample: 123 x 456\nansArr = [0, 0, 0, 0, 0, 0]\nIn first loop of i:\n\n6 x 3 = 18 write 8  and add carry 1 to next multiplication. Vector: [0, 0, 0, 0, 0, 1, 8]\n5 x 3 = 15. We have carry 1 so 15 + 1 = 16. Write 6 and add carry 1 to next multiplication. Vector: [0, 0, 0, 1, 6, 8]\n4 x 3 = 12. We have carry 1 so 12 + 1 = 13. Write 3 and add carry 1 to next multiplication. Vector: [0, 0, 1, 3, 6, 8]\n\nIn the second loop of i:\n\n6 x 2 = 12. Add 2 to [i + j + 1] position and add carry 1 to next multiplication. Vector: [0, 0, 1, 4, 8, 8]\n5 x 2 = 10. Add 0 to [i + j + 1] position and add carry 1 to next multiplication. Vector: [0, 0, 2, 4, 8, 8]\n4 x 2 = 12. Add 2 to [i + j + 1] position and add carry 1 to next multiplication. Vector: [0, 1, 4, 4, 8, 8]\n\nIn the final loop of i:\n\n6 x 1 = 6. Add 6 to [i + j + 1] position. Because 6 + 4 (the 4 next to 8) = 10 so add 0 and add carry 1 to next multiplication. Vector: [0, 1, 1, 0, 8, 8]\n5 x 1 = 5. Add 5 to [i + j + 1] position. Vector: [0, 1, 6, 0, 8, 8]\n4 x 1 = 4. Add 4 to [i + j + 1] position. Vector: [0, 5, 6, 0, 8, 8]\n\nComplexity\nWith m is length of string num1 and n is length of string num2\n\nTime complexity: O(mn)\n\n\n\nSpace complexity:O(m+n)\n\n\nCode\nclass Solution {\npublic:\n    string multiply(string num1, string num2) {\n        string ans = "";\n        if (num1 == "0" || num2 == "0")\n            return "0";\n        vector<int> ansArr(num1.length() + num2.length(), 0);\n        for (int i = num1.length() - 1; i >= 0; i--) {\n            for (int j =  num2.length() - 1; j >= 0; j--) {\n                ansArr[i + j + 1] += (num1[i] - \'0\') * (num2[j] - \'0\');\n                ansArr[i + j] += ansArr[i + j + 1] / 10;\n                ansArr[i + j + 1] =  ansArr[i + j + 1] % 10; \n            }\n        }\n        int startNum = (ansArr[0] == 0) ? 1 : 0;\n        while (startNum < ansArr.size())\n            ans += to_string(ansArr[startNum++]);\n        return ans;\n    }\n};',
        views: "335",
        upvotes: "1",
        author_id: "753",
        problem_id: 44,
      },
    ],
  },
  {
    title: "44. Wildcard Matching",
    description:
      "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n\n\n\t'?' Matches any single character.\n\t'*' Matches any sequence of characters (including the empty sequence).\n\n\nThe matching should cover the entire input string (not partial).\n\n \nExample 1:\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\n\nExample 2:\n\nInput: s = \"aa\", p = \"*\"\nOutput: true\nExplanation: '*' matches any sequence.\n\n\nExample 3:\n\nInput: s = \"cb\", p = \"?a\"\nOutput: false\nExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n\n\n \nConstraints:\n\n\n\t0 <= s.length, p.length <= 2000\n\ts contains only lowercase English letters.\n\tp contains only lowercase English letters, '?' or '*'.\n\n",
    difficulty: "Hard",
    acceptance: "48.42",
    frequency: "9.37",
    topics: [
      [
        "Enumeration",
        "Design",
        "Two Pointers",
        "Bit Manipulation",
        "Array",
        "Probability and Statistics",
        "Sorting",
        "Doubly-Linked List",
        "Collapse",
        "Breadth-First Search",
      ],
    ],
    languages: [
      [
        "Java",
        "Go",
        "C++",
        "TypeScript",
        "Racket",
        "JavaScript",
        "Swift",
        "Python",
        "C#",
        "Erlang",
      ],
    ],
    comments: [
      {
        author_id: "305",
        problem_id: 45,
        body: "Потратил на решение этой задачи весь день, но это было того стоило!",
        comment_reply_id: null,
      },
      {
        author_id: "952",
        problem_id: 45,
        body: "Благодаря этой задаче я узнал о новой функции языка программирования.",
        comment_reply_id: null,
      },
      {
        author_id: "716",
        problem_id: 45,
        body: "Сколько времени я потратил на решение этой задачи? Не считаясь!",
        comment_reply_id: null,
      },
      {
        author_id: "575",
        problem_id: 45,
        body: "Я так рад, что решил эту задачу! Это действительно научило меня чему-то новому.",
        comment_reply_id: null,
      },
      {
        author_id: "759",
        problem_id: 45,
        body: "Кто бы мог подумать, что решение окажется настолько простым!",
        comment_reply_id: null,
      },
      {
        author_id: "287",
        problem_id: 45,
        body: "Эта задача показала мне, насколько важно быть терпеливым в программировании.",
        comment_reply_id: null,
      },
      {
        author_id: "608",
        problem_id: 45,
        body: "Это был настоящий вызов для моего ума, но я его преодолел!",
        comment_reply_id: null,
      },
      {
        author_id: "697",
        problem_id: 45,
        body: "Кто-нибудь сталкивался с такой ошибкой раньше? Не могу понять, в чем проблема.",
        comment_reply_id: null,
      },
      {
        author_id: "814",
        problem_id: 45,
        body: "Чувствую себя чемпионом после этой задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "391",
        problem_id: 45,
        body: "Чувствую себя настоящим гений после того, как решил эту задачу!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "0(N) Space SOLUTION WITH ALL SOLUTIONS",
        body: "PLS UPVOTE MY SOLUTION IF YOPU LIKE AND COMMENT FOR ANY DISCUSSION\nApproach\nsolvetab Function: This function uses the tabulation technique to find if the string s matches the wildcard pattern p. It initializes two vectors, prev and curr, of size p.length() + 1. These vectors are used to represent the DP table.\nBase Case Initialization: It sets prev[0] to true, representing an empty string matching an empty pattern.\nHandling the '' Characters at the Start of Pattern: It checks if the pattern starts with multiple '' characters. For each character in p from 1 to p.length(), it sets prev[j] to true if the pattern contains only '*' characters from the start.\nFilling DP Table: It iterates through each character in s and each character in p, starting from 1 to s.length() and 1 to p.length(). For each character, it checks two conditions:\nIf the characters are the same or if the pattern has a '?', it propagates the result from the previous diagonal position (prev[j-1]) to the current position (curr[j]).\nIf the pattern has a '', it propagates the result from the previous row (prev[j]) or the previous column (curr[j-1]) to the current position (curr[j]), indicating that the '' can match either a single character in s or a sequence of characters.\nFinal Result: After filling the DP table, the function returns the value at prev[p.length()], which indicates if the entire string s matches the entire wildcard pattern p.\nisMatch Function: This function serves as an interface to call the solvetab function. It takes the input strings s and p and calls solvetab(s, p) to find if s matches p\n\nComplexity\n\nTime complexity:0(M*N)\n\n\n\nSpace complexity:0(N)\n\n\nCode\n\nTABULATION\nApproach\nsolvetab Function: This function uses a tabulation (bottom-up) dynamic programming approach to find if s matches the wildcard pattern p. It initializes a 2D DP table dp of size (s.length() + 1) x (p.length() + 1) with all elements initialized to 0.\nBase Cases: It sets dp[0][0] to true, as an empty string matches an empty pattern. Then, it handles the case where the pattern starts with multiple '' characters. For each character in p from 1 to p.length(), it sets dp[0][j] to true if the pattern contains only '' characters from the start.\nFilling DP Table: It iterates through each character in s and each character in p, starting from 1 to s.length() and 1 to p.length(). For each character, it checks three conditions:\nIf the characters are the same or if the pattern has a '?', it propagates the result from the previous position (dp[i-1][j-1]) to the current position (dp[i][j]).\nIf the pattern has a '', it propagates the result from the previous row (dp[i-1][j]) or the previous column (dp[i][j-1]) to the current position (dp[i][j]), indicating that the '' can match either a single character or a sequence of characters.\nIf none of the above conditions match, it sets dp[i][j] to false, as the characters do not match.\nFinal Result: After filling the DP table, the function returns the value at dp[s.length()][p.length()], which indicates if the entire string s matches the entire wildcard pattern p.\nisMatch Function: This function serves as an interface to call the solvetab function. It takes the input strings s and p and calls solvetab(s, p) to find if s matches p.\n\nComplexity\n\nTime complexity:0(N*M)\n\n\n\nSpace complexity:0(N*M)\n\n\nclass Solution {\npublic:\n\nbool solvetab(string s, string p)\n{\n    vector<vector<int>>dp(s.length()+1,vector<int>(p.length()+1,0));\n    dp[0][0]=true;\n    for(int j=1;j<=p.length();j++)\n    {\n    bool flag= true;\n        for(int k =1;k<=j;k++)\n        {\n            if(p[k-1]!='*')\n            {\n                flag=false;\n                break;\n            }\n        }\n        dp[0][j]=flag;\n    }\n    for(int i =1;i<=s.length();i++)\n    {\n        for(int j =1;j<=p.length();j++)\n        {\n            if(p[j-1]=='?' || p[j-1]==s[i-1])\n            {\n                dp[i][j]=dp[i-1][j-1];\n            }\n            else if(p[j-1]=='*')\n            {\n              dp[i][j]=dp[i-1][j] || dp[i][j-1];\n            }\n            else\n            {\n                  dp[i][j]=false;\n            }\n        }\n    }\n    return dp[s.length()][p.length()];\n}\n\n\n\n\n    bool isMatch(string s, string p)\n    {\n       \n        // return solve(s,p,s.length()-1,p.length()-1,dp);\nreturn solvetab(s,p);\n    }\n};\nMEMOIZATION\nApproach\nsolve Function: This recursive function is used to check if a substring of str starting from the first character to index i matches a substring of pattern starting from the first character to index j. The function takes the string str, the pattern pattern, the indices i and j, and a memoization table dp as input.\nBase Cases: The function first checks for base cases:\nIf both i and j are less than 0, it means both str and pattern are empty, so it returns true.\nIf i is greater than or equal to 0 but j is less than 0, it means pattern is empty, so it returns false.\nIf j is greater than or equal to 0 but i is less than 0, it checks if the remaining characters in pattern (from index 0 to j) are all '*' characters. If yes, it returns true; otherwise, it returns false.\nMemoization: Before proceeding with the recursive calls, the function checks if the result for the current i and j has already been computed and stored in the memoization table dp. If so, it directly returns the precomputed value to avoid redundant calculations.\nRecursive Calls: If the base cases are not satisfied, the function checks for the following conditions:\nIf the current characters in str and pattern match (either the same character or '?' in the pattern), it makes a recursive call to solve with indices i-1 and j-1 to check the remaining substrings.\nIf the current character in pattern is '', it makes two recursive calls to solve:\nOne with index i-1 and the same index j to check if the '' matches a single character in str.\nAnother with the same index i and index j-1 to check if the '*' matches a sequence of characters in str.\nIf none of the above conditions match, it returns false, as the characters do not match.\nMemoization Update: After the recursive calls, the function updates the memoization table dp with the result for the current i and j and returns the result.\nisMatch Function: This function serves as an interface to call the solve function with the appropriate arguments. It initializes the memoization table dp, calls solve with s.length()-1, p.length()-1, and returns the result.\n\nComplexity\n\nTime complexity:0(N*M)\n\n\n\nSpace complexity:0(N*M)\n\n\nclass Solution {\npublic:\n\nbool solve(string& str,string& pattern , int i , int j, vector<vector<int>>&dp)\n{\n    if(i<0 && j<0)\n    {\n        return true;\n    }\n    if(i>=0 && j<0)\n    {\n        return false;\n    }\n    if(j>=0 && i<0)\n    {\n        for(int k =0;k<=j;k++)\n        {\n            if(pattern[k]!='*')\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n    if(dp[i][j]!=-1)\n    {\n        return dp[i][j];\n    }\n    if(pattern[j]=='?' || pattern[j]==str[i])\n    {\n        return dp[i][j]=solve(str,pattern, i-1,j-1,dp);\n    }\n    else if(pattern[j]=='*')\n    {\n       return dp[i][j]=solve(str,pattern, i-1,j,dp) || solve(str,pattern, i,j-1,dp);\n    }\n    else\n    {\n        return false;\n    }\n}\n    bool isMatch(string s, string p)\n    {\n        vector<vector<int>>dp(s.length(),vector<int>(p.length(),-1));\n        return solve(s,p,s.length()-1,p.length()-1,dp);\n    }\n};",
        views: "2184",
        upvotes: "3",
        author_id: "158",
        problem_id: 45,
      },
      {
        title:
          "Top down Memozation approach using recursion, easy to understand",
        body: "Intuition\n\nthe initial intuition is to use recursion combined with memoization to solve this problem efficiently.Results are stored to avoid redundant computation\nApproach\n\nThe approach involves creation of the dfs function that evaluates the current character.If at any given point of time we exhaust both pattern and match string then we return true\nif i >= len(s) and j >= len(p):\ncache[(i,j)]=True\nif we exhaust all the pattern element then we return False,as there are many element in match string left and it is considered to be not a match\nif j >= len(p):\ncache[(i,j)]=False\nreturn cache[i,j]\nthen we check if match is actually happening or not\n        match = i < len(s) and (s[i] == p[j] or p[j] == '?' or p[j] == '*')\nif match happens and the * is the reason we check if next element in pattern matches current element\nif j<len(p) and p[j] == '*':\n# Match zero characters or match one or more characters\ncache[(i,j)]= dfs(i, j + 1) or (match and dfs(i + 1, j))\nreturn cache[(i,j)]\nif matching had happened due to some other criteria like ? or same value then this part will store that data\n        if match:\n            cache[(i,j)]=dfs(i + 1, j + 1)\n            return cache[(i,j)]\nComplexity\nTime complexity: The time complexity depends on the number of subproblems that need to be solved. In the worst case, each call to dfs may explore multiple branches, resulting in a time complexity of O(m*n), where m is the length of string s and n is the length of pattern p.\nSpace complexity: The space complexity is determined by the size of the memoization cache. Since we store the results of subproblems in the cache, the space complexity is O(m*n), where m is the length of string s and n is the length of pattern p.\nPlease upvote so that i get to know my efforts are worth a change and that will motivate to add contents for more examples\nCode\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        cache={}\n        def dfs(i, j):\n\n            if (i,j) in cache:\n                return cache[i,j]\n\n            if i >= len(s) and j >= len(p):\n                cache[(i,j)]=True\n\n                return cache[(i,j)]\n            if j >= len(p):\n                cache[(i,j)]=False\n                return cache[i,j]\n            \n            match = i < len(s) and (s[i] == p[j] or p[j] == '?' or p[j] == '*')\n            \n            if p[j] == '*':\n                # Match zero characters or match one or more characters\n                cache[(i,j)]= dfs(i, j + 1) or (match and dfs(i + 1, j))\n                return cache[(i,j)]\n            \n            if match:\n                cache[(i,j)]=dfs(i + 1, j + 1)\n                return cache[(i,j)]\n            \n            cache[(i,j)]=False\n        \n        return dfs(0, 0)\n",
        views: "Apr 13, 2024",
        upvotes: "0",
        author_id: "281",
        problem_id: 45,
      },
      {
        title: "44. Wildcard Matching.cpp",
        body: "Code\nclass Solution {\npublic:\n    bool isMatch(string x, string y) {\n        int n = x.size();\n        int m = y.size();\n        bool dy[n+1][m+1];\n        dy[0][0] = true;\n        for(int i=1;i<=n;i++) {\n            dy[i][0] = false;\n        }\n        int h = 1;\n        for(int i=1;i<=m;i++) {\n            if(y[i-1]=='*' and h==1) {\n                dy[0][i] = true;\n            }\n            else {\n                dy[0][i] = false;\n                h = 0;\n            }\n        }\n        for(int i=1;i<=n;i++) {\n            for(int j=1;j<=m;j++) {\n                if(x[i-1]==y[j-1] || y[j-1]=='?') {\n                    dy[i][j] = dy[i-1][j-1];\n                } else if(x[i-1]!=y[j-1] and y[j-1]=='*') {\n                    dy[i][j] = dy[i][j-1] || dy[i-1][j];\n                } else {\n                    dy[i][j] = false;\n                }\n            }\n        }\n        return dy[n][m];\n    }\n};",
        views: "509",
        upvotes: "0",
        author_id: "95",
        problem_id: 45,
      },
      {
        title: "Recursive Memoized & Tabulation DP solutions",
        body: "Recursive Memoized Solution\nComplexity\n\nTime complexity: O(n*m)\nSpace complexity: O(n*m) + Auxilary Space O(n*m)\n\nCode\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int n = size(s), m = size(p);\n        vector<vector<int>> dp(n,vector<int>(m,-1));\n        function<bool(int,int)> f = [&](int i,int j) -> bool {\n            if(i==-1 && j==-1) return true;\n            if(j==-1) return false;\n            if(i==-1) return p[j]=='*'&&f(i,j-1);\n            if(dp[i][j]!=-1) return dp[i][j];\n            dp[i][j] = 0;\n            if(s[i]==p[j]||p[j]=='?') return dp[i][j] = f(i-1,j-1);\n            if(p[j]!='*') return dp[i][j] = false;\n            return dp[i][j] = f(i-1,j)||f(i,j-1);\n        };\n        return f(n-1,m-1);\n    }\n};\nTabulation DP Solution\nComplexity\n\nTime complexity: O(n*m)\nSpace complexity: O(n*m)\n\nCode\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int n = size(s), m = size(p);\n        vector<vector<bool>> dp(n+1,vector<bool>(m+1));\n        dp[0][0] = true;\n\n        if(p[0]=='*') dp[0][1] = true;\n        for(int j=2;j<=m;++j) if(p[j-1]=='*') dp[0][j] = dp[0][j-1];\n\n        for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) {\n            if(s[i-1]==p[j-1] || p[j-1]=='?') dp[i][j] = dp[i-1][j-1];\n            else if(p[j-1]=='*') dp[i][j] = dp[i-1][j] || dp[i][j-1];\n        }\n\n        return dp[n][m];\n    }\n};",
        views: "172",
        upvotes: "1",
        author_id: "138",
        problem_id: 45,
      },
    ],
  },
  {
    title: "45. Jump Game II",
    description:
      "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\n\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n\n\n\t0 <= j <= nums[i] and\n\ti + j < n\n\n\nReturn the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\n\n \nExample 1:\n\nInput: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n\nExample 2:\n\nInput: nums = [2,3,0,1,4]\nOutput: 2\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 104\n\t0 <= nums[i] <= 1000\n\tIt's guaranteed that you can reach nums[n - 1].\n\n",
    difficulty: "Medium",
    acceptance: "74.45",
    frequency: "122.90",
    topics: [
      [
        "Database",
        "Memoization",
        "Hash Function",
        "Binary Indexed Tree",
        "Binary Search Tree",
        "Biconnected Component",
        "Strongly Connected Component",
        "Graph",
        "Backtracking",
        "Minimum Spanning Tree",
      ],
    ],
    languages: [
      [
        "Racket",
        "Erlang",
        "Dart",
        "Go",
        "C#",
        "Ruby",
        "Java",
        "Kotlin",
        "C++",
        "Elixir",
      ],
    ],
    comments: [
      {
        author_id: "147",
        problem_id: 46,
        body: "Я так рад, что решил эту задачу! Это действительно научило меня чему-то новому.",
        comment_reply_id: null,
      },
      {
        author_id: "498",
        problem_id: 46,
        body: "Иногда лучшее решение приходит в голову после нескольких неудачных попыток.",
        comment_reply_id: null,
      },
      {
        author_id: "810",
        problem_id: 46,
        body: "Было трудно, но я нашел путь к решению этой задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "459",
        problem_id: 46,
        body: "Теперь я чувствую, что могу решить что угодно!",
        comment_reply_id: null,
      },
      {
        author_id: "120",
        problem_id: 46,
        body: "Я так рад, что решил эту задачу! Это действительно научило меня чему-то новому.",
        comment_reply_id: null,
      },
      {
        author_id: "37",
        problem_id: 46,
        body: "Сложно даже представить, сколько попыток ушло на решение этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "380",
        problem_id: 46,
        body: "Не могу поверить, что решил это за одну попытку! Сейчас немного в шоке.",
        comment_reply_id: null,
      },
      {
        author_id: "86",
        problem_id: 46,
        body: "Эта задача вынудила меня глубже погрузиться в язык программирования.",
        comment_reply_id: null,
      },
      {
        author_id: "192",
        problem_id: 46,
        body: "Эта задача преподнесла мне неожиданный поворот! Интересно, как многие это заметили.",
        comment_reply_id: null,
      },
      {
        author_id: "553",
        problem_id: 46,
        body: "У кого-нибудь есть идеи, как можно оптимизировать мое решение? Пока я не совсем доволен своим подходом.",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "✅ Swift: Simple and Easy to Understand",
        body: "Code\nclass Solution {\n    func jump(_ nums: [Int]) -> Int {\n        guard 1 <= nums.count && nums.count <= Int(10e4) else { return 0 }\n        \n        return (0..<nums.count-1).reduce(into: (\n            step: 0, \n            end: 0, \n            maxPos: 0)){ jumps, i in\n\n            jumps.maxPos = max(jumps.maxPos, i + nums[i])\n            if (i == jumps.end) { jumps.end = jumps.maxPos; jumps.step += 1 }\n        }.step\n    }\n}",
        views: "3212",
        upvotes: "1",
        author_id: "800",
        problem_id: 46,
      },
      {
        title:
          "C++✅✅ | Faster🧭 than 75%🔥| Straight Forward Method🆗 | Clean And Concise Code |",
        body: "Code\nPlease Do Upvote!!!!\nConnect with me on Linkedin -> https://www.linkedin.com/in/md-kamran-55b98521a/\n\nclass Solution {\npublic:\n\n    int jump(vector<int>& nums) {\n\n      for(int i = 1; i < nums.size(); i++)\n      {\n        nums[i] = max(nums[i] + i, nums[i-1]);\n      }\n\n      int ind = 0;\n      int ans = 0;\n\n      while(ind < nums.size() - 1)\n      {\n        ans++;\n        ind = nums[ind];\n      }\n\n      return ans;\n    }\n};\n\n\n",
        views: "52290",
        upvotes: "424",
        author_id: "66",
        problem_id: 46,
      },
      {
        title:
          "✅ Easy Solutions w/ Explanation | Optimizations from Brute-Force to DP to Greedy BFS",
        body: "❌ Solution - I (Brute Force) [Rejected]\nWe start at index 0 and are required to reach index n - 1 (where n = nums.size()). We can't always do the maximum jump at each index. This can be easily verified by looking at the example test cases.\nSo, at each position, we can use a jump size of anywhere in the range [1, nums[pos]]. The final answer will be the minimum jumps required. We can recursively solve this problem as -\n\nIf we reach index n-1 return 0, signifying that we need 0 more jumps.\nElse recurse for each jump size possible from the current index and return the answer in which we require the minimum number of jumps\n\nint jump(vector<int>& nums, int pos = 0) {\n\tif(pos >= size(nums) - 1) return 0;        \n\tint minJumps = 10001;  // initialising to max possible jumps + 1\n\tfor(int j = 1; j <= nums[pos]; j++)  // explore all possible jump sizes from current position\n\t\tminJumps = min(minJumps, 1 + jump(nums, pos + j));        \n\treturn minJumps;\n}\nTime Complexity : O(N!). At each index i we have N-i choices and we recursively explore each of them till end. So we require O(N*(N-1)*(N-2)...1) = O(N!).\nSpace Complexity : O(N)\n\n✔️ Solution - II (Recursive Dynamic Programming - Memoization) [Accepted]\nWe can see that for a given position, we are repeatedly calculating the same answer over and over again. The jumps required to reach for a given index on the path remains fixed and can be stored in dp array to avoid re-calculations.\nThe solution is similar as the brute force with just the change that we are storing the solutions for each pos and returning it if it is already calculated.\nint jump(vector<int>& nums) {\n\tvector<int> dp(size(nums), 10001); // initialise all to max possible jumps + 1 denoting dp[i] hasn't been computed yet\n\treturn solve(nums, dp, 0);\n}\n// recursive solver to find min jumps to reach end\nint solve(vector<int>& nums, vector<int>& dp, int pos) {\n\tif(pos >= size(nums) - 1) return 0;    // when we reach end, return 0 denoting no more jumps required\n\tif(dp[pos] != 10001) return dp[pos];    // number of jumps from pos to end is already calculated, so just return it\n\t// explore all possible jump sizes from current position. Store & return min jumps required\n\tfor(int j = 1; j <= nums[pos]; j++)\n\t\tdp[pos] = min(dp[pos], 1 + solve(nums, dp, pos + j));        \n\treturn dp[pos];\n}\nTime Complexity : O(N^2)\nSpace Complexity : O(N)\n\n✔️ Solution - III (Iterative Dynamic Programming - Tabulation) [Accepted]\nWe can solve this iteratively as well. For this, we start from the last index. We need 0 jumps from nums[n-1] to reach the end. We store this as dp[n - 1] = 0 and then iteratively solve this for each previous index till the 0th index. Here dp[i] denotes minimum jumps required from current index to reach till the end.\n\nFor each index, we explore all the possible jump sizes available with us.\nThe minimum jumps required to reach the end from the current index would be - min(dp[jumpLen]), where 1 <= jumpLen <= nums[currentPostion]\n\nint jump(vector<int>& nums) {\n\tint n = size(nums);\n\tvector<int> dp(n, 10001);\n\tdp[n - 1] = 0;  // start from last index. No jumps required to reach end if we are already here\n\t// same as above. For each index, explore all jump sizes and use the one requiring minimum jumps to reach end\n\tfor(int i = n - 2; i >= 0; i--) \n\t\tfor(int jumpLen = 1; jumpLen <= nums[i]; jumpLen++) \n\t\t\tdp[i] = min(dp[i], 1 + dp[min(n - 1, i + jumpLen)]);  // min(n-1, i + jumpLen) for bounds handling\n\treturn dp[0];\n}\nTime Complexity : O(N^2)\nSpace Complexity : O(N)\n\n✔️ Solution IV (Greedy BFS)\nWe can iterate over all indices maintaining the furthest reachable position from current index - maxReachable and currently furthest reached position - lastJumpedPos. Everytime we will try to update lastJumpedPos to furthest possible reachable index - maxReachable.\nUpdating the lastJumpedPos separately from maxReachable allows us to maintain track of minimum jumps required. Each time lastJumpedPos is updated, jumps will also be updated and store the minimum jumps required to reach lastJumpedPos (On the contrary, updating jumps with maxReachable won't give the optimal (minimum possible) value of jumps required).\nWe will just return it as soon as lastJumpedPos reaches(or exceeds) last index.\nWe can try to understand the steps in code below as analogous to those in BFS as -\n\n\nmaxReachable = max(maxReachable, i + nums[i]) : Updating the range of next level. Similar to  queue.push(node) step of BFS but here we are only greedily storing the max reachable index on next level.\n\n\ni == lastJumpedPos :  When it becomes true, current level iteration has been completed.\n\n\nlastJumpedPos = maxReachable : Set range till which we need to iterate the next level\n\n\njumps++ : Move on to the next level.\n\n\nreturn jumps : The final answer will be number of levels in BFS traversal.\n\n\nFor eg. Take the example : nums = [2,3,1,4,1,1,1,2]. This approach proceeds as illustrated in image below -\n\n\nint jump(vector<int>& nums) {\n\tint n = size(nums), i = 0, maxReachable = 0, lastJumpedPos = 0, jumps = 0;\n\twhile(lastJumpedPos < n - 1) {  // loop till last jump hasn't taken us till the end\n\t\tmaxReachable = max(maxReachable, i + nums[i]);  // furthest index reachable on the next level from current level\n\t\tif(i == lastJumpedPos) {\t\t\t  // current level has been iterated & maxReachable position on next level has been finalised\n\t\t\tlastJumpedPos = maxReachable;     // so just move to that maxReachable position\n\t\t\tjumps++;                          // and increment the level\n\t// NOTE: jump^ only gets updated after we iterate all possible jumps from previous level\n\t//       This ensures jumps will only store minimum jump required to reach lastJumpedPos\n\t\t}            \n\t\ti++;\n\t}\n\treturn jumps;\n}\nTime Complexity : O(N)\nSpace Complexity : O(1)\n\n\n💻🐱‍💻If there are any suggestions / questions / mistakes in my post, please do comment below 👇\n\n",
        views: "58676",
        upvotes: "867",
        author_id: "328",
        problem_id: 46,
      },
      {
        title:
          "Clean Codes🔥🔥|| Full Explanation✅|| Implicit BFS✅|| C++|| Java|| Python3",
        body: "Intuition :\n\nWe have to find the minimum number of jumps required to reach the end of a given array of non-negative integers i.e the shortest number of jumps needed to reach the end of an array of numbers.\n\n\nExplanation to Approach :\n\nWe are using a search algorithm that works by moving forward in steps and counting each step as a jump.\nThe algorithm keeps track of the farthest reachable position at each step and updates the number of jumps needed to reach that farthest position.\nThe algorithm returns the minimum number of jumps needed to reach the end of the array.\n\n\nComplexity :\n\nTime complexity : O(n)\n\n\n\nSpace complexity: O(1)\n\n\nPlease Upvote👍👍\nThanks for visiting my solution.😊\nCodes [C++ |Java |Python3] with Comments :\nC++JavaPython3class Solution {\n public:\n  int jump(vector<int>& nums) {\n    int ans = 0;\n    int end = 0;\n    int farthest = 0;\n\n    // Implicit BFS\n    for (int i = 0; i < nums.size() - 1; ++i) {\n      farthest = max(farthest, i + nums[i]);\n      if (farthest >= nums.size() - 1) {\n        ++ans;\n        break;\n      }\n      if (i == end) {    // Visited all the items on the current level\n        ++ans;           // Increment the level\n        end = farthest;  // Make the queue size for the next level\n      }\n    }\n\n    return ans;\n  }\n};\nPlease Upvote👍👍\n",
        views: "38613",
        upvotes: "278",
        author_id: "239",
        problem_id: 46,
      },
    ],
  },
  {
    title: "46. Permutations",
    description:
      "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n\n \nExample 1:\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\nExample 2:\nInput: nums = [0,1]\nOutput: [[0,1],[1,0]]\nExample 3:\nInput: nums = [1]\nOutput: [[1]]\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 6\n\t-10 <= nums[i] <= 10\n\tAll the integers of nums are unique.\n\n",
    difficulty: "Medium",
    acceptance: "72.66",
    frequency: "115.19",
    topics: [
      [
        "Binary Search Tree",
        "Counting",
        "Binary Tree",
        "Merge Sort",
        "Queue",
        "Enumeration",
        "Ordered Set",
        "Interactive",
        "Number Theory",
        "Biconnected Component",
      ],
    ],
    languages: [
      [
        "PHP",
        "C",
        "C#",
        "Rust",
        "Kotlin",
        "Scala",
        "Python",
        "Python3",
        "Racket",
        "Ruby",
      ],
    ],
    comments: [
      {
        author_id: "152",
        problem_id: 47,
        body: "Это было круто! Какая следующая задача?",
        comment_reply_id: null,
      },
      {
        author_id: "821",
        problem_id: 47,
        body: "Теперь я чувствую, что могу решить что угодно!",
        comment_reply_id: null,
      },
      {
        author_id: "255",
        problem_id: 47,
        body: "Я просто в восторге от того, как эффективно работает мое решение!",
        comment_reply_id: null,
      },
      {
        author_id: "604",
        problem_id: 47,
        body: "Наконец-то я справился с этой задачей! Вперед к следующей!",
        comment_reply_id: null,
      },
      {
        author_id: "389",
        problem_id: 47,
        body: "Сложно поверить, что я только что решил это! Спасибо всем за поддержку.",
        comment_reply_id: null,
      },
      {
        author_id: "132",
        problem_id: 47,
        body: "Было трудно, но я нашел путь к решению этой задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "527",
        problem_id: 47,
        body: "Эта задача была настоящим испытанием ума! Сложность на высшем уровне.",
        comment_reply_id: null,
      },
      {
        author_id: "836",
        problem_id: 47,
        body: "Кто-нибудь еще решал эту задачу? Хотелось бы услышать ваши мысли!",
        comment_reply_id: null,
      },
      {
        author_id: "549",
        problem_id: 47,
        body: "Это было как головоломка, но я нашел свой путь к решению!",
        comment_reply_id: null,
      },
      {
        author_id: "617",
        problem_id: 47,
        body: "Чувствую, что становлюсь лучше программистом с каждой решенной задачей.",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "【Video】Simple Backtracking Solution",
        body: "Intuition\nUsing backtracking to create all possible combinations\n\nSolution Video\n\n⭐️⭐️ Don't forget to subscribe to my channel! ⭐️⭐️\n■ Subscribe URL\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\nSubscribers: 4,155\nThank you for your support!\n\nApproach\nThis is based on Python solution. Other might be different a bit.\n\n\nThe function permute takes a list of integers nums as input and aims to generate all possible permutations of the elements in the input list.\n\n\nThe base case is checked: if the length of the nums list is 1, then it means there's only one element left to permute, and at this point, a list containing that single element is returned as a permutation.\n\n\nIf the nums list has more than one element, the algorithm proceeds with permutation generation.\n\n\nInitialize an empty list res to store the permutations.\n\n\nIterate over each element in the nums list (using _ as a placeholder for the loop variable). In each iteration, pop the first element n from the nums list.\n\n\nRecursively call the permute function on the remaining elements in nums after removing the first element. This generates all possible permutations of the remaining elements.\n\n\nFor each permutation p generated in the recursive call, append the previously removed element n to it.\n\n\nExtend the res list with the permutations generated in the recursive calls, each with the element n appended.\n\n\nAfter the loop completes, add the removed element n back to the end of the nums list, restoring the original state for the next iteration.\n\n\nFinally, return the list res containing all the generated permutations.\n\n\nIn summary, this code uses a recursive approach to generate all possible permutations of the input list nums. It removes one element at a time, generates permutations for the remaining elements, appends the removed element to those permutations, and collects all permutations in the res list. The recursion continues until only one element is left in the list, at which point a permutation containing that single element is returned.\nComplexity\n\n\nTime complexity: O(n * n!)\n\n\nRecursive Calls: The permute function is called recursively, and each time it generates permutations for a smaller list by removing one element. In the worst case, the recursion depth is equal to the length of the input list nums, which is n.\n\n\nPermutation Generation: For each index, we are generating permutations for the remaining elements and appending the removed element at the end. This involves recursive calls and list manipulations. In general time complexity of permutation should be O(n!)\n\n\n\n\nSpace complexity: O(n)\n\n\nRecursion Depth: The depth of recursion goes up to the number of elements in the input list. So, the maximum recursion depth is O(n).\n\n\nAdditional Memory: The additional memory usage includes the res list, the n variable, and the space used in each recursive call.\nConsidering these factors, the space complexity is O(n)\n\n\n\n\nPythonJavaScriptJavaC++class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        if len(nums) == 1:\n            return [nums[:]]\n        \n        res = []\n\n        for _ in range(len(nums)):\n            n = nums.pop(0)\n            perms = self.permute(nums)\n\n            for p in perms:\n                p.append(n)\n            \n            res.extend(perms)\n            nums.append(n)\n        \n        return res\n            \n\nThis is bonus codes I don't explain in the article.\n\nPythonJavaScriptJavaC++class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            \n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n\n        res = []\n        backtrack(0)\n        return res",
        views: "541",
        upvotes: "10",
        author_id: "587",
        problem_id: 47,
      },
      {
        title:
          "A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palind...",
        body: "This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum.\nSubsets : https://leetcode.com/problems/subsets/\npublic List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\n    list.add(new ArrayList<>(tempList));\n    for(int i = start; i < nums.length; i++){\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n}\nSubsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\n    list.add(new ArrayList<>(tempList));\n    for(int i = start; i < nums.length; i++){\n        if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n} \n\nPermutations : https://leetcode.com/problems/permutations/\npublic List<List<Integer>> permute(int[] nums) {\n   List<List<Integer>> list = new ArrayList<>();\n   // Arrays.sort(nums); // not necessary\n   backtrack(list, new ArrayList<>(), nums);\n   return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n   if(tempList.size() == nums.length){\n      list.add(new ArrayList<>(tempList));\n   } else{\n      for(int i = 0; i < nums.length; i++){ \n         if(tempList.contains(nums[i])) continue; // element already exists, skip\n         tempList.add(nums[i]);\n         backtrack(list, tempList, nums);\n         tempList.remove(tempList.size() - 1);\n      }\n   }\n} \nPermutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/\npublic List<List<Integer>> permuteUnique(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\n    if(tempList.size() == nums.length){\n        list.add(new ArrayList<>(tempList));\n    } else{\n        for(int i = 0; i < nums.length; i++){\n            if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\n            used[i] = true; \n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, used);\n            used[i] = false; \n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n\nCombination Sum : https://leetcode.com/problems/combination-sum/\npublic List<List<Integer>> combinationSum(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\n    if(remain < 0) return;\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\n    else{ \n        for(int i = start; i < nums.length; i++){\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\nCombination Sum II (can't reuse same element) : https://leetcode.com/problems/combination-sum-ii/\npublic List<List<Integer>> combinationSum2(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n    \n}\n\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\n    if(remain < 0) return;\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\n    else{\n        for(int i = start; i < nums.length; i++){\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i + 1);\n            tempList.remove(tempList.size() - 1); \n        }\n    }\n} \nPalindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/\npublic List<List<String>> partition(String s) {\n   List<List<String>> list = new ArrayList<>();\n   backtrack(list, new ArrayList<>(), s, 0);\n   return list;\n}\n\npublic void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\n   if(start == s.length())\n      list.add(new ArrayList<>(tempList));\n   else{\n      for(int i = start; i < s.length(); i++){\n         if(isPalindrome(s, start, i)){\n            tempList.add(s.substring(start, i + 1));\n            backtrack(list, tempList, s, i + 1);\n            tempList.remove(tempList.size() - 1);\n         }\n      }\n   }\n}\n\npublic boolean isPalindrome(String s, int low, int high){\n   while(low < high)\n      if(s.charAt(low++) != s.charAt(high--)) return false;\n   return true;\n} ",
        views: "592948",
        upvotes: "5.5K",
        author_id: "613",
        problem_id: 47,
      },
      {
        title: "permute",
        body: "Intuition\n\nApproach\n\nComplexity\n\nTime complexity:\n\n\n\nSpace complexity:\n\n\nCode\nclass Solution(object):\n    def permute(self, nums):\n        def backtrack(start):\n            if start == len(nums):\n                permutations.append(nums[:])\n            else:\n                for i in range(start, len(nums)):\n                    nums[start], nums[i] = nums[i], nums[start]\n                    backtrack(start + 1)\n                    nums[start], nums[i] = nums[i], nums[start]\n\n        permutations = []\n        backtrack(0)\n        return permutations",
        views: "1022",
        upvotes: "0",
        author_id: "987",
        problem_id: 47,
      },
      {
        title: "first",
        body: "Intuition\n\nApproach\n\nComplexity\n\nTime complexity:\n\n\n\nSpace complexity:\n\n\nCode\nclass Solution(object):\n    def permute(self, nums):\n        def backtrack(start):\n            if start == len(nums):\n                permutations.append(nums[:])\n            else:\n                for i in range(start, len(nums)):\n                    nums[start], nums[i] = nums[i], nums[start]\n                    backtrack(start + 1)\n                    nums[start], nums[i] = nums[i], nums[start]\n\n        permutations = []\n        backtrack(0)\n        return permutations",
        views: "304",
        upvotes: "0",
        author_id: "904",
        problem_id: 47,
      },
    ],
  },
  {
    title: "47. Permutations II",
    description:
      "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n\n \nExample 1:\n\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n\n\nExample 2:\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n\n \nConstraints:\n\n\n\t1 <= nums.length <= 8\n\t-10 <= nums[i] <= 10\n\n",
    difficulty: "Medium",
    acceptance: "16.14",
    frequency: "187.94",
    topics: [
      [
        "Sliding Window",
        "Backtracking",
        "Randomized",
        "String Matching",
        "Two Pointers",
        "Ordered Set",
        "Monotonic Stack",
        "Sorting",
        "Recursion",
        "Data Stream",
      ],
    ],
    languages: [
      [
        "Elixir",
        "C",
        "PHP",
        "JavaScript",
        "C#",
        "Dart",
        "Scala",
        "Ruby",
        "Python3",
        "Kotlin",
      ],
    ],
    comments: [
      {
        author_id: "902",
        problem_id: 48,
        body: "Это моя новая любимая задача! Хочу попробовать еще раз!",
        comment_reply_id: null,
      },
      {
        author_id: "499",
        problem_id: 48,
        body: "Теперь я чувствую, что могу решить что угодно!",
        comment_reply_id: null,
      },
      {
        author_id: "567",
        problem_id: 48,
        body: "Чувствую себя чемпионом после этой задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "679",
        problem_id: 48,
        body: "Было трудно, но я нашел путь к решению этой задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "10",
        problem_id: 48,
        body: "Эта задача была настоящим испытанием ума! Сложность на высшем уровне.",
        comment_reply_id: null,
      },
      {
        author_id: "874",
        problem_id: 48,
        body: "Потратил на решение этой задачи весь день, но это было того стоило!",
        comment_reply_id: null,
      },
      {
        author_id: "219",
        problem_id: 48,
        body: "Сложно даже представить, сколько попыток ушло на решение этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "331",
        problem_id: 48,
        body: "Я так рад, что решил эту задачу! Это действительно научило меня чему-то новому.",
        comment_reply_id: null,
      },
      {
        author_id: "291",
        problem_id: 48,
        body: "Это был настоящий вызов для моего ума, но я его преодолел!",
        comment_reply_id: null,
      },
      {
        author_id: "387",
        problem_id: 48,
        body: "Мой мозг сейчас в кипении от этой задачи.",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title:
          "Video solution ( Must watch ) |  Intuition explained in detail | C++ | Backtracking",
        body: "Video\nHey everyone, i have created video solution for this problem, (its in Hindi) i have solved this problem by backtracking using :\nUsing swap method (more efficient and will clear all your doubts and confusion)\nif you have any consfusion on swap method ( when to swap back and when not to ), i have explained this thing in detail by using concept of pass by value vs. pass by reference, i am 100% sure this will clear all your doubts and will make your backtracking concepts much more clear and stronger.\nlink: \nCode\nclass Solution {\npublic:\n    vector<vector<int>> res;\n    void helper(vector<int> nums, int start){\n        if(start==nums.size()){\n            res.push_back(nums);\n            return;\n        }\n        for(int i=start;i<nums.size();i++){\n            if(i==start || nums[start]!=nums[i]){\n                swap(nums[start],nums[i]);\n                helper(nums,start+1);\n            }\n        }\n        \n    }  \n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        int start=0;\n        sort(nums.begin(), nums.end());\n        helper(nums,start);\n        return res;\n    }\n};",
        views: "707",
        upvotes: "11",
        author_id: "848",
        problem_id: 48,
      },
      {
        title: "Easy Bitmasking and Backtracking solution  || C++ || Python",
        body: "Intuition\nBacktracking + Bitmasking\nCode\nclass Solution {\npublic:\n    int n;\n    set<vector<int>> st;\n    vector<int> ans1;\n    void f(int mask,vector<int>& v){\n        //If all the elements are fitted in the array ans1\n        if(mask==(1<<n)-1){\n            //then we store ans1 vector in the set (why set ? because it will prune the duplicate vectors) \n            st.insert(ans1);\n            return;\n        }\n        for(int i=0;i<n;i++){\n            //checking if ith number in the array is not used in the permutation\n            if((mask&(1<<i))==0){\n                //pick\n                ans1.push_back(v[i]);\n                f(mask^(1<<i),v);\n                //drop (pick and drop are part of backtracking)\n                ans1.pop_back();\n            }\n        }\n        return ;\n    }\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        n = nums.size();\n        f(0,nums);\n        vector<vector<int>> ans;\n        //storing all the elements of the set in the ans vector of vector since return type is vector of vector\n        for(auto it:st){\n            ans.push_back(it);\n        }\n        return ans;\n    }\n};\nPython Code\nclass Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        st =set()\n        ans =[]\n        n = len(nums)\n        ans1 =[]\n        def f(mask):\n            nonlocal ans1\n            if mask == (1<<n)-1:\n                st.add(tuple(ans1.copy()))\n                return\n            for i in range(n):\n                if (mask&(1<<i))==0:\n                    ans1.append(nums[i])\n                    f(mask^(1<<i))\n                    ans1.pop()\n            return\n\n        f(0)\n        for i in st:\n            ans.append(i)\n        return ans",
        views: "2064",
        upvotes: "1",
        author_id: "982",
        problem_id: 48,
      },
      {
        title: "Lexicographic generation",
        body: "Intuition\nGenerate permutation lexicographically.\nApproach\nImplement directly the Algorithm L (Lexicographic permutation generation) described in 7.2.1.2 TAoCP Volume 4A.\nComplexity\n\nTime complexity: O(n!)\\mathcal{O}(n!)O(n!)\n\n\n\nSpace complexity: O(n)\\mathcal{O}(n)O(n)\n\n\nCode\nimpl Solution {\n    pub fn permute_unique(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut nums = nums;\n        (&mut nums).sort_unstable();\n\n        let n = Vec::len(&nums);\n\n        let mut perms = Vec::new();\n        loop {\n            // L1\n            perms.push(Vec::clone(&nums));\n\n            // L2\n            let (mut j, mut increased) = (n - 1, true);\n            while j > 0 && increased {\n                j -= 1;\n                increased = nums[j] >= nums[j + 1];\n            }\n            if increased {\n                break;\n            }\n\n            // L3\n            let mut l = n - 1;\n            while nums[j] >= nums[l] {\n                l -= 1;\n            }\n            (&mut nums).swap(j, l);\n\n            // L4\n            l = n - 1;\n            j = j + 1;\n            while j < l {\n                (&mut nums).swap(j, l);\n                l -= 1;\n                j += 1;\n            }\n        }\n\n        perms\n    }\n}",
        views: "509",
        upvotes: "1",
        author_id: "140",
        problem_id: 48,
      },
      {
        title: "Golang simple solution using recursion",
        body: "Intuition\n\nApproach\n\nComplexity\n\nTime complexity: fac(n)\n\n\n\nSpace complexity: O(n)\n\n\nCode\nfunc permuteUnique(nums []int) [][]int {\n    var result [][]int\n    helper(nums,0,len(nums),&result)\n    return result\n}\nfunc helper(nums []int, l,n int,result *[][]int){\n    if l==n{\n        arr:=make([]int,n)\n        copy(arr,nums)\n        *result=append(*result,arr)\n    }\n    hash:=make(map[int]bool)\n    for i:=l; i<n; i++{\n        if !hash[nums[i]] {\n            hash[nums[i]]=true\n            nums[i],nums[l]=nums[l],nums[i]\n            helper(nums,l+1,n,result)\n            nums[i],nums[l]=nums[l],nums[i]\n        }\n    }\n}",
        views: "158",
        upvotes: "1",
        author_id: "804",
        problem_id: 48,
      },
    ],
  },
  {
    title: "48. Rotate Image",
    description:
      "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\n\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n\n \nExample 1:\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\n\n\nExample 2:\n\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\n\n \nConstraints:\n\n\n\tn == matrix.length == matrix[i].length\n\t1 <= n <= 20\n\t-1000 <= matrix[i][j] <= 1000\n\n",
    difficulty: "Medium",
    acceptance: "47.17",
    frequency: "111.41",
    topics: [
      [
        "Simulation",
        "Hash Table",
        "Sorting",
        "Strongly Connected Component",
        "Collapse",
        "Backtracking",
        "Sliding Window",
        "Prefix Sum",
        "Heap (Priority Queue)",
        "Memoization",
      ],
    ],
    languages: [
      [
        "C++",
        "Ruby",
        "Racket",
        "Erlang",
        "C",
        "Python3",
        "Dart",
        "Java",
        "Kotlin",
        "Swift",
      ],
    ],
    comments: [
      {
        author_id: "645",
        problem_id: 49,
        body: "Сложно даже представить, сколько попыток ушло на решение этой задачи.",
        comment_reply_id: null,
      },
      {
        author_id: "27",
        problem_id: 49,
        body: "Иногда простые решения лучше всех! Не всегда нужно усложнять.",
        comment_reply_id: null,
      },
      {
        author_id: "556",
        problem_id: 49,
        body: "Кто бы мог подумать, что решение окажется настолько простым!",
        comment_reply_id: null,
      },
      {
        author_id: "551",
        problem_id: 49,
        body: "Не могу поверить, что я наконец-то разобрался с этой задачей. Спасибо, сообщество!",
        comment_reply_id: null,
      },
      {
        author_id: "737",
        problem_id: 49,
        body: "Иногда лучшее решение приходит в голову после нескольких неудачных попыток.",
        comment_reply_id: null,
      },
      {
        author_id: "899",
        problem_id: 49,
        body: "Потратил на решение этой задачи весь день, но это было того стоило!",
        comment_reply_id: null,
      },
      {
        author_id: "716",
        problem_id: 49,
        body: "Не могу поверить, что я решил это без помощи Google!",
        comment_reply_id: null,
      },
      {
        author_id: "876",
        problem_id: 49,
        body: "Сложно поверить, что я только что решил это! Спасибо всем за поддержку.",
        comment_reply_id: null,
      },
      {
        author_id: "613",
        problem_id: 49,
        body: "Как я мог пропустить этот трюк? Благодарю за подсказку!",
        comment_reply_id: null,
      },
      {
        author_id: "552",
        problem_id: 49,
        body: "Иногда лучшее решение приходит в голову после нескольких неудачных попыток.",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "🚀[Animation] - Understand in 30 seconds",
        body: "upvoting the answer will motivate me to create more animations! Thanks.\nApproach\n2 Steps to rotate image\n\nTranspose the matrix\nSwap the columns\n\n\nCode\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int row = matrix.size();\n        for(int i=0;i<row; i++){\n            for(int j=0; j<=i;j++){\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n        for(int i=0;i<row;i++){\n            reverse(matrix[i].begin(), matrix[i].end());\n        }\n    }\n};",
        views: "49461",
        upvotes: "941",
        author_id: "490",
        problem_id: 49,
      },
      {
        title: "A common method to rotate the image",
        body: "here give a common method to solve the image rotation problems.\n/*\n * clockwise rotate\n * first reverse up to down, then swap the symmetry \n * 1 2 3     7 8 9     7 4 1\n * 4 5 6  => 4 5 6  => 8 5 2\n * 7 8 9     1 2 3     9 6 3\n*/\nvoid rotate(vector<vector<int> > &matrix) {\n    reverse(matrix.begin(), matrix.end());\n    for (int i = 0; i < matrix.size(); ++i) {\n        for (int j = i + 1; j < matrix[i].size(); ++j)\n            swap(matrix[i][j], matrix[j][i]);\n    }\n}\n\n/*\n * anticlockwise rotate\n * first reverse left to right, then swap the symmetry\n * 1 2 3     3 2 1     3 6 9\n * 4 5 6  => 6 5 4  => 2 5 8\n * 7 8 9     9 8 7     1 4 7\n*/\nvoid anti_rotate(vector<vector<int> > &matrix) {\n    for (auto vi : matrix) reverse(vi.begin(), vi.end());\n    for (int i = 0; i < matrix.size(); ++i) {\n        for (int j = i + 1; j < matrix[i].size(); ++j)\n            swap(matrix[i][j], matrix[j][i]);\n    }\n}",
        views: "285933",
        upvotes: "3.9K",
        author_id: "576",
        problem_id: 49,
      },
      {
        title: "Beats 100% users with easy explanation",
        body: "Intuition\nTranspose matrix and then observing pattern\n\nApproach\nFirst, find the transpose of the given matrix by swapping all non-diagonal elements. Then, observe that reversing the rows will yield the same result. You can achieve this by using a two-pointer approach: place one pointer at the beginning and one at the end of each row, then swap their elements iteratively until reaching the middle of the row.\nComplexity\n\n\nTime complexity:\nO(n^2)\n\n\nSpace complexity:\nO(1)\n\n\nCode\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        for(int i=0;i<n-1;i++){\n            for(int j=i+1;j<n;j++){\n                swap(matrix[i][j],matrix[j][i]); \n            }\n        }\n        for(int i=0;i<n;i++){\n            reverse(matrix[i].begin(), matrix[i].end());\n        }\n    }\n};",
        views: "111",
        upvotes: "1",
        author_id: "588",
        problem_id: 49,
      },
      {
        title: "Beats 100% | Easy and intuitive |",
        body: "Code\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int l = matrix.length;\n        int i=0;\n        int j= l-1;\n        while(i<j) {\n            for(int count=0; i+count<j; count++){\n                rotate(matrix, i, j, count);\n            }\n            i++; j--;\n        }\n    }\n\n    public void rotate(int[][] matrix, int i, int j, int count ) {\n        int temp = matrix[i][i+count];\n        matrix[i][i+count] = matrix[j-count][i];\n        matrix[j-count][i] = matrix[j][j-count];\n        matrix[j][j-count] = matrix[i+count][j];\n        matrix[i+count][j] = temp;\n    }\n}",
        views: "372",
        upvotes: "1",
        author_id: "241",
        problem_id: 49,
      },
    ],
  },
  {
    title: "49. Group Anagrams",
    description:
      'Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n \nExample 1:\nInput: strs = ["eat","tea","tan","ate","nat","bat"]\nOutput: [["bat"],["nat","tan"],["ate","eat","tea"]]\nExample 2:\nInput: strs = [""]\nOutput: [[""]]\nExample 3:\nInput: strs = ["a"]\nOutput: [["a"]]\n\n \nConstraints:\n\n\n\t1 <= strs.length <= 104\n\t0 <= strs[i].length <= 100\n\tstrs[i] consists of lowercase English letters.\n\n',
    difficulty: "Medium",
    acceptance: "73.91",
    frequency: "186.45",
    topics: [
      [
        "Interactive",
        "Prefix Sum",
        "Data Stream",
        "Tree",
        "Ordered Set",
        "Shell",
        "Combinatorics",
        "Line Sweep",
        "Math",
        "Array",
      ],
    ],
    languages: [
      [
        "Scala",
        "Swift",
        "Python3",
        "Dart",
        "Rust",
        "PHP",
        "Elixir",
        "C",
        "TypeScript",
        "Racket",
      ],
    ],
    comments: [
      {
        author_id: "94",
        problem_id: 50,
        body: "Благодаря этой задаче я узнал о новой функции языка программирования.",
        comment_reply_id: null,
      },
      {
        author_id: "724",
        problem_id: 50,
        body: "Как я мог не догадаться о таком подходе? Спасибо за отличное объяснение!",
        comment_reply_id: null,
      },
      {
        author_id: "399",
        problem_id: 50,
        body: "Эта задача заставила меня подумать вне коробки. Очень интересное решение!",
        comment_reply_id: null,
      },
      {
        author_id: "65",
        problem_id: 50,
        body: "Чувствую себя чемпионом после этой задачи!",
        comment_reply_id: null,
      },
      {
        author_id: "936",
        problem_id: 50,
        body: "Эта задача мне не давала покоя, но теперь я горд собой!",
        comment_reply_id: null,
      },
      {
        author_id: "284",
        problem_id: 50,
        body: "Эта задача вынудила меня глубже погрузиться в язык программирования.",
        comment_reply_id: null,
      },
      {
        author_id: "885",
        problem_id: 50,
        body: "Идея для этого решения пришла ко мне во сне! Удивительно, как мозг работает иногда.",
        comment_reply_id: null,
      },
      {
        author_id: "812",
        problem_id: 50,
        body: "Чувствую, что становлюсь лучше с каждой решенной задачей!",
        comment_reply_id: null,
      },
      {
        author_id: "194",
        problem_id: 50,
        body: "Кто бы мог подумать, что решение окажется настолько простым!",
        comment_reply_id: null,
      },
      {
        author_id: "87",
        problem_id: 50,
        body: "Кто-нибудь еще решал эту задачу? Хотелось бы услышать ваши мысли!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title:
          "✅Beats 100% || C++ || JAVA || PYTHON || Beginner Friendly🔥🔥🔥",
        body: 'Intuition:\nThe intuition is to group words that are anagrams of each other together. Anagrams are words that have the same characters but in a different order.\nExplanation:\nLet\'s go through the code step by step using the example input ["eat","tea","tan","ate","nat","bat"] to understand how it works.\n\n\nInitializing Variables\n\nWe start by initializing an empty unordered map called mp (short for map), which will store the groups of anagrams.\n\n\n\nGrouping Anagrams\nWe iterate through each word in the input vector strs. Let\'s take the first word, "eat", as an example.\n\n\nSorting the Word\nWe create a string variable called word and assign it the value of the current word ("eat" in this case).\nNext, we sort the characters in word using the sort() function. After sorting, word becomes "aet".\n\n\nGrouping the Anagram\nWe insert word as the key into the mp unordered map using mp[word], and we push the original word ("eat") into the vector associated with that key using mp[word].push_back(x), where x is the current word.\nSince "aet" is a unique sorted representation of all the anagrams, it serves as the key in the mp map, and the associated vector holds all the anagrams.\n\n\n\n\nFor the given example, the mp map would look like this after processing all the words:\n{\n  "aet": ["eat", "tea", "ate"],\n  "ant": ["tan", "nat"],\n  "abt": ["bat"]\n}\n\n\nCreating the Result\nWe initialize an empty vector called ans (short for answer) to store the final result.\n\nWe iterate through each key-value pair in the mp map using a range-based for loop. For each pair, we push the vector of anagrams (x.second) into the ans vector.\n\n\n\nFor the given example, the ans vector would look like this:\n[\n  ["eat", "tea", "ate"],\n  ["tan", "nat"],\n  ["bat"]\n]\n\nReturning the Result\nWe return the ans vector, which contains the groups of anagrams.\n\nCode\nC++JavaPython3class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> mp;\n        \n        for(auto x: strs){\n            string word = x;\n            sort(word.begin(), word.end());\n            mp[word].push_back(x);\n        }\n        \n        vector<vector<string>> ans;\n        for(auto x: mp){\n            ans.push_back(x.second);\n        }\n        return ans;\n    }\n};\n\nIf you are a beginner solve these problems which makes concepts clear for future coding:\n\nTwo Sum\nRoman to Integer\nPalindrome Number\nMaximum Subarray\nRemove Element\nContains Duplicate\nAdd Two Numbers\nMajority Element\nRemove Duplicates from Sorted Array\nValid Anagram\nGroup Anagrams\nPractice them in a row for better understanding and please Upvote for more questions.\n\nIf you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.',
        views: "162990",
        upvotes: "1.4K",
        author_id: "584",
        problem_id: 50,
      },
      {
        title: "Fast",
        body: "Code\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& words) {\n        // Unordered map to store anagram groups\n        unordered_map<string, vector<string>> anagramGroups;\n        \n        // Iterate through each word in the input vector\n        for (const string& word : words) {\n            // Sort the characters in the word to create a key\n            string key = word;\n            sort(key.begin(), key.end());\n            \n            // If key is not in the map, add a new entry with the word as a vector\n            if (anagramGroups.find(key) == anagramGroups.end()) {\n                anagramGroups[key] = {word};\n            }\n            // If key is already present, append the word to the existing vector\n            else {\n                anagramGroups[key].push_back(word);\n            }\n        }\n        \n        // Convert map values to a vector and return\n        vector<vector<string>> result;\n        for (const auto& group : anagramGroups) {\n            result.push_back(group.second);\n        }\n        \n        return result;\n    }\n};",
        views: "1981",
        upvotes: "3",
        author_id: "346",
        problem_id: 50,
      },
      {
        title: "Anagram Solution in c++",
        body: "Intuition\nThe problem requires grouping anagrams together. An anagram is a word formed by rearranging the letters of another, such as \"listen\" and \"silent\". One way to solve this problem is by using a hashmap where the keys represent the unique signatures of the words (sorted characters), and the values are vectors containing the anagrams corresponding to that signature.\nApproach\nCreate an unordered_map groups where the keys are signatures of words and the values are vectors of strings (anagrams).\nIterate through each word in the input vector strs.\nFor each word, create its signature by sorting its characters.\nUse the signature as the key to group the word with its anagrams.\nIterate through the groups hashmap and push the vectors of anagrams into the result vector.\nReturn the result.\nComplexity\n\n\nTime complexity:\nConstructing each signature takes O(k log k) time, where k is the length of the longest string in strs.\nWe iterate through each string in strs, so the total time complexity is O(n * k log k), where n is the number of strings in strs.\n\n\nSpace complexity:\nWe use extra space to store the hashmap groups, which can contain at most n keys, and each value can have a maximum of k strings. So, the space complexity is O(n * k).\n\n\nCode\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,vector<string>>groups;\n        for(const string& s:strs){\n            string signature(26,'o');\n            for(char c:s){\n                signature[c-'a']++;\n            }\n            groups[signature].push_back(s);\n        }\n        vector<vector<string>> result;\n        for(const auto& entry: groups){\n            result.push_back(entry.second);\n        }\n        return result;\n    }\n};",
        views: "903",
        upvotes: "2",
        author_id: "49",
        problem_id: 50,
      },
      {
        title: "9 line code for Beginners in java",
        body: "Approach\n\n\n\nTo group anagrams, use a hash map where thekeys are sorted versions of the strings and the values are lists of original strings.\n\n\nIterate through each string, sort its characters, and use this sorted string as the key in the hash map. Add theoriginal string to the list corresponding to this key.\n\n\nAfter processing all strings, the hash map will contain lists of anagrams grouped together. Return these lists as the final result.\n\n\nCode\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> map = new HashMap<>();\n        \n        for (String str : strs) {\n            char[] chars = str.toCharArray();\n            Arrays.sort(chars);\n            String sortedStr = new String(chars);\n            if (!map.containsKey(sortedStr)) {\n                map.put(sortedStr, new ArrayList<>());\n            }\n            map.get(sortedStr).add(str);\n        }\n      return new ArrayList<>(map.values());\n    }\n}\n\n",
        views: "59",
        upvotes: "2",
        author_id: "283",
        problem_id: 50,
      },
    ],
  },
  {
    title: "50. Pow(x, n)",
    description:
      "Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\n\n \nExample 1:\n\nInput: x = 2.00000, n = 10\nOutput: 1024.00000\n\n\nExample 2:\n\nInput: x = 2.10000, n = 3\nOutput: 9.26100\n\n\nExample 3:\n\nInput: x = 2.00000, n = -2\nOutput: 0.25000\nExplanation: 2-2 = 1/22 = 1/4 = 0.25\n\n\n \nConstraints:\n\n\n\t-100.0 < x < 100.0\n\t-231 <= n <= 231-1\n\tn is an integer.\n\tEither x is not zero or n > 0.\n\t-104 <= xn <= 104\n\n",
    difficulty: "Medium",
    acceptance: "53.23",
    frequency: "152.22",
    topics: [
      [
        "Randomized",
        "Divide and Conquer",
        "Combinatorics",
        "Simulation",
        "Heap (Priority Queue)",
        "Binary Search Tree",
        "Probability and Statistics",
        "Stack",
        "Bit Manipulation",
        "Ordered Set",
      ],
    ],
    languages: [
      [
        "Elixir",
        "Java",
        "Swift",
        "Python3",
        "TypeScript",
        "Kotlin",
        "Erlang",
        "C#",
        "Python",
        "Rust",
      ],
    ],
    comments: [
      {
        author_id: "759",
        problem_id: 51,
        body: "Эта задача была настоящим испытанием ума! Сложность на высшем уровне.",
        comment_reply_id: null,
      },
      {
        author_id: "89",
        problem_id: 51,
        body: "Сколько времени я потратил на решение этой задачи? Не считаясь!",
        comment_reply_id: null,
      },
      {
        author_id: "864",
        problem_id: 51,
        body: "Эта задача мне не давала покоя, но теперь я горд собой!",
        comment_reply_id: null,
      },
      {
        author_id: "659",
        problem_id: 51,
        body: "Сложно поверить, что я только что решил это! Спасибо всем за поддержку.",
        comment_reply_id: null,
      },
      {
        author_id: "863",
        problem_id: 51,
        body: "Идея для этого решения пришла ко мне во сне! Удивительно, как мозг работает иногда.",
        comment_reply_id: null,
      },
      {
        author_id: "634",
        problem_id: 51,
        body: "Самая сложная часть в этой задаче - это формулировка.",
        comment_reply_id: null,
      },
      {
        author_id: "830",
        problem_id: 51,
        body: "Чувствую, что становлюсь лучше с каждой решенной задачей!",
        comment_reply_id: null,
      },
      {
        author_id: "300",
        problem_id: 51,
        body: "Я так рад, что решил эту задачу! Это действительно научило меня чему-то новому.",
        comment_reply_id: null,
      },
      {
        author_id: "645",
        problem_id: 51,
        body: "Эта задача мне не давала покоя, но теперь я горд собой!",
        comment_reply_id: null,
      },
      {
        author_id: "188",
        problem_id: 51,
        body: "Я просто в восторге от того, как эффективно работает мое решение!",
        comment_reply_id: null,
      },
    ],
    solutions: [
      {
        title: "Easy understanding recursive solution",
        body: "Intuition\nAfter tried direclty multiply the number based on the power one by one, I got Time Limit Exceeded error. So Here is the revised version.\nThink about some examples:\n\n36=(32)3=(32)2∗(32)=32∗32∗323^6 = (3^2)^3 = (3^2)^2*(3^2)=3^2*3^2*3^236=(32)3=(32)2∗(32)=32∗32∗32\n35=(32)2∗3=32∗32∗33^5 = (3^2)^2 * 3 = 3^2*3^2*335=(32)2∗3=32∗32∗3\nsame for negative power\n\nSo whenever the power is even we pass in x as x*x and n as n/2 recursively\nand when power is odd we pass in x as x*x and n as n//2 (floor division since it's odd) and times x it self (reminder of 2 which is power of 1)\nIn combine, we can write as follow:\nApproach\n\nFirst the base case:\n\nWhen n is 0 resut is 1\nWhen n is -1 result is 1/x\nWhen n is 1 result is x\n\nThen think about the possible senarios, when n is even and when n is odd\nComplexity\n\n\nTime complexity:\nO(logn)\n\n\nSpace complexity:\nO(1)\n\n\nCode\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n == 0:\n            return 1\n\n        if n == -1:\n            return 1/x\n        \n        if n == 1:\n            return x\n\n        return self.myPow(x*x, n//2) * self.myPow(x, n % 2)\n",
        views: "188",
        upvotes: "1",
        author_id: "482",
        problem_id: 51,
      },
      {
        title:
          "✅ [JAVA / C++] : Simple | O log(n) | Easy | Faster than 100% | Explained",
        body: "\n\nFIRST APPROACH\nWe can solve this problem by multiplying x by n times\neg:\nx = 7 and n = 11\n7 * 7 * 7 * 7 * 7 * 7 * 7 * 7 * 7 * 7 * 7 = 1977326743\nHere we have multiplied 7 for 11 times, which will result in O(n)\nBut, Suppose x = 1 and n = 2147483647\nIf we follow this approach then, 1 will be multiplied 2147483647 times which is not efficient at all.\n\n\nCOMPLEXITY\n\nTime: O(n), where n is the given power\nSpace: O(1), in-place\n\n\n\n\n\n\nSECOND  APPROACH\nIn order to improve efficiency we will opt for Binary Exponentiation using which we can calculate xn using O log2(N) multiplications.\nBasic Idea is to divide the work using binary representation of exponents\ni.e. is to keep multiplying pow with x, if the bit is odd, and multiplying x with itself until we get 0\nWe will use very 1st example of 1st Approach i.e.\nx = 7, n = 11 and pow = 1\nHere, we have to calculate 711\nBinary of n i.e. (11)10 is (1011)2\n1   0   1   1\n23  22  21  20    <-- Corresponding place values of each bit\nOR we can also write this as\n1  0  1  1\n8 4 2 1  <-- Corresponding place values of each bit\nNow, 78 × 72 × 71 == 711 as 7(8 + 2 + 1) == 711\nNOTE:  We have not considered 74 in this case as the 4th place bit is OFF\nSo, 78 × 72 × 71 == 5764801 × 49 × 7 == 1977326743 <-- Desired Output\nNow, applying logic keeping this concept in mind\ndouble pow = 1;\nwhile(n != 0){\n\tif((n & 1) != 0) // equivalent to if((n % 2) != 0) i.e. multiply only when the number is odd  \n\tpow *= x;\n\n\tx *= x;\n\tn >>>= 1; // equivalent to n = n / 2; i.e. keep dividing the number by 2\n\n}\n\n\nPROCESS\n\n\nIteration 1\npow = 1 × 7 = 7\nx = 7 × 7 = 49\nn = 11 >>> 1 = 5\n\n\nIteration 2\npow = 7 × 49 = 343\nx = 49 × 49 = 2401\nn = 5 >>> 1 = 2\n\n\nIteration 3\nx = 2401 × 2401 = 5764801\nn = 2 >>> 1 = 1\n\n\nIteration 4\npow = 343 × 5764801 = 1977326743\nx = 5764801 × 5764801 = 3.323293057 × 10¹³\nn = 1 >>> 1 = 0\n\n\n\n\nWe exit the loop as the number has become 0 and we got pow as 1977326743 which is the desired output\nIn this binary exponentiation approach, the loop iterated for only 4 times which is nothing but (O log2(N) + 1) ~ (O log2(N))\nAnd for 2nd example of 1st Approach where\nx = 1 and n = 2147483647\nThis loop executed for only 31 times (O log2(N)) which is far far less than 2147483647 times(in case of O(N) approach)\n\n\nJAVA / C++ CODE\n  \n\n\nCOMPLEXITY\n\nTime: O(log2(n)), where n is the given power\nSpace: O(1), in-place\n\n\n\n\n\n\n\nRefer to the following github repsitory for more leetcode solutions\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\nPlease UPVOTE if you find this post helpful :)",
        views: "87760",
        upvotes: "950",
        author_id: "582",
        problem_id: 51,
      },
      {
        title:
          "👏Beats 100.00% of users with Java || ✅✅Simple & Easy Well Explained Solution using loop🔥💥",
        body: "Intuition\n\nFind x power of n and store in ans, after that check if n is positive then return ans else 1/ans.\nIterate untill n is positive, and Check if n is even then x replaced by x*x and n/n else ans replace by ans * x and n decreased by 1.\n\nI Think This Can Help You(For Proof Click on the Image)\n\nApproach\n\nInitlize double variable ans as 1, beacuse if we multiply anything with 1 answer will be same and Initilize long variable n_temp as n, beacuse we use temporary n.\ndouble ans=1;\nlong n_temp = n;\n\nCheck if n_temp is negative convert to positive, beacuse we decrease n_temp loop will be go infinity.\nif(n_temp<0){\n    n_temp *= -1;\n}\n\nIterate loop untill n_temp is more than 0(Below code is in the loop)\n\nCheck if n_temp is even then make x is equals to xx and n_temp reduced by half else make ans is equals to ansx and n_temp decreased by 1.\n\nwhile(n_temp>0){\n    if(n_temp%2==0){\n        x = x*x;\n        n_temp = n_temp/2;\n    }else{\n        ans = ans * x;\n        n_temp--;\n    }\n}\n\nCheck if absolute n is negetive than return 1/ans.\nif(n<0){\n        return (double) 1/ans;\n}\n\nif n is positive simplly return ans.\nreturn ans;\n\n\nComplexity\n\n\nTime complexity:\nO(log(2)n)   --> log n base 2\n\n\nSpace complexity:\nO(1)\n\n\nCode\nclass Solution {\n    public double myPow(double x, int n) {\n        double ans=1;\n        long n_temp = n;\n        if(n_temp<0){\n            n_temp *= -1;\n        }\n        while(n_temp>0){\n            if(n_temp%2==0){\n                x = x*x;\n                n_temp = n_temp/2;\n            }else{\n                ans = ans * x;\n                n_temp--;\n            }\n        }\n        if(n<0){\n            return (double) 1/ans;\n        }\n        return ans;\n    }\n}\n",
        views: "4938",
        upvotes: "29",
        author_id: "665",
        problem_id: 51,
      },
      {
        title:
          "✅☑️ Best C++ 5 Solution || Math || Recursion || Brute Force -> Optimize || One Stop Solution.",
        body: "Intuition\n\nWe can solve this question using math and recursion.\nApproach\n\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\nComplexity\n\nTime complexity:\n\n\nTime complexity is given in code comment.\n\nSpace complexity:\n\n\nSpace complexity is given in code comment.\nCode\n/*\n\n    Time Complexity : O(N), because we call the recurtion until we multiply the base exponent times. Thus the\n    time complexity is linear.\n\n    Space Complexity : O(N), Recursion stack space.\n\n*/\n\n\n/***************************************** Approach 1 *****************************************/\n\nclass Solution {\nprivate:\n    double power(double x, int n){\n        if(n==0){\n            return 1;\n        }\n        return x * power(x, n-1);\n    }\npublic:\n    double myPow(double x, int n) {\n        if (n == INT_MAX) return (x == 1) ? 1 : (x == -1) ? -1 : 0;\n        if (n == INT_MIN) return (x == 1 || x == -1) ? 1 : 0;\n        double num = 1;\n        if(n>=0){\n            num = power(x, n);\n        }\n        else{\n            n = -n;\n            num = power(x, n);\n            num = 1.0/num;\n        }\n        return num;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(N), because we loop until we multiply the base exponent times. Thus the time complexity\n    is linear.\n\n    Space Complexity : O(1), Constant space.\n\n*/\n\n\n/***************************************** Approach 2 *****************************************/\n\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        if (n == INT_MAX) return (x == 1) ? 1 : (x == -1) ? -1 : 0;\n        if (n == INT_MIN) return (x == 1 || x == -1) ? 1 : 0;\n        double num = 1;\n        if(n>=0){\n            while(n>0){\n                num *= x;\n                n--;\n            }\n        }\n        else{\n            n = -n;\n            while(n>0){\n                num *= x;\n                n--;\n            }\n            num = 1.0/num;\n        }\n        return num;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(logN).\n\n    Space Complexity : O(logN), Recursion stack space.\n\n*/\n\n\n/***************************************** Approach 3 *****************************************/\n\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        if(n==0) return 1;\n        if(n<0) {\n            n = abs(n);\n            x = 1/x;\n        }\n        if(n%2==0){\n            return myPow(x*x, n/2);\n        }\n        else{\n            return x*myPow(x, n-1);\n        }\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(logN).\n\n    Space Complexity : O(1), Constant space.\n\n*/\n\n\n/***************************************** Approach 4 *****************************************/\n\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        double num = 1;\n        long long nn = n;\n        if(nn < 0) nn = -nn;\n        while(nn>0){\n            if(nn%2==1){\n                num = num * x;\n                nn--;\n            }\n            else{\n                x = x*x;\n                nn/=2;\n            }\n        }\n        if(n < 0){\n            num = 1.0/num;\n        }\n        return num;\n    }\n};\n\n\n\n\n\n\n/*\n\n    Time Complexity : O(logN).\n\n    Space Complexity : O(logN), Constant space.\n\n*/\n\n\n/***************************************** Approach 5 *****************************************/\n\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        return pow(x, n);\n    }\n};\n\n\n\nIF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.\n",
        views: "45547",
        upvotes: "233",
        author_id: "2",
        problem_id: 51,
      },
    ],
  },
];
module.exports = data;
